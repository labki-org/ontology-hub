---
phase: 17-graph-view-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/graph_query.py
  - backend/app/schemas/graph.py
autonomous: true

must_haves:
  truths:
    - "Graph API returns property nodes for categories that have properties"
    - "Graph API returns subobject nodes for categories that use subobjects"
    - "Graph API returns template nodes associated with categories"
    - "Edges connect categories to their properties, subobjects, and templates"
  artifacts:
    - path: "backend/app/services/graph_query.py"
      provides: "Extended graph query with property/subobject/template node retrieval"
      contains: "property|subobject|template"
    - path: "backend/app/schemas/graph.py"
      provides: "Graph edge types for property/subobject/template relationships"
  key_links:
    - from: "backend/app/services/graph_query.py"
      to: "CategoryProperty table"
      via: "SQL join to get property nodes"
      pattern: "category_property|CategoryProperty"
    - from: "backend/app/services/graph_query.py"
      to: "canonical_json.subobjects"
      via: "JSON extraction for subobject relationships"
      pattern: "subobjects"
---

<objective>
Extend the graph query API to return property, subobject, and template nodes alongside category nodes, with edges representing the relationships between them.

Purpose: Enable the frontend graph visualization to display all entity types as distinct nodes, fulfilling requirements GRAPH-01, GRAPH-02, and GRAPH-03.

Output: Extended GraphQueryService that returns property/subobject/template nodes when queried for a category's neighborhood graph.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-graph-view-fixes/17-CONTEXT.md
@.planning/phases/17-graph-view-fixes/17-RESEARCH.md

# Key source files
@backend/app/services/graph_query.py
@backend/app/schemas/graph.py
@backend/app/models/v2/relationships.py
@backend/app/models/v2/category.py
@backend/app/models/v2/property.py
@backend/app/models/v2/subobject.py
@backend/app/models/v2/template.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add property nodes and edges to graph response</name>
  <files>
    backend/app/services/graph_query.py
  </files>
  <action>
Extend `get_neighborhood_graph` method in GraphQueryService to include property nodes:

1. After collecting category nodes, query the `category_property` relationship table to find all properties directly assigned to categories in the neighborhood.

2. For each property found:
   - Query the `properties` table to get property details (entity_key, label)
   - Create a GraphNode with entity_type="property"
   - Apply draft overlay to get change_status
   - Add module membership (properties can belong to modules via module_entity table)

3. Create GraphEdge entries with edge_type="property" for each category->property relationship.

4. The property nodes should be at depth=1 relative to their parent category (or null if category has no depth).

5. Also extend `get_module_graph` similarly to include properties belonging to the module.

Use existing patterns from the category node creation. Query structure:
```python
# Get properties for categories in neighborhood
property_query = text("""
    SELECT DISTINCT p.entity_key, p.label, c.entity_key as category_key
    FROM properties p
    JOIN category_property cp ON cp.property_id = p.id
    JOIN categories c ON c.id = cp.category_id
    WHERE c.entity_key = ANY(:entity_keys)
""")
```
  </action>
  <verify>
Run backend tests: `cd /home/daharoni/dev/ontology-hub/backend && python -m pytest tests/ -v -k graph`
Manual check: Start backend, call GET /api/v2/graph/neighborhood/Person?depth=2 and verify response contains nodes with entity_type="property" and edges with edge_type="property"
  </verify>
  <done>
Graph API returns property nodes alongside category nodes, with edges connecting categories to their properties.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add subobject nodes and edges to graph response</name>
  <files>
    backend/app/services/graph_query.py
  </files>
  <action>
Extend `get_neighborhood_graph` to include subobject nodes:

1. Categories reference subobjects via their `canonical_json` field. The structure is typically:
   - `canonical_json.subobjects` - list of subobject entity_keys
   - OR subobject references might be in properties

2. Query approach:
   - For each category in the neighborhood, extract subobject references from canonical_json
   - Query the `subobjects` table to get subobject details
   - Create GraphNode with entity_type="subobject"
   - Apply draft overlay for change_status

3. Create GraphEdge entries with edge_type="subobject" for each category->subobject relationship.

4. Also update `get_module_graph` to include subobjects.

Query pattern:
```python
# Get subobject entity_keys from category canonical_json
for category in neighborhood_categories:
    subobj_keys = category.canonical_json.get("subobjects", [])
    # Query subobjects table for these keys
```

If canonical_json doesn't have subobjects array, check if there's a relationship table. If neither exists, subobjects might not be linked to categories in the current schema - document this finding.
  </action>
  <verify>
Run backend tests: `cd /home/daharoni/dev/ontology-hub/backend && python -m pytest tests/ -v -k graph`
Manual check: Call GET /api/v2/graph/neighborhood/Person?depth=2 and verify response contains subobject nodes if the category uses subobjects.
  </verify>
  <done>
Graph API returns subobject nodes with edges connecting categories to their subobjects.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add template nodes and edges to graph response</name>
  <files>
    backend/app/services/graph_query.py
  </files>
  <action>
Extend `get_neighborhood_graph` to include template nodes:

1. Templates are stored in the `templates` table. Check how they relate to categories:
   - Template might reference a category via canonical_json
   - Or there might be a relationship table
   - Or templates are standalone (no direct category link)

2. If templates link to categories:
   - Query templates for any that reference categories in the neighborhood
   - Create GraphNode with entity_type="template"
   - Create GraphEdge with edge_type="template"

3. If templates don't directly link to categories:
   - Include templates that belong to the same module as neighborhood categories
   - Edge type could be "module_sibling" or omit edges entirely

4. Apply draft overlay for change_status on template nodes.

5. Also update `get_module_graph` to include templates belonging to the module.

Note: If templates have no direct relationship to categories, document this and include them only in module graphs (where module membership provides the relationship).
  </action>
  <verify>
Run backend tests: `cd /home/daharoni/dev/ontology-hub/backend && python -m pytest tests/ -v -k graph`
Manual check: Call GET /api/v2/graph/neighborhood/Person?depth=2 and verify template nodes appear if applicable.
  </verify>
  <done>
Graph API returns template nodes. Templates are included based on their relationship to categories or module membership.
  </done>
</task>

</tasks>

<verification>
1. Backend tests pass: `cd backend && python -m pytest tests/ -v`
2. API returns mixed entity types: GET /api/v2/graph/neighborhood/{category}?depth=2 includes property, subobject, template nodes
3. Edge types are correct: edges have edge_type="property", "subobject", "template" as appropriate
4. Module membership still works: nodes include modules array for hull rendering
5. Draft overlay applied: change_status appears for all node types when in draft context
</verification>

<success_criteria>
1. Graph API returns nodes with entity_type in ["category", "property", "subobject", "template"]
2. Edges correctly represent relationships: parent (category->category), property (category->property), subobject (category->subobject), template (category->template or module->template)
3. All existing graph functionality preserved (cycle detection, module membership, draft overlay)
4. Backend tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-graph-view-fixes/17-01-SUMMARY.md`
</output>
