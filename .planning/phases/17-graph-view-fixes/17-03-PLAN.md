---
phase: 17-graph-view-fixes
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - frontend/src/components/graph/ModuleHull.tsx
  - frontend/src/components/graph/HullLayer.tsx
autonomous: true

must_haves:
  truths:
    - "User sees module hull boundaries as smooth curves, not jagged polygons"
    - "User sees module name label displayed on the hull"
    - "Modules with 1-2 nodes still render a visible boundary (circle/ellipse fallback)"
  artifacts:
    - path: "frontend/src/components/graph/ModuleHull.tsx"
      provides: "Smooth hull rendering with Catmull-Rom curves"
      contains: "curveCatmullRomClosed|d3-shape"
    - path: "frontend/src/components/graph/HullLayer.tsx"
      provides: "Module label positioning on hull"
      contains: "label|text"
  key_links:
    - from: "frontend/src/components/graph/ModuleHull.tsx"
      to: "d3-shape"
      via: "curve interpolation"
      pattern: "curveCatmullRomClosed|line"
---

<objective>
Update module hull rendering to use smooth Catmull-Rom curves instead of straight-line polygons, add module name labels on hulls, and handle edge cases where modules have fewer than 3 nodes.

Purpose: Fulfill requirement GRAPH-04 (smooth module hull boundaries) and improve module visual identity with labels.

Output: ModuleHull renders with smooth curves; module names visible on hulls; 1-2 node modules show circular boundaries.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-graph-view-fixes/17-CONTEXT.md
@.planning/phases/17-graph-view-fixes/17-RESEARCH.md

# Key source files
@frontend/src/components/graph/ModuleHull.tsx
@frontend/src/components/graph/HullLayer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ModuleHull to use Catmull-Rom curves</name>
  <files>
    frontend/src/components/graph/ModuleHull.tsx
  </files>
  <action>
Replace the straight-line polygon path generation with d3-shape Catmull-Rom curve interpolation.

**Current implementation uses:**
```typescript
const pathData = `M${hull.map((p) => p.join(',')).join('L')}Z`
```

**New implementation from RESEARCH.md:**
```typescript
import { line, curveCatmullRomClosed } from 'd3-shape'
import { polygonHull } from 'd3-polygon'

function getSmoothHullPath(points: [number, number][], padding: number): string | null {
  if (points.length < 3) return null

  // 1. Compute convex hull
  const hull = polygonHull(points)
  if (!hull || hull.length < 3) return null

  // 2. Calculate centroid for expansion
  const centroid: [number, number] = [
    hull.reduce((sum, p) => sum + p[0], 0) / hull.length,
    hull.reduce((sum, p) => sum + p[1], 0) / hull.length,
  ]

  // 3. Expand hull points outward from centroid by padding
  const expandedPoints: [number, number][] = hull.map((p) => {
    const dx = p[0] - centroid[0]
    const dy = p[1] - centroid[1]
    const distance = Math.sqrt(dx * dx + dy * dy)
    if (distance === 0) return p
    const factor = (distance + padding) / distance
    return [centroid[0] + dx * factor, centroid[1] + dy * factor]
  })

  // 4. Create smooth curve with Catmull-Rom interpolation
  const lineGenerator = line<[number, number]>()
    .x(d => d[0])
    .y(d => d[1])
    .curve(curveCatmullRomClosed.alpha(0.5))

  return lineGenerator(expandedPoints)
}
```

**Changes to ModuleHull component:**
1. Import line and curveCatmullRomClosed from 'd3-shape'
2. Replace the path calculation in useMemo with getSmoothHullPath function
3. Increase default padding from 40 to 50 for better spacing around nodes
4. Return the path from getSmoothHullPath (already in SVG path format from d3.line)

The fill and stroke styling remains the same.
  </action>
  <verify>
Run: `cd /home/daharoni/dev/ontology-hub/frontend && npm run build`
Visual check: Start frontend, view graph with multiple modules, confirm hull boundaries are smooth curves not jagged.
  </verify>
  <done>
Module hull boundaries render as smooth Catmull-Rom curves.
  </done>
</task>

<task type="auto">
  <name>Task 2: Handle 1-2 node modules with ellipse fallback</name>
  <files>
    frontend/src/components/graph/ModuleHull.tsx
  </files>
  <action>
Add fallback rendering for modules with fewer than 3 nodes (convex hull requires 3+ points).

**For 1 node:**
- Render a circle centered on the node position
- Radius = padding value (e.g., 50px)

**For 2 nodes:**
- Render an ellipse that encompasses both nodes
- Calculate bounding box, add padding
- Center the ellipse between the two nodes

**Implementation:**
```typescript
const hullPath = useMemo(() => {
  const moduleNodes = nodes.filter(
    (n) => n.data.modules && Array.isArray(n.data.modules) && n.data.modules.includes(moduleId)
  )

  if (moduleNodes.length === 0) return null

  const points: [number, number][] = moduleNodes.map((n) => [n.position.x, n.position.y])

  // Single node: circle
  if (moduleNodes.length === 1) {
    const [x, y] = points[0]
    return {
      type: 'circle' as const,
      cx: x,
      cy: y,
      r: padding,
    }
  }

  // Two nodes: ellipse
  if (moduleNodes.length === 2) {
    const [x1, y1] = points[0]
    const [x2, y2] = points[1]
    const cx = (x1 + x2) / 2
    const cy = (y1 + y2) / 2
    const dx = Math.abs(x2 - x1)
    const dy = Math.abs(y2 - y1)
    return {
      type: 'ellipse' as const,
      cx,
      cy,
      rx: dx / 2 + padding,
      ry: Math.max(dy / 2 + padding, padding),  // Ensure minimum height
    }
  }

  // 3+ nodes: smooth hull path
  const path = getSmoothHullPath(points, padding)
  if (!path) return null
  return { type: 'path' as const, d: path }
}, [moduleId, nodes, padding])

// In render:
if (!hullPath) return null

if (hullPath.type === 'circle') {
  return (
    <circle
      cx={hullPath.cx}
      cy={hullPath.cy}
      r={hullPath.r}
      fill={color}
      fillOpacity={0.15}
      stroke={color}
      strokeWidth={2}
      strokeOpacity={0.4}
      pointerEvents="none"
    />
  )
}

if (hullPath.type === 'ellipse') {
  return (
    <ellipse
      cx={hullPath.cx}
      cy={hullPath.cy}
      rx={hullPath.rx}
      ry={hullPath.ry}
      fill={color}
      fillOpacity={0.15}
      stroke={color}
      strokeWidth={2}
      strokeOpacity={0.4}
      pointerEvents="none"
    />
  )
}

// path type
return (
  <path
    d={hullPath.d}
    fill={color}
    fillOpacity={0.15}
    stroke={color}
    strokeWidth={2}
    strokeOpacity={0.4}
    pointerEvents="none"
  />
)
```
  </action>
  <verify>
Run: `cd /home/daharoni/dev/ontology-hub/frontend && npm run build`
Visual check: If any module has only 1-2 categories visible, confirm a circular/elliptical boundary appears instead of nothing.
  </verify>
  <done>
Modules with 1-2 nodes show circular or elliptical boundaries instead of disappearing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add module name label on hull</name>
  <files>
    frontend/src/components/graph/ModuleHull.tsx
    frontend/src/components/graph/HullLayer.tsx
  </files>
  <action>
Add module name label displayed on the hull boundary.

**Approach per CONTEXT.md decision "Module name/label displays on the hull":**

1. Calculate label position based on hull centroid (top of hull is good placement)

2. **In ModuleHull.tsx**, compute centroid and return it alongside the path:
```typescript
// Compute centroid for label positioning
const centroid: [number, number] = [
  points.reduce((sum, p) => sum + p[0], 0) / points.length,
  points.reduce((sum, p) => sum + p[1], 0) / points.length,
]

// Find topmost point of hull for label placement (or use centroid - offset)
const topY = Math.min(...points.map(p => p[1])) - padding - 10  // Above the hull
```

3. Return both path and label position from ModuleHull, or render the label directly in ModuleHull.

4. **Label styling:**
   - Same color as hull (or darker shade for readability)
   - Small font size (10-12px)
   - Semi-transparent background for readability over graph content
   - Position above the hull

**Implementation in ModuleHull:**
```typescript
// After computing hullPath, also compute label position
const labelPosition = useMemo(() => {
  const moduleNodes = nodes.filter(...)
  if (moduleNodes.length === 0) return null

  const points = moduleNodes.map(n => [n.position.x, n.position.y] as [number, number])
  const cx = points.reduce((sum, p) => sum + p[0], 0) / points.length
  const minY = Math.min(...points.map(p => p[1]))

  return { x: cx, y: minY - padding - 15 }  // Above hull
}, [moduleId, nodes, padding])

// In render, add text element:
<>
  {/* Hull shape (circle/ellipse/path) */}
  {hullShape}

  {/* Module label */}
  {labelPosition && (
    <text
      x={labelPosition.x}
      y={labelPosition.y}
      textAnchor="middle"
      fill={color}
      fontSize={11}
      fontWeight={500}
      opacity={0.8}
      pointerEvents="none"
    >
      {moduleId}
    </text>
  )}
</>
```

Note: moduleId is the entity_key like "core" or "extensions". If you need a display label, it would require passing module label from HullLayer (which doesn't currently have it). For now, use moduleId as the label.
  </action>
  <verify>
Run: `cd /home/daharoni/dev/ontology-hub/frontend && npm run build`
Visual check: Start frontend, view graph with module hulls visible, confirm module names appear above hull boundaries.
  </verify>
  <done>
Module name labels display on hull boundaries. Labels positioned above the hull, styled with module color.
  </done>
</task>

</tasks>

<verification>
1. Frontend builds: `cd frontend && npm run build`
2. Hull boundaries are smooth curves (no jagged polygon edges)
3. Single-node modules show circular boundary
4. Two-node modules show elliptical boundary
5. Module names visible above hull boundaries
6. Semi-transparent fill still shows overlapping hulls correctly
7. Zoom/pan still works correctly with hull overlays
</verification>

<success_criteria>
1. Module hull boundaries render as smooth Catmull-Rom curves (GRAPH-04)
2. Modules with 1-2 nodes have visible boundaries (circle/ellipse)
3. Module names appear as labels on hull boundaries
4. Frontend builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-graph-view-fixes/17-03-SUMMARY.md`
</output>
