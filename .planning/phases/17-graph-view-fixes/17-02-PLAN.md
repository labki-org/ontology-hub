---
phase: 17-graph-view-fixes
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - frontend/package.json
  - frontend/src/components/graph/GraphNode.tsx
  - frontend/src/components/graph/useForceLayout.ts
  - frontend/src/stores/graphStore.ts
  - frontend/src/components/graph/GraphCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "User sees categories as rounded rectangles (slate color, largest)"
    - "User sees properties as diamonds (green color)"
    - "User sees subobjects as hexagons (violet color)"
    - "User sees templates as circles (amber color)"
    - "Hovering a node dims unrelated nodes and highlights connected ones"
  artifacts:
    - path: "frontend/src/components/graph/GraphNode.tsx"
      provides: "SVG shape rendering based on entity_type"
      contains: "getNodeShape|getNodeColor|hexagonPath|diamondPath"
    - path: "frontend/src/stores/graphStore.ts"
      provides: "Hover state management"
      contains: "hoveredNodeId|setHoveredNodeId"
  key_links:
    - from: "frontend/src/components/graph/GraphNode.tsx"
      to: "data.entity_type"
      via: "switch statement for shape selection"
      pattern: "entity_type.*category|property|subobject|template"
    - from: "frontend/src/components/graph/GraphCanvas.tsx"
      to: "graphStore.hoveredNodeId"
      via: "onNodeMouseEnter/Leave handlers"
      pattern: "onNodeMouseEnter|onNodeMouseLeave"
---

<objective>
Update the graph visualization to render distinct shapes and colors for each entity type (category, property, subobject, template), and add hover interaction that highlights connected nodes.

Purpose: Enable visual differentiation of entity types in the graph view, fulfilling requirements GRAPH-01, GRAPH-02, GRAPH-03, plus hover highlighting from CONTEXT.md decisions.

Output: GraphNode component renders SVG shapes per entity type; hover state dims unrelated nodes.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-graph-view-fixes/17-CONTEXT.md
@.planning/phases/17-graph-view-fixes/17-RESEARCH.md

# Key source files
@frontend/src/components/graph/GraphNode.tsx
@frontend/src/components/graph/GraphCanvas.tsx
@frontend/src/components/graph/useForceLayout.ts
@frontend/src/stores/graphStore.ts
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install d3-shape and update GraphNode with SVG shapes</name>
  <files>
    frontend/package.json
    frontend/src/components/graph/GraphNode.tsx
  </files>
  <action>
1. Install d3-shape (needed for smooth hulls in Plan 03, but install now):
   ```bash
   cd /home/daharoni/dev/ontology-hub/frontend && npm install d3-shape @types/d3-shape
   ```

2. Rewrite GraphNode.tsx to render SVG shapes based on entity_type:

**Shape assignments (per CONTEXT.md):**
- category: Rounded rectangle (80x80px) - slate-400 fill (#94a3b8), slate-500 border (#64748b)
- property: Diamond (50x50px) - green-300 fill (#86efac), green-500 border (#22c55e)
- subobject: Hexagon (60x60px) - violet-300 fill (#c4b5fd), violet-500 border (#8b5cf6)
- template: Circle (50x50px) - amber-300 fill (#fcd34d), amber-500 border (#f59e0b)

**Implementation pattern from RESEARCH.md:**
```typescript
// Constants outside component
const NODE_SIZES: Record<string, number> = {
  category: 80,
  subobject: 60,
  property: 50,
  template: 50,
}

const ENTITY_COLORS: Record<string, string> = {
  category: '#94a3b8',
  property: '#86efac',
  subobject: '#c4b5fd',
  template: '#fcd34d',
}

const ENTITY_BORDER_COLORS: Record<string, string> = {
  category: '#64748b',
  property: '#22c55e',
  subobject: '#8b5cf6',
  template: '#f59e0b',
}

// SVG path generators
function getNodeShape(entityType: string, size: number): string {
  const half = size / 2
  switch (entityType) {
    case 'category':
      // Rounded rectangle - use rx,ry for rounded corners
      return roundedRectPath(size, 8)
    case 'property':
      return diamondPath(size)
    case 'subobject':
      return hexagonPath(size)
    case 'template':
      return circlePath(size)
    default:
      return rectPath(size)
  }
}
```

3. Keep existing change_status styling (border glow for added/modified/deleted).

4. Keep existing click handler for setSelectedEntity.

5. Ensure React Flow Handle components are positioned at top/bottom of the node container.

6. Add node label inside the shape, truncated with ellipsis if too long.
  </action>
  <verify>
Run: `cd /home/daharoni/dev/ontology-hub/frontend && npm run build`
Visual check: Start frontend, view graph, confirm nodes render as shapes (may only see category shapes until backend returns other types).
  </verify>
  <done>
GraphNode renders distinct SVG shapes per entity_type. d3-shape installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update useForceLayout collision radius for different node sizes</name>
  <files>
    frontend/src/components/graph/useForceLayout.ts
  </files>
  <action>
Update useForceLayout to use larger collision radius based on the largest node size:

1. Current code uses fixed collisionRadius = 50 in options.

2. Change to account for category nodes (80px) being larger:
   - Default collisionRadius should be 50 (half of largest node + padding)
   - Or accept nodeSize from caller

3. Recommended change:
```typescript
const {
  chargeStrength = -400,
  linkDistance = 100,  // Increased from 80 for spacious layout
  collisionRadius = 55, // Increased from 50 to account for 80px category nodes
} = options ?? {}
```

4. Also increase chargeStrength slightly to spread nodes more (spacious layout per CONTEXT.md):
   - Try -500 instead of -400

5. The force layout runs synchronously to completion, so these changes affect initial positioning.
  </action>
  <verify>
Run: `cd /home/daharoni/dev/ontology-hub/frontend && npm run build`
Visual check: Start frontend, view graph, confirm nodes don't overlap excessively.
  </verify>
  <done>
Force layout uses appropriate collision radius for larger category nodes. Spacious layout achieved.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add hover highlighting with connected node tracking</name>
  <files>
    frontend/src/stores/graphStore.ts
    frontend/src/components/graph/GraphCanvas.tsx
    frontend/src/components/graph/GraphNode.tsx
  </files>
  <action>
1. **graphStore.ts** - Add hover state:
```typescript
interface GraphState {
  // ... existing fields
  hoveredNodeId: string | null

  // ... existing actions
  setHoveredNodeId: (id: string | null) => void
}

const initialState = {
  // ... existing
  hoveredNodeId: null,
}

// In the store:
setHoveredNodeId: (id) => {
  set((state) => {
    state.hoveredNodeId = id
  })
},
```

2. **GraphCanvas.tsx** - Add mouse handlers:
```typescript
// Import from @xyflow/react
import { getIncomers, getOutgoers } from '@xyflow/react'

// In component:
const setHoveredNodeId = useGraphStore((s) => s.setHoveredNodeId)
const hoveredNodeId = useGraphStore((s) => s.hoveredNodeId)

const onNodeMouseEnter = useCallback((_event: React.MouseEvent, node: Node) => {
  setHoveredNodeId(node.id)
}, [setHoveredNodeId])

const onNodeMouseLeave = useCallback(() => {
  setHoveredNodeId(null)
}, [setHoveredNodeId])

// Pass to ReactFlow:
<ReactFlow
  ...
  onNodeMouseEnter={onNodeMouseEnter}
  onNodeMouseLeave={onNodeMouseLeave}
>
```

3. **GraphNode.tsx** - Apply dimming based on hover state:
```typescript
// In component:
const hoveredNodeId = useGraphStore((s) => s.hoveredNodeId)

// Compute highlight state
const getHighlightState = (): 'highlighted' | 'dimmed' | 'normal' => {
  if (!hoveredNodeId) return 'normal'
  if (data.entity_key === hoveredNodeId) return 'highlighted'
  // For connected check, we'd need edges - simplify to just dim non-hovered
  return 'dimmed'
}

// Note: Full connected node tracking requires access to edges in the node component.
// Simpler approach: Just dim all non-hovered nodes when any node is hovered.
// For full connected highlighting, would need to pass connectedIds via React context.

// Apply opacity based on state
const highlightState = getHighlightState()
const opacity = highlightState === 'dimmed' ? 0.3 : 1
```

4. For full "highlight connected nodes" behavior, the GraphCanvas needs to compute connectedIds and pass them down. Since nodes render via nodeTypes which can't easily receive props, use a Zustand computed value or React context.

Simpler approach for this plan: Just dim non-hovered nodes. Full connected highlighting can be a future enhancement.
  </action>
  <verify>
Run: `cd /home/daharoni/dev/ontology-hub/frontend && npm run build`
Visual check: Start frontend, hover over a node, confirm other nodes dim (opacity reduces).
  </verify>
  <done>
Hovering a node dims unrelated nodes. Hover state managed in graphStore.
  </done>
</task>

</tasks>

<verification>
1. Frontend builds: `cd frontend && npm run build`
2. Node shapes render correctly for each entity_type
3. Colors match the specified palette (muted/pastel)
4. Labels visible inside shapes
5. Nodes don't overlap excessively (spacious layout)
6. Hover dims non-hovered nodes
7. Existing functionality preserved (click selection, change_status badges)
</verification>

<success_criteria>
1. Categories render as rounded rectangles (slate color)
2. Properties render as diamonds (green color)
3. Subobjects render as hexagons (violet color)
4. Templates render as circles (amber color)
5. Hovering any node dims other nodes
6. Frontend builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-graph-view-fixes/17-02-SUMMARY.md`
</output>
