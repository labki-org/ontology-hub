---
phase: 10-query-layer
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - backend/app/routers/entities_v2.py
  - backend/app/main.py
autonomous: true

# QRY-01 Note: Requirement "Entity queries accept ontology_version_id for canonical reads"
# is satisfied BY DESIGN. Per Phase 8 decision: "Latest-only versioning - Ontology Hub
# retains only current version; labki-schemas repo is the version archive."
# There is only one version, so all queries implicitly return current canonical data.

must_haves:
  truths:
    - "Category detail returns parents, direct properties, and inherited properties with provenance"
    - "Property where-used endpoint returns categories using the property"
    - "Module detail returns direct entities and computed closure"
    - "Bundle detail returns modules and computed closure"
    - "All entity queries accept optional draft_id and return effective view with change_status"
  artifacts:
    - path: "backend/app/routers/entities_v2.py"
      provides: "v2 entity endpoints"
      exports: ["router"]
    - path: "backend/app/main.py"
      provides: "Router registration"
      contains: "entities_v2"
  key_links:
    - from: "backend/app/routers/entities_v2.py"
      to: "app.services.draft_overlay.DraftContextDep"
      via: "FastAPI dependency"
      pattern: "DraftContextDep"
    - from: "backend/app/routers/entities_v2.py"
      to: "category_property_effective"
      via: "SQLAlchemy text query"
      pattern: "category_property_effective"
---

<objective>
Implement v2.0 entity query endpoints with draft overlay support

Purpose: Provide read endpoints for all entity types that return canonical data with optional draft overlay, supporting QRY-01 through QRY-07 requirements including category detail with inheritance provenance, property where-used, and module/bundle closure computation.

Note: QRY-01 (ontology_version_id for canonical reads) is satisfied by design - Phase 8 established latest-only versioning where only current version is retained. All queries implicitly return current canonical data.

Output: FastAPI router with entity endpoints that integrate DraftOverlayService for effective view computation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-query-layer/10-CONTEXT.md
@.planning/phases/10-query-layer/10-RESEARCH.md
@.planning/phases/10-query-layer/10-01-SUMMARY.md

# v2.0 models
@backend/app/models/v2/__init__.py
@backend/app/models/v2/relationships.py
@backend/app/models/v2/category_property_effective.py

# v1.0 patterns to follow
@backend/app/routers/entities.py

# Dependencies from 10-01
@backend/app/services/draft_overlay.py
@backend/app/schemas/entity_v2.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create v2 entity router with category and property endpoints</name>
  <files>backend/app/routers/entities_v2.py</files>
  <action>
Create entities_v2.py router with /api/v2 prefix.

**Endpoints to implement:**

1. **GET /categories** - List categories with pagination and draft overlay
   - Query params: cursor (optional str), limit (int, default 20), draft_id (optional UUID)
   - Query Category table ordered by entity_key
   - Apply draft overlay to each category
   - Include draft-created categories (from DraftOverlayService.get_draft_creates)
   - Re-sort merged results by entity_key
   - Return EntityListResponse with change_status on each item

2. **GET /categories/{entity_key}** - Category detail with parents and properties
   - Query params: draft_id (optional UUID)
   - Get canonical category by entity_key
   - Apply draft overlay
   - Query CategoryParent to get parent category keys
   - Query category_property_effective materialized view joined with properties table:
     - Select property entity_key, label, depth, is_required, source category entity_key
     - Order by depth (direct first), then label
     - Build property list with is_direct (depth=0), is_inherited (depth>0), source_category, inheritance_depth
   - Return CategoryDetailResponse

3. **GET /properties** - List properties with pagination and draft overlay
   - Same pattern as categories list

4. **GET /properties/{entity_key}** - Property detail
   - Query params: draft_id (optional UUID)
   - Get canonical property, apply overlay
   - Return PropertyDetailResponse

5. **GET /properties/{entity_key}/used-by** - Where-used (QRY-05)
   - Query params: draft_id (optional UUID)
   - Query CategoryProperty joined with Category where property matches
   - Get list of category entity_keys using this property
   - Apply draft overlay to each category
   - Return list of category objects with change_status

**Implementation notes:**
- Use DraftContextDep dependency for all endpoints
- Use raw SQL (sqlalchemy text()) for category_property_effective queries since it's a view
- Follow v1.0 cursor pagination pattern (limit+1 to detect has_next)
- Handle 404 for missing entities
- Include rate limiting decorators like v1.0 (optional but follow pattern)
  </action>
  <verify>python -c "from app.routers.entities_v2 import router; print(f'Routes: {len(router.routes)}')" from backend dir</verify>
  <done>Category and property endpoints implemented with draft overlay support and category detail includes inherited properties with provenance</done>
</task>

<task type="auto">
  <name>Task 2: Add module/bundle endpoints with closure computation and register router</name>
  <files>backend/app/routers/entities_v2.py, backend/app/main.py</files>
  <action>
Add module and bundle endpoints to entities_v2.py.

**Endpoints to implement:**

1. **GET /modules/{entity_key}** - Module detail with closure (QRY-06)
   - Query params: draft_id (optional UUID)
   - Get canonical module, apply overlay
   - Query ModuleEntity to get direct entity membership (grouped by entity_type)
   - Compute closure using helper function (see below)
   - Return ModuleDetailResponse with entities and closure

2. **GET /bundles/{entity_key}** - Bundle detail with closure (QRY-07)
   - Query params: draft_id (optional UUID)
   - Get canonical bundle, apply overlay
   - Query BundleModule to get direct module membership
   - Compute closure using helper function (see below)
   - Return BundleDetailResponse with modules and closure

3. **GET /subobjects** and **GET /templates** - List endpoints (basic pagination, draft overlay)
   - Follow same pattern as categories/properties list

**Closure computation - add as helper functions in entities_v2.py:**

```python
async def compute_module_closure(
    session: AsyncSession,
    module_key: str,
    direct_category_keys: list[str],
) -> list[str]:
    """Compute transitive category dependencies for a module.

    For each category in module, find categories it depends on (inherits from).
    Closure = direct categories + all ancestor categories.
    Uses recursive CTE on category_parent table.
    """
    if not direct_category_keys:
        return []

    # Recursive CTE to find all ancestor categories
    query = text("""
        WITH RECURSIVE ancestors AS (
            -- Base: direct module categories
            SELECT cp.parent_id as category_id
            FROM category_parent cp
            JOIN categories c ON c.id = cp.category_id
            WHERE c.entity_key = ANY(:category_keys)

            UNION

            -- Recursive: parents of parents
            SELECT cp.parent_id
            FROM category_parent cp
            JOIN ancestors a ON a.category_id = cp.category_id
        )
        SELECT DISTINCT c.entity_key
        FROM ancestors a
        JOIN categories c ON c.id = a.category_id
        WHERE c.entity_key != ALL(:category_keys)
    """)
    result = await session.execute(query, {"category_keys": direct_category_keys})
    return [row[0] for row in result.fetchall()]


async def compute_bundle_closure(
    session: AsyncSession,
    bundle_key: str,
    direct_module_keys: list[str],
) -> list[str]:
    """Compute transitive module dependencies for a bundle.

    Module A depends on Module B if A has category that inherits from B's category.
    Uses category_parent and module_entity tables.
    """
    if not direct_module_keys:
        return []

    # Find modules containing ancestor categories of direct modules' categories
    query = text("""
        WITH RECURSIVE category_ancestors AS (
            -- Base: categories in direct modules
            SELECT me.category_id, me.module_id as source_module_id
            FROM module_entity me
            JOIN modules m ON m.id = me.module_id
            WHERE m.entity_key = ANY(:module_keys)
              AND me.entity_type = 'category'

            UNION

            -- Recursive: parent categories
            SELECT cp.parent_id, ca.source_module_id
            FROM category_parent cp
            JOIN category_ancestors ca ON ca.category_id = cp.category_id
        )
        SELECT DISTINCT m.entity_key
        FROM category_ancestors ca
        JOIN module_entity me ON me.category_id = ca.category_id
        JOIN modules m ON m.id = me.module_id
        WHERE m.entity_key != ALL(:module_keys)
    """)
    result = await session.execute(query, {"module_keys": direct_module_keys})
    return [row[0] for row in result.fetchall()]
```

**Register router in main.py:**
- Import router from app.routers.entities_v2
- Add: `app.include_router(entities_v2.router, prefix="/api/v2")`
  </action>
  <verify>python -c "from app.routers.entities_v2 import router; from app.main import app; routes = [r.path for r in app.routes if hasattr(r, 'path')]; assert any('/api/v2' in str(r) or 'entities_v2' in str(r) for r in routes) or 'entities_v2' in str(app.routes), 'Router not registered'; print('OK')" from backend dir</verify>
  <done>Module and bundle endpoints with closure computation implemented; router registered at /api/v2</done>
</task>

</tasks>

<verification>
- [ ] GET /api/v2/categories returns paginated list with change_status
- [ ] GET /api/v2/categories/{key} returns detail with parents and properties
- [ ] GET /api/v2/properties returns paginated list
- [ ] GET /api/v2/properties/{key}/used-by returns categories using property
- [ ] GET /api/v2/modules/{key} returns module with entities and closure
- [ ] GET /api/v2/bundles/{key} returns bundle with modules and closure
- [ ] All endpoints accept draft_id query parameter
- [ ] Router registered in main.py at /api/v2 prefix
- [ ] Closure computation uses recursive CTEs in helper functions
</verification>

<success_criteria>
All v2.0 entity query endpoints operational with draft context support; category detail includes inheritance provenance from materialized view; module/bundle detail includes computed closure via helper functions with recursive CTEs.
</success_criteria>

<output>
After completion, create `.planning/phases/10-query-layer/10-02-SUMMARY.md`
</output>
