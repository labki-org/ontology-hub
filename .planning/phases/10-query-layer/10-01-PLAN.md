---
phase: 10-query-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/schemas/entity_v2.py
  - backend/app/schemas/graph.py
  - backend/app/services/draft_overlay.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "Response models support change_status metadata for draft context"
    - "DraftOverlayService loads draft changes and applies JSON Patch to canonical data"
    - "jsonpatch library installed for RFC 6902 compliance"
  artifacts:
    - path: "backend/app/schemas/entity_v2.py"
      provides: "v2 entity response models with change_status"
      exports: ["CategoryDetailResponse", "PropertyDetailResponse", "ModuleDetailResponse", "BundleDetailResponse", "EntityListResponse"]
    - path: "backend/app/schemas/graph.py"
      provides: "Graph response models for visualization"
      exports: ["GraphNode", "GraphEdge", "GraphResponse"]
    - path: "backend/app/services/draft_overlay.py"
      provides: "Draft overlay computation service"
      exports: ["DraftOverlayService", "get_draft_context", "DraftContextDep"]
  key_links:
    - from: "backend/app/services/draft_overlay.py"
      to: "app.models.v2.DraftChange"
      via: "SQLModel query"
      pattern: "select.*DraftChange"
    - from: "backend/app/services/draft_overlay.py"
      to: "jsonpatch"
      via: "library import"
      pattern: "import jsonpatch"
---

<objective>
Create v2.0 response schemas and draft overlay service infrastructure

Purpose: Enable entity and graph endpoints to return responses with draft change status metadata and compute effective views by merging canonical data with draft JSON Patch changes.

Output: Response schemas with change_status fields, graph models for visualization, and DraftOverlayService for server-side draft overlay computation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-query-layer/10-CONTEXT.md
@.planning/phases/10-query-layer/10-RESEARCH.md

# v2.0 models
@backend/app/models/v2/__init__.py
@backend/app/models/v2/draft.py
@backend/app/models/v2/category.py

# Existing patterns
@backend/app/database.py
@backend/app/schemas/entity.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create v2 response schemas with change_status metadata</name>
  <files>backend/app/schemas/entity_v2.py, backend/app/schemas/graph.py</files>
  <action>
Create response schemas for v2.0 entity and graph endpoints.

**entity_v2.py:**
- `ChangeStatus` literal type: "added" | "modified" | "deleted" | "unchanged"
- `CategoryDetailResponse`: entity_key, label, description, parents (list[str]), properties with provenance (list of dicts with entity_key, label, is_direct, is_inherited, is_required, source_category, inheritance_depth), change_status, deleted flag
- `PropertyDetailResponse`: entity_key, label, description, datatype, cardinality, change_status, deleted flag
- `ModuleDetailResponse`: entity_key, label, version, entities (list by type), closure (computed dependencies), change_status, deleted flag
- `BundleDetailResponse`: entity_key, label, version, modules (list), closure (computed modules), change_status, deleted flag
- `EntityListResponse`: Generic paginated list with items, next_cursor, has_next (similar to v1 but items include change_status)
- `EntityWithStatus`: Base model with change_status and deleted fields for list items

**graph.py:**
- `GraphNode`: id (entity_key), label, entity_type, depth (optional), modules (list for hull rendering), change_status (optional for draft context)
- `GraphEdge`: source, target, edge_type (default "parent")
- `GraphResponse`: nodes, edges, has_cycles flag

Use Pydantic BaseModel with Field aliases for underscore-prefixed internal fields (e.g., `_change_status` -> `change_status`).
  </action>
  <verify>python -c "from app.schemas.entity_v2 import CategoryDetailResponse, EntityListResponse; from app.schemas.graph import GraphNode, GraphResponse; print('OK')" from backend dir</verify>
  <done>v2 response schemas importable with change_status support and graph models defined</done>
</task>

<task type="auto">
  <name>Task 2: Create DraftOverlayService and add jsonpatch dependency</name>
  <files>backend/app/services/draft_overlay.py, backend/requirements.txt</files>
  <action>
Add jsonpatch to requirements.txt (version ^1.33).

Create DraftOverlayService class in draft_overlay.py:

**Class structure:**
```python
class DraftOverlayService:
    def __init__(self, session: AsyncSession, draft_id: Optional[UUID] = None):
        self.session = session
        self.draft_id = draft_id
        self._draft_changes: dict[str, DraftChange] | None = None

    async def _load_draft_changes(self) -> dict[str, DraftChange]:
        """Load all changes for this draft, keyed by '{entity_type}:{entity_key}'."""
        # If no draft_id, return empty dict
        # Query DraftChange where draft_id matches
        # Return dict keyed by f"{change.entity_type}:{change.entity_key}"

    async def apply_overlay(
        self,
        canonical: SQLModel | None,
        entity_type: str,
        entity_key: str,
    ) -> dict | None:
        """Apply draft changes to canonical entity, return effective JSON with change_status.

        Returns:
        - None if entity deleted in draft (but include deleted marker per CONTEXT.md)
        - Modified dict if updated in draft (apply JSON Patch)
        - New entity dict if created in draft
        - Canonical JSON with change_status="unchanged" if no draft changes
        """
        # Load draft changes if not cached
        # Look up change by entity_type:entity_key
        # Handle each ChangeType:
        #   CREATE: return replacement_json with _change_status="added"
        #   DELETE: return canonical with _change_status="deleted", _deleted=True
        #   UPDATE: deepcopy canonical, apply jsonpatch, return with _change_status="modified"
        #   None: return canonical with _change_status="unchanged"
        # IMPORTANT: Always deepcopy before applying patch to avoid mutating cached data

    async def get_draft_creates(self, entity_type: str) -> list[dict]:
        """Get all CREATE changes for an entity type (for list queries)."""
        # Query DraftChange where change_type=CREATE and entity_type matches
        # Return list of replacement_json with _change_status="added"
```

**FastAPI dependency:**
```python
async def get_draft_context(
    session: SessionDep,
    draft_id: Optional[UUID] = Query(None, description="Draft UUID for effective view"),
) -> DraftOverlayService:
    return DraftOverlayService(session=session, draft_id=draft_id)

DraftContextDep = Annotated[DraftOverlayService, Depends(get_draft_context)]
```

Use `from copy import deepcopy` for safe patch application.
Use `jsonpatch.JsonPatch(patch_ops).apply(doc)` for RFC 6902 compliance.
Handle JsonPatchException by returning canonical with _patch_error field.
  </action>
  <verify>pip install -r requirements.txt && python -c "from app.services.draft_overlay import DraftOverlayService, DraftContextDep; print('OK')" from backend dir</verify>
  <done>DraftOverlayService loads draft changes and applies JSON Patch overlays; jsonpatch library installed</done>
</task>

</tasks>

<verification>
- [ ] entity_v2.py exports response models with change_status
- [ ] graph.py exports GraphNode, GraphEdge, GraphResponse
- [ ] draft_overlay.py exports DraftOverlayService and DraftContextDep
- [ ] jsonpatch in requirements.txt
- [ ] DraftOverlayService.apply_overlay handles CREATE, UPDATE, DELETE, and no-change cases
- [ ] deepcopy used before applying JSON Patch
</verification>

<success_criteria>
Response schemas support change_status metadata; DraftOverlayService can load draft changes and compute effective views by applying JSON Patch to canonical data.
</success_criteria>

<output>
After completion, create `.planning/phases/10-query-layer/10-01-SUMMARY.md`
</output>
