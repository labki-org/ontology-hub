---
phase: 10-query-layer
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - backend/app/services/graph_query.py
  - backend/app/routers/graph.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "Neighborhood graph returns nodes/edges within specified depth of selected entity"
    - "Module-scoped graph returns all nodes/edges for entities in a module"
    - "Graph nodes include module membership for hull rendering"
    - "Graph nodes include change_status badges in draft context"
  artifacts:
    - path: "backend/app/services/graph_query.py"
      provides: "Graph traversal service with recursive CTEs"
      exports: ["GraphQueryService"]
    - path: "backend/app/routers/graph.py"
      provides: "Graph API endpoints"
      exports: ["router"]
  key_links:
    - from: "backend/app/services/graph_query.py"
      to: "category_parent"
      via: "recursive CTE"
      pattern: "WITH RECURSIVE"
    - from: "backend/app/routers/graph.py"
      to: "app.services.draft_overlay.DraftContextDep"
      via: "FastAPI dependency"
      pattern: "DraftContextDep"
    - from: "backend/app/routers/graph.py"
      to: "app.services.graph_query.GraphQueryService"
      via: "service instantiation"
      pattern: "GraphQueryService"
---

<objective>
Implement graph query endpoints for neighborhood and module-scoped visualization

Purpose: Enable frontend graph visualization by providing neighborhood traversal (GRP-01) and module-scoped (GRP-02) graph queries that include module membership for hull rendering (GRP-03) and change status badges in draft context (GRP-04).

Output: GraphQueryService with recursive CTE queries and FastAPI router for graph endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-query-layer/10-CONTEXT.md
@.planning/phases/10-query-layer/10-RESEARCH.md
@.planning/phases/10-query-layer/10-01-SUMMARY.md

# v2.0 models
@backend/app/models/v2/__init__.py
@backend/app/models/v2/relationships.py

# Dependencies from 10-01
@backend/app/services/draft_overlay.py
@backend/app/schemas/graph.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GraphQueryService with recursive CTE queries</name>
  <files>backend/app/services/graph_query.py</files>
  <action>
Create GraphQueryService class for graph traversal queries.

**Class structure:**
```python
class GraphQueryService:
    def __init__(self, session: AsyncSession, draft_overlay: DraftOverlayService):
        self.session = session
        self.draft_overlay = draft_overlay

    async def get_neighborhood_graph(
        self,
        entity_key: str,
        entity_type: str = "category",
        depth: int = 2,
    ) -> GraphResponse:
        """Get neighborhood graph for entity within specified depth (GRP-01).

        Returns nodes and edges for ancestors and descendants up to depth levels.
        Includes module membership for hull rendering (GRP-03).
        Applies draft overlay for change_status (GRP-04).
        """

    async def get_module_graph(
        self,
        module_key: str,
    ) -> GraphResponse:
        """Get graph of all entities in a module (GRP-02).

        Returns nodes and edges for all entities in the module.
        Includes module membership for hull rendering (GRP-03).
        Applies draft overlay for change_status (GRP-04).
        """

    async def _get_module_membership(
        self,
        entity_keys: list[str],
        entity_type: str = "category",
    ) -> dict[str, list[str]]:
        """Batch load module membership for entities to avoid N+1 queries."""
```

**Neighborhood graph CTE:**
```sql
WITH RECURSIVE neighborhood AS (
    -- Base: starting category
    SELECT c.id, c.entity_key, c.label, 0 as depth, 'start' as direction, ARRAY[c.id] as path
    FROM categories c WHERE c.entity_key = :entity_key

    UNION ALL

    -- Ancestors (parents)
    SELECT c.id, c.entity_key, c.label, n.depth + 1, 'ancestor', n.path || c.id
    FROM categories c
    JOIN category_parent cp ON cp.parent_id = c.id
    JOIN neighborhood n ON n.id = cp.category_id
    WHERE n.depth < :max_depth AND NOT c.id = ANY(n.path)

    UNION ALL

    -- Descendants (children)
    SELECT c.id, c.entity_key, c.label, n.depth + 1, 'descendant', n.path || c.id
    FROM categories c
    JOIN category_parent cp ON cp.category_id = c.id
    JOIN neighborhood n ON n.id = cp.parent_id
    WHERE n.depth < :max_depth AND NOT c.id = ANY(n.path)
)
SELECT DISTINCT ON (id) id, entity_key, label, depth
FROM neighborhood ORDER BY id, depth;
```

**Module graph query:**
- Query ModuleEntity for entity_type=category where module matches
- Get all category_keys in module
- Query categories table for node data
- Query category_parent for edges between module categories

**Module membership batch query:**
- Query ModuleEntity where entity_key IN (:keys) and entity_type matches
- Group by entity_key, collect module keys

**Draft overlay integration:**
- After getting node data, apply draft_overlay.apply_overlay to each
- Extract change_status from overlay result
- For draft-created categories in the module, add them to nodes

**Cycle detection:**
- Use path array in CTE to detect cycles
- Set has_cycles=True in response if any node appears twice in traversal
  </action>
  <verify>python -c "from app.services.graph_query import GraphQueryService; print('OK')" from backend dir</verify>
  <done>GraphQueryService implements neighborhood and module graph queries with recursive CTEs, module membership, and draft overlay</done>
</task>

<task type="auto">
  <name>Task 2: Create graph router and register in main.py</name>
  <files>backend/app/routers/graph.py, backend/app/main.py</files>
  <action>
Create graph.py router with /api/v2/graph prefix.

**Endpoints:**

1. **GET /neighborhood** - Neighborhood graph (GRP-01)
   - Query params:
     - entity_key: str (required) - Starting entity
     - entity_type: str (default "category") - Type of starting entity
     - depth: int (default 2, ge=1, le=5) - Max traversal depth
     - draft_id: Optional[UUID] - Draft context for change_status
   - Create GraphQueryService with session and draft context
   - Call get_neighborhood_graph()
   - Return GraphResponse

2. **GET /module/{module_key}** - Module-scoped graph (GRP-02)
   - Query params:
     - draft_id: Optional[UUID] - Draft context for change_status
   - Path param: module_key
   - Create GraphQueryService with session and draft context
   - Call get_module_graph()
   - Return GraphResponse

**Router structure:**
```python
router = APIRouter(prefix="/graph", tags=["graph"])

@router.get("/neighborhood", response_model=GraphResponse)
async def get_neighborhood_graph(
    entity_key: str = Query(..., description="Starting entity key"),
    entity_type: str = Query("category", description="Entity type"),
    depth: int = Query(2, ge=1, le=5, description="Max traversal depth"),
    draft_ctx: DraftContextDep,
) -> GraphResponse:
    service = GraphQueryService(draft_ctx.session, draft_ctx)
    return await service.get_neighborhood_graph(entity_key, entity_type, depth)

@router.get("/module/{module_key}", response_model=GraphResponse)
async def get_module_graph(
    module_key: str,
    draft_ctx: DraftContextDep,
) -> GraphResponse:
    service = GraphQueryService(draft_ctx.session, draft_ctx)
    return await service.get_module_graph(module_key)
```

**Register in main.py:**
- Import router from app.routers.graph
- Add: `app.include_router(graph.router, prefix="/api/v2")`

**Error handling:**
- 404 if starting entity not found
- 404 if module not found
  </action>
  <verify>python -c "from app.routers.graph import router; print(f'Routes: {len(router.routes)}')" from backend dir</verify>
  <done>Graph router with neighborhood and module endpoints registered at /api/v2/graph</done>
</task>

</tasks>

<verification>
- [ ] GET /api/v2/graph/neighborhood returns nodes/edges within depth
- [ ] GET /api/v2/graph/module/{key} returns module-scoped graph
- [ ] Graph nodes include modules list for hull rendering
- [ ] Graph nodes include change_status when draft_id provided
- [ ] Cycle detection prevents infinite loops in CTE
- [ ] Module membership loaded in batch (no N+1)
- [ ] Router registered in main.py
</verification>

<success_criteria>
Graph endpoints operational with neighborhood traversal using recursive CTEs, module-scoped queries, module membership for hull rendering, and change status badges in draft context.
</success_criteria>

<output>
After completion, create `.planning/phases/10-query-layer/10-03-SUMMARY.md`
</output>
