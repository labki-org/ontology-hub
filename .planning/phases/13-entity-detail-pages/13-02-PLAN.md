---
phase: 13-entity-detail-pages
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - frontend/src/components/entity/form/EditableField.tsx
  - frontend/src/components/entity/form/VisualChangeMarker.tsx
  - frontend/src/components/entity/form/EditableList.tsx
  - frontend/src/components/entity/sections/EntityHeader.tsx
  - frontend/src/components/entity/sections/AccordionSection.tsx
autonomous: true

must_haves:
  truths:
    - "EditableField shows text in view mode, becomes editable input in edit mode"
    - "Modified fields show background shading and left border accent"
    - "Hover on modified field shows original value in tooltip"
    - "Revert button per field restores original value"
    - "EditableList allows adding/removing items in edit mode"
  artifacts:
    - path: "frontend/src/components/entity/form/EditableField.tsx"
      provides: "Inline editable text field with revert"
      exports: ["EditableField"]
    - path: "frontend/src/components/entity/form/VisualChangeMarker.tsx"
      provides: "Background shading and border for modified fields"
      exports: ["VisualChangeMarker"]
    - path: "frontend/src/components/entity/form/EditableList.tsx"
      provides: "Add/remove list items in edit mode"
      exports: ["EditableList"]
    - path: "frontend/src/components/entity/sections/EntityHeader.tsx"
      provides: "Shared entity header with name, label, description"
      exports: ["EntityHeader"]
  key_links:
    - from: "frontend/src/components/entity/form/EditableField.tsx"
      to: "frontend/src/components/entity/form/VisualChangeMarker.tsx"
      via: "wraps content"
      pattern: "VisualChangeMarker"
---

<objective>
Create reusable form components for edit mode - editable fields with visual change indicators, revert functionality, and list editing.

Purpose: These shared form components will be used by all 6 entity detail pages to provide consistent edit mode UX with visual markers for modified fields.

Output: EditableField, VisualChangeMarker, EditableList, EntityHeader, AccordionSection components ready for use.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-entity-detail-pages/13-CONTEXT.md
@.planning/phases/13-entity-detail-pages/13-RESEARCH.md
@.planning/phases/13-entity-detail-pages/13-01-SUMMARY.md
@frontend/src/components/ui/input.tsx
@frontend/src/components/ui/tooltip.tsx
@frontend/src/components/ui/accordion.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VisualChangeMarker component</name>
  <files>frontend/src/components/entity/form/VisualChangeMarker.tsx</files>
  <action>
Create `frontend/src/components/entity/form/VisualChangeMarker.tsx` - wrapper component that adds visual styling for modified/new/deleted fields:

```typescript
import { cn } from '@/lib/utils'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip'

type ChangeStatus = 'modified' | 'added' | 'deleted' | 'unchanged'

interface VisualChangeMarkerProps {
  children: React.ReactNode
  status: ChangeStatus
  originalValue?: string
  className?: string
}

/**
 * Wrapper that adds visual change indicators based on CONTEXT.md decisions:
 * - Modified: Background shading + left border accent, hover shows original
 * - Added: Green badge + full green border
 * - Deleted: Red overlay/styling + 'DELETED' badge
 * - Unchanged: No styling
 */
export function VisualChangeMarker({
  children,
  status,
  originalValue,
  className,
}: VisualChangeMarkerProps) {
  if (status === 'unchanged') {
    return <div className={className}>{children}</div>
  }

  const statusStyles = {
    modified: 'bg-yellow-50 border-l-4 border-l-yellow-500 pl-2',
    added: 'bg-green-50 border-2 border-green-500 rounded',
    deleted: 'bg-red-50 border-2 border-red-300 opacity-60',
  }

  const content = (
    <div className={cn(statusStyles[status], 'relative', className)}>
      {status === 'deleted' && (
        <span className="absolute -top-2 -right-2 bg-red-500 text-white text-xs px-1 rounded">
          DELETED
        </span>
      )}
      {status === 'added' && (
        <span className="absolute -top-2 -right-2 bg-green-500 text-white text-xs px-1 rounded">
          NEW
        </span>
      )}
      {children}
    </div>
  )

  // Show original value tooltip for modified fields
  if (status === 'modified' && originalValue !== undefined) {
    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>{content}</TooltipTrigger>
          <TooltipContent>
            <p className="text-sm">
              <span className="text-muted-foreground">Original: </span>
              {originalValue || '(empty)'}
            </p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    )
  }

  return content
}
```

This implements the CONTEXT.md decisions:
- Modified fields: background shading AND left border accent
- Original value: hover tooltip shows original
- New entities: green badge + full green border
- Deleted entities: red overlay/styling and 'DELETED' badge
  </action>
  <verify>
File exists and exports VisualChangeMarker:
```bash
grep -n "export function VisualChangeMarker" frontend/src/components/entity/form/VisualChangeMarker.tsx
```
  </verify>
  <done>VisualChangeMarker component created with visual indicators for modified/added/deleted states</done>
</task>

<task type="auto">
  <name>Task 2: Create EditableField component</name>
  <files>frontend/src/components/entity/form/EditableField.tsx</files>
  <action>
Create `frontend/src/components/entity/form/EditableField.tsx` - inline editable field with view/edit modes:

```typescript
import { useState, useEffect, useCallback } from 'react'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Button } from '@/components/ui/button'
import { VisualChangeMarker } from './VisualChangeMarker'
import { RotateCcw } from 'lucide-react'

interface EditableFieldProps {
  value: string
  originalValue?: string
  onChange: (value: string) => void
  onRevert?: () => void
  isEditing: boolean
  multiline?: boolean
  label?: string
  placeholder?: string
  className?: string
}

/**
 * Inline editable field that:
 * - Shows text in view mode
 * - Becomes input/textarea in edit mode
 * - Shows visual change marker when value differs from original
 * - Has revert button to restore original value
 * - ESC key reverts, Enter saves (single-line only)
 */
export function EditableField({
  value,
  originalValue,
  onChange,
  onRevert,
  isEditing,
  multiline = false,
  label,
  placeholder,
  className,
}: EditableFieldProps) {
  const [localValue, setLocalValue] = useState(value)

  // Sync local value with prop when it changes externally
  useEffect(() => {
    setLocalValue(value)
  }, [value])

  const isModified = originalValue !== undefined && value !== originalValue
  const status = isModified ? 'modified' : 'unchanged'

  const handleChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
      const newValue = e.target.value
      setLocalValue(newValue)
      onChange(newValue)
    },
    [onChange]
  )

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Escape' && onRevert) {
        onRevert()
        e.preventDefault()
      }
      // Enter to save only for single-line inputs
      if (e.key === 'Enter' && !multiline) {
        ;(e.target as HTMLInputElement).blur()
        e.preventDefault()
      }
    },
    [onRevert, multiline]
  )

  // View mode
  if (!isEditing) {
    return (
      <VisualChangeMarker status={status} originalValue={originalValue} className={className}>
        <div className="py-1">
          {label && (
            <span className="text-sm font-medium text-muted-foreground">{label}: </span>
          )}
          <span>{value || <span className="text-muted-foreground italic">(empty)</span>}</span>
        </div>
      </VisualChangeMarker>
    )
  }

  // Edit mode
  const InputComponent = multiline ? Textarea : Input

  return (
    <VisualChangeMarker status={status} originalValue={originalValue} className={className}>
      <div className="flex items-start gap-2">
        <div className="flex-1">
          {label && (
            <label className="text-sm font-medium text-muted-foreground mb-1 block">
              {label}
            </label>
          )}
          <InputComponent
            value={localValue}
            onChange={handleChange}
            onKeyDown={handleKeyDown}
            placeholder={placeholder}
            className={multiline ? 'min-h-[80px]' : ''}
          />
        </div>
        {isModified && onRevert && (
          <Button
            variant="ghost"
            size="icon"
            onClick={onRevert}
            title="Revert to original"
            className="mt-6"
          >
            <RotateCcw className="h-4 w-4" />
          </Button>
        )}
      </div>
    </VisualChangeMarker>
  )
}
```

Features:
- Shows plain text in view mode, input in edit mode
- ESC key reverts to original (per CONTEXT.md)
- Revert button per field when modified
- Wrapped in VisualChangeMarker for styling
  </action>
  <verify>
File exists and exports EditableField:
```bash
grep -n "export function EditableField" frontend/src/components/entity/form/EditableField.tsx
```
  </verify>
  <done>EditableField component created with view/edit modes, ESC to revert, and visual change markers</done>
</task>

<task type="auto">
  <name>Task 3: Create EditableList and section components</name>
  <files>
    frontend/src/components/entity/form/EditableList.tsx
    frontend/src/components/entity/sections/EntityHeader.tsx
    frontend/src/components/entity/sections/AccordionSection.tsx
  </files>
  <action>
Create `frontend/src/components/entity/form/EditableList.tsx`:

```typescript
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Badge } from '@/components/ui/badge'
import { Plus, X } from 'lucide-react'
import { useState } from 'react'

interface EditableListProps {
  items: string[]
  onAdd: (item: string) => void
  onRemove: (item: string) => void
  isEditing: boolean
  renderItem?: (item: string) => React.ReactNode
  placeholder?: string
  emptyMessage?: string
}

/**
 * List that allows adding/removing items in edit mode.
 * Shows edit icons in draft mode per CONTEXT.md.
 */
export function EditableList({
  items,
  onAdd,
  onRemove,
  isEditing,
  renderItem,
  placeholder = 'Add item...',
  emptyMessage = 'No items',
}: EditableListProps) {
  const [newItem, setNewItem] = useState('')

  const handleAdd = () => {
    if (newItem.trim()) {
      onAdd(newItem.trim())
      setNewItem('')
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleAdd()
      e.preventDefault()
    }
  }

  if (items.length === 0 && !isEditing) {
    return <p className="text-sm text-muted-foreground italic">{emptyMessage}</p>
  }

  return (
    <div className="space-y-2">
      <div className="flex flex-wrap gap-2">
        {items.map((item) => (
          <div key={item} className="flex items-center gap-1">
            {renderItem ? (
              renderItem(item)
            ) : (
              <Badge variant="secondary">{item}</Badge>
            )}
            {isEditing && (
              <Button
                variant="ghost"
                size="icon"
                className="h-5 w-5"
                onClick={() => onRemove(item)}
              >
                <X className="h-3 w-3" />
              </Button>
            )}
          </div>
        ))}
      </div>
      {isEditing && (
        <div className="flex gap-2">
          <Input
            value={newItem}
            onChange={(e) => setNewItem(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder={placeholder}
            className="max-w-xs"
          />
          <Button variant="outline" size="sm" onClick={handleAdd}>
            <Plus className="h-4 w-4 mr-1" /> Add
          </Button>
        </div>
      )}
    </div>
  )
}
```

Create `frontend/src/components/entity/sections/EntityHeader.tsx`:

```typescript
import { Badge } from '@/components/ui/badge'
import { EditableField } from '../form/EditableField'

type ChangeStatus = 'added' | 'modified' | 'deleted' | 'unchanged'

interface EntityHeaderProps {
  entityKey: string
  label: string
  description?: string | null
  entityType: string
  changeStatus?: ChangeStatus
  isEditing: boolean
  originalLabel?: string
  originalDescription?: string
  onLabelChange?: (value: string) => void
  onDescriptionChange?: (value: string) => void
  onRevertLabel?: () => void
  onRevertDescription?: () => void
}

/**
 * Shared header component for all entity detail pages.
 * Shows name, label, description with edit capability and change status badge.
 */
export function EntityHeader({
  entityKey,
  label,
  description,
  entityType,
  changeStatus,
  isEditing,
  originalLabel,
  originalDescription,
  onLabelChange,
  onDescriptionChange,
  onRevertLabel,
  onRevertDescription,
}: EntityHeaderProps) {
  const statusBadge = changeStatus && changeStatus !== 'unchanged' && (
    <Badge
      variant={
        changeStatus === 'added'
          ? 'default'
          : changeStatus === 'modified'
          ? 'secondary'
          : 'destructive'
      }
      className={
        changeStatus === 'added'
          ? 'bg-green-500 hover:bg-green-600'
          : changeStatus === 'modified'
          ? 'bg-yellow-500 hover:bg-yellow-600'
          : ''
      }
    >
      {changeStatus === 'added'
        ? '+ Added'
        : changeStatus === 'modified'
        ? '~ Modified'
        : '- Deleted'}
    </Badge>
  )

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-3">
        <Badge variant="outline" className="capitalize">
          {entityType}
        </Badge>
        <code className="text-sm text-muted-foreground">{entityKey}</code>
        {statusBadge}
      </div>

      <EditableField
        value={label}
        originalValue={originalLabel}
        onChange={onLabelChange || (() => {})}
        onRevert={onRevertLabel}
        isEditing={isEditing && !!onLabelChange}
        label="Label"
        placeholder="Enter label..."
        className="text-2xl font-bold"
      />

      <EditableField
        value={description || ''}
        originalValue={originalDescription}
        onChange={onDescriptionChange || (() => {})}
        onRevert={onRevertDescription}
        isEditing={isEditing && !!onDescriptionChange}
        multiline
        label="Description"
        placeholder="Enter description..."
      />
    </div>
  )
}
```

Create `frontend/src/components/entity/sections/AccordionSection.tsx`:

```typescript
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion'
import { Badge } from '@/components/ui/badge'

interface AccordionSectionProps {
  id: string
  title: string
  count?: number
  defaultOpen?: boolean
  children: React.ReactNode
}

/**
 * Collapsible accordion section for organizing entity details.
 * Per CONTEXT.md: sections reset to default state on navigation.
 */
export function AccordionSection({
  id,
  title,
  count,
  defaultOpen = true,
  children,
}: AccordionSectionProps) {
  return (
    <Accordion
      type="single"
      collapsible
      defaultValue={defaultOpen ? id : undefined}
    >
      <AccordionItem value={id}>
        <AccordionTrigger className="text-sm font-semibold text-muted-foreground uppercase tracking-wide">
          <span className="flex items-center gap-2">
            {title}
            {count !== undefined && (
              <Badge variant="secondary" className="text-xs">
                {count}
              </Badge>
            )}
          </span>
        </AccordionTrigger>
        <AccordionContent>{children}</AccordionContent>
      </AccordionItem>
    </Accordion>
  )
}
```
  </action>
  <verify>
All files exist with correct exports:
```bash
grep -n "export function" frontend/src/components/entity/form/EditableList.tsx
grep -n "export function" frontend/src/components/entity/sections/EntityHeader.tsx
grep -n "export function" frontend/src/components/entity/sections/AccordionSection.tsx
```
  </verify>
  <done>EditableList, EntityHeader, and AccordionSection components created for entity detail pages</done>
</task>

</tasks>

<verification>
1. All form components exist:
   - `ls frontend/src/components/entity/form/`
2. All section components exist:
   - `ls frontend/src/components/entity/sections/`
3. TypeScript compiles: `cd frontend && npm run build`
4. Components export correctly:
   - `grep "export function" frontend/src/components/entity/form/*.tsx`
   - `grep "export function" frontend/src/components/entity/sections/*.tsx`
</verification>

<success_criteria>
- VisualChangeMarker applies correct styling for modified/added/deleted states
- EditableField toggles between view/edit modes with ESC to revert
- EditableList allows add/remove in edit mode with X buttons
- EntityHeader shows entity type badge, key, label, description with change status
- AccordionSection wraps content in collapsible section with count badge
- All components use existing shadcn/ui primitives (Input, Badge, Accordion)
</success_criteria>

<output>
After completion, create `.planning/phases/13-entity-detail-pages/13-02-SUMMARY.md`
</output>
