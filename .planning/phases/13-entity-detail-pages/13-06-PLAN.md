---
phase: 13-entity-detail-pages
plan: 06
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - frontend/src/components/entity/detail/ModuleDetail.tsx
  - frontend/src/components/entity/detail/BundleDetail.tsx
autonomous: true

must_haves:
  truths:
    - "Module page shows direct members grouped by entity type"
    - "Module page shows computed closure (transitive dependencies)"
    - "Module page shows version and suggested version increment"
    - "Bundle page shows modules list"
    - "Bundle page shows computed closure (all modules including dependencies)"
    - "Edit mode allows adding/removing members from modules/bundles"
  artifacts:
    - path: "frontend/src/components/entity/detail/ModuleDetail.tsx"
      provides: "Module detail with members and closure"
      exports: ["ModuleDetail"]
    - path: "frontend/src/components/entity/detail/BundleDetail.tsx"
      provides: "Bundle detail with modules and closure"
      exports: ["BundleDetail"]
  key_links:
    - from: "frontend/src/components/entity/detail/ModuleDetail.tsx"
      to: "frontend/src/api/entitiesV2.ts"
      via: "useModule hook"
      pattern: "useModule"
    - from: "frontend/src/components/entity/detail/BundleDetail.tsx"
      to: "frontend/src/api/entitiesV2.ts"
      via: "useBundle hook"
      pattern: "useBundle"
---

<objective>
Implement Module and Bundle entity detail pages with members, computed closure, and edit capabilities.

Purpose: Modules and Bundles organize entities for deployment. These detail pages show their contents and transitive dependencies, enabling users to understand the full scope of what gets deployed.

Output: ModuleDetail and BundleDetail components with member lists, closure visualization, and edit mode.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-entity-detail-pages/13-CONTEXT.md
@.planning/phases/13-entity-detail-pages/13-02-SUMMARY.md
@.planning/phases/13-entity-detail-pages/13-03-SUMMARY.md
@frontend/src/api/types.ts
@backend/app/schemas/entity_v2.py
@backend/app/routers/entities_v2.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ModuleDetail component</name>
  <files>frontend/src/components/entity/detail/ModuleDetail.tsx</files>
  <action>
Replace placeholder `frontend/src/components/entity/detail/ModuleDetail.tsx`:

```typescript
import { useEffect, useState, useCallback } from 'react'
import { useModule } from '@/api/entitiesV2'
import { useAutoSave } from '@/hooks/useAutoSave'
import { useDetailStore } from '@/stores/detailStore'
import { EntityHeader } from '../sections/EntityHeader'
import { AccordionSection } from '../sections/AccordionSection'
import { EditableList } from '../form/EditableList'
import { Badge } from '@/components/ui/badge'
import { Skeleton } from '@/components/ui/skeleton'
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible'
import { ChevronDown } from 'lucide-react'
import type { ModuleDetailV2 } from '@/api/types'

interface ModuleDetailProps {
  entityKey: string
  draftId?: string
  isEditing: boolean
}

const ENTITY_TYPE_ORDER = ['category', 'property', 'subobject', 'template']
const ENTITY_TYPE_LABELS: Record<string, string> = {
  category: 'Categories',
  property: 'Properties',
  subobject: 'Subobjects',
  template: 'Templates',
}

/**
 * Module detail view with:
 * - Header (name, label, version)
 * - Direct members grouped by entity type (per CONTEXT.md)
 * - Computed closure (transitive category dependencies)
 * - Suggested version increment (placeholder)
 */
export function ModuleDetail({
  entityKey,
  draftId,
  isEditing,
}: ModuleDetailProps) {
  const { data, isLoading, error } = useModule(entityKey, draftId)
  const openDetail = useDetailStore((s) => s.openDetail)
  const pushBreadcrumb = useDetailStore((s) => s.pushBreadcrumb)

  // Cast to ModuleDetailV2
  const module = data as ModuleDetailV2 | undefined

  // Track original values
  const [originalValues, setOriginalValues] = useState<{
    label?: string
  }>({})

  // Local editable state
  const [editedLabel, setEditedLabel] = useState('')
  const [editedEntities, setEditedEntities] = useState<Record<string, string[]>>({})

  // Auto-save hook
  const { saveChange, isSaving } = useAutoSave({
    draftToken: draftId || '',
    entityType: 'module',
    entityKey,
    debounceMs: 500,
  })

  // Initialize state
  useEffect(() => {
    if (module) {
      setEditedLabel(module.label)
      setEditedEntities(module.entities || {})

      setOriginalValues({
        label: module.label,
      })

      pushBreadcrumb(entityKey, 'module', module.label)
    }
  }, [module, entityKey, pushBreadcrumb])

  // Change handlers
  const handleLabelChange = useCallback(
    (value: string) => {
      setEditedLabel(value)
      if (draftId) saveChange([{ op: 'replace', path: '/label', value }])
    },
    [draftId, saveChange]
  )

  const handleAddEntity = useCallback(
    (entityType: string, entKey: string) => {
      const newEntities = { ...editedEntities }
      if (!newEntities[entityType]) newEntities[entityType] = []
      newEntities[entityType] = [...newEntities[entityType], entKey]
      setEditedEntities(newEntities)
      if (draftId) saveChange([{ op: 'replace', path: '/entities', value: newEntities }])
    },
    [editedEntities, draftId, saveChange]
  )

  const handleRemoveEntity = useCallback(
    (entityType: string, entKey: string) => {
      const newEntities = { ...editedEntities }
      newEntities[entityType] = (newEntities[entityType] || []).filter((k) => k !== entKey)
      setEditedEntities(newEntities)
      if (draftId) saveChange([{ op: 'replace', path: '/entities', value: newEntities }])
    },
    [editedEntities, draftId, saveChange]
  )

  if (isLoading) {
    return (
      <div className="p-6 space-y-4">
        <Skeleton className="h-8 w-64" />
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-32 w-full" />
      </div>
    )
  }

  if (error || !module) {
    return (
      <div className="p-6 text-center text-destructive">
        <p className="font-medium">Failed to load module</p>
        <p className="text-sm text-muted-foreground mt-1">
          {error instanceof Error ? error.message : 'Module not found'}
        </p>
      </div>
    )
  }

  // Count total members
  const totalMembers = Object.values(editedEntities).reduce(
    (sum, arr) => sum + arr.length,
    0
  )

  return (
    <div className="p-6 space-y-6">
      {isSaving && (
        <div className="fixed top-4 right-4 bg-primary text-primary-foreground px-3 py-1 rounded text-sm">
          Saving...
        </div>
      )}

      {/* Header with version */}
      <div className="space-y-4">
        <EntityHeader
          entityKey={entityKey}
          label={editedLabel}
          description={null}
          entityType="module"
          changeStatus={module.change_status}
          isEditing={isEditing}
          originalLabel={originalValues.label}
          onLabelChange={handleLabelChange}
        />
        {module.version && (
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground">Version:</span>
            <Badge variant="outline">{module.version}</Badge>
          </div>
        )}
      </div>

      {/* Direct Members - grouped by entity type per CONTEXT.md */}
      <AccordionSection
        id="members"
        title="Direct Members"
        count={totalMembers}
      >
        <div className="space-y-4">
          {ENTITY_TYPE_ORDER.map((entityType) => {
            const members = editedEntities[entityType] || []
            if (members.length === 0 && !isEditing) return null

            return (
              <Collapsible key={entityType} defaultOpen={members.length > 0}>
                <CollapsibleTrigger className="flex items-center gap-2 w-full p-2 rounded hover:bg-muted/50 text-left">
                  <ChevronDown className="h-4 w-4 transition-transform duration-200 [&[data-state=open]]:rotate-180" />
                  <span className="text-sm font-medium">
                    {ENTITY_TYPE_LABELS[entityType] || entityType}
                  </span>
                  <Badge variant="secondary" className="text-xs ml-auto">
                    {members.length}
                  </Badge>
                </CollapsibleTrigger>
                <CollapsibleContent className="pl-6">
                  <EditableList
                    items={members}
                    onAdd={(key) => handleAddEntity(entityType, key)}
                    onRemove={(key) => handleRemoveEntity(entityType, key)}
                    isEditing={isEditing}
                    placeholder={`Add ${entityType}...`}
                    emptyMessage={`No ${entityType}s in module`}
                    renderItem={(key) => (
                      <Badge
                        variant="secondary"
                        className="cursor-pointer hover:bg-secondary/80"
                        onClick={() => openDetail(key, entityType)}
                      >
                        {key}
                      </Badge>
                    )}
                  />
                </CollapsibleContent>
              </Collapsible>
            )
          })}
        </div>
      </AccordionSection>

      {/* Computed Closure */}
      <AccordionSection
        id="closure"
        title="Computed Dependencies"
        count={module.closure.length}
        defaultOpen={false}
      >
        {module.closure.length > 0 ? (
          <div className="space-y-2">
            <p className="text-sm text-muted-foreground">
              These categories are automatically included because module categories inherit from them:
            </p>
            <div className="flex flex-wrap gap-2">
              {module.closure.map((catKey) => (
                <Badge
                  key={catKey}
                  variant="outline"
                  className="cursor-pointer hover:bg-muted"
                  onClick={() => openDetail(catKey, 'category')}
                >
                  {catKey}
                </Badge>
              ))}
            </div>
          </div>
        ) : (
          <p className="text-sm text-muted-foreground italic">
            No transitive dependencies
          </p>
        )}
      </AccordionSection>

      {/* TODO: Suggested version increment - needs validation results */}
      <AccordionSection
        id="versioning"
        title="Version Increment"
        defaultOpen={false}
      >
        <p className="text-sm text-muted-foreground italic">
          Version increment suggestions will appear after validation
        </p>
      </AccordionSection>
    </div>
  )
}
```

This implements:
- MOD-01: Header with name, label (description omitted as modules typically don't have it)
- MOD-02: Direct members list grouped by entity type
- MOD-03: Computed closure view showing auto-included dependencies
- MOD-04: Dependencies list (shown as closure)
- MOD-05: Edit icons for adding/removing members in draft mode
- MOD-06: Suggested version increment display (placeholder - needs Phase 14 validation)
  </action>
  <verify>
ModuleDetail exists and uses hook:
```bash
grep -n "export function ModuleDetail" frontend/src/components/entity/detail/ModuleDetail.tsx
grep -n "useModule" frontend/src/components/entity/detail/ModuleDetail.tsx
```
  </verify>
  <done>ModuleDetail component implemented with members grouped by type, closure, and edit mode</done>
</task>

<task type="auto">
  <name>Task 2: Implement BundleDetail component</name>
  <files>frontend/src/components/entity/detail/BundleDetail.tsx</files>
  <action>
Replace placeholder `frontend/src/components/entity/detail/BundleDetail.tsx`:

```typescript
import { useEffect, useState, useCallback } from 'react'
import { useBundle } from '@/api/entitiesV2'
import { useAutoSave } from '@/hooks/useAutoSave'
import { useDetailStore } from '@/stores/detailStore'
import { EntityHeader } from '../sections/EntityHeader'
import { AccordionSection } from '../sections/AccordionSection'
import { EditableList } from '../form/EditableList'
import { Badge } from '@/components/ui/badge'
import { Skeleton } from '@/components/ui/skeleton'
import type { BundleDetailV2 } from '@/api/types'

interface BundleDetailProps {
  entityKey: string
  draftId?: string
  isEditing: boolean
}

/**
 * Bundle detail view with:
 * - Header (name, label, version)
 * - Modules list
 * - Computed closure (all modules including dependencies)
 * - Suggested version increment (placeholder)
 */
export function BundleDetail({
  entityKey,
  draftId,
  isEditing,
}: BundleDetailProps) {
  const { data, isLoading, error } = useBundle(entityKey, draftId)
  const openDetail = useDetailStore((s) => s.openDetail)
  const pushBreadcrumb = useDetailStore((s) => s.pushBreadcrumb)

  // Cast to BundleDetailV2
  const bundle = data as BundleDetailV2 | undefined

  // Track original values
  const [originalValues, setOriginalValues] = useState<{
    label?: string
  }>({})

  // Local editable state
  const [editedLabel, setEditedLabel] = useState('')
  const [editedModules, setEditedModules] = useState<string[]>([])

  // Auto-save hook
  const { saveChange, isSaving } = useAutoSave({
    draftToken: draftId || '',
    entityType: 'bundle',
    entityKey,
    debounceMs: 500,
  })

  // Initialize state
  useEffect(() => {
    if (bundle) {
      setEditedLabel(bundle.label)
      setEditedModules(bundle.modules || [])

      setOriginalValues({
        label: bundle.label,
      })

      pushBreadcrumb(entityKey, 'bundle', bundle.label)
    }
  }, [bundle, entityKey, pushBreadcrumb])

  // Change handlers
  const handleLabelChange = useCallback(
    (value: string) => {
      setEditedLabel(value)
      if (draftId) saveChange([{ op: 'replace', path: '/label', value }])
    },
    [draftId, saveChange]
  )

  const handleAddModule = useCallback(
    (moduleKey: string) => {
      const newModules = [...editedModules, moduleKey]
      setEditedModules(newModules)
      if (draftId) saveChange([{ op: 'replace', path: '/modules', value: newModules }])
    },
    [editedModules, draftId, saveChange]
  )

  const handleRemoveModule = useCallback(
    (moduleKey: string) => {
      const newModules = editedModules.filter((m) => m !== moduleKey)
      setEditedModules(newModules)
      if (draftId) saveChange([{ op: 'replace', path: '/modules', value: newModules }])
    },
    [editedModules, draftId, saveChange]
  )

  if (isLoading) {
    return (
      <div className="p-6 space-y-4">
        <Skeleton className="h-8 w-64" />
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-32 w-full" />
      </div>
    )
  }

  if (error || !bundle) {
    return (
      <div className="p-6 text-center text-destructive">
        <p className="font-medium">Failed to load bundle</p>
        <p className="text-sm text-muted-foreground mt-1">
          {error instanceof Error ? error.message : 'Bundle not found'}
        </p>
      </div>
    )
  }

  return (
    <div className="p-6 space-y-6">
      {isSaving && (
        <div className="fixed top-4 right-4 bg-primary text-primary-foreground px-3 py-1 rounded text-sm">
          Saving...
        </div>
      )}

      {/* Header with version */}
      <div className="space-y-4">
        <EntityHeader
          entityKey={entityKey}
          label={editedLabel}
          description={null}
          entityType="bundle"
          changeStatus={bundle.change_status}
          isEditing={isEditing}
          originalLabel={originalValues.label}
          onLabelChange={handleLabelChange}
        />
        {bundle.version && (
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground">Version:</span>
            <Badge variant="outline">{bundle.version}</Badge>
          </div>
        )}
      </div>

      {/* Modules */}
      <AccordionSection
        id="modules"
        title="Modules"
        count={editedModules.length}
      >
        <EditableList
          items={editedModules}
          onAdd={handleAddModule}
          onRemove={handleRemoveModule}
          isEditing={isEditing}
          placeholder="Add module..."
          emptyMessage="No modules in bundle"
          renderItem={(moduleKey) => (
            <Badge
              variant="secondary"
              className="cursor-pointer hover:bg-secondary/80"
              onClick={() => openDetail(moduleKey, 'module')}
            >
              {moduleKey}
            </Badge>
          )}
        />
      </AccordionSection>

      {/* Computed Closure */}
      <AccordionSection
        id="closure"
        title="Computed Module Closure"
        count={bundle.closure.length}
        defaultOpen={false}
      >
        {bundle.closure.length > 0 ? (
          <div className="space-y-2">
            <p className="text-sm text-muted-foreground">
              These modules are automatically included because bundle modules depend on them:
            </p>
            <div className="flex flex-wrap gap-2">
              {bundle.closure.map((moduleKey) => (
                <Badge
                  key={moduleKey}
                  variant="outline"
                  className="cursor-pointer hover:bg-muted"
                  onClick={() => openDetail(moduleKey, 'module')}
                >
                  {moduleKey}
                </Badge>
              ))}
            </div>
          </div>
        ) : (
          <p className="text-sm text-muted-foreground italic">
            No additional module dependencies
          </p>
        )}
      </AccordionSection>

      {/* TODO: Suggested version increment - needs validation results */}
      <AccordionSection
        id="versioning"
        title="Version Increment"
        defaultOpen={false}
      >
        <p className="text-sm text-muted-foreground italic">
          Version increment suggestions will appear after validation
        </p>
      </AccordionSection>
    </div>
  )
}
```

This implements:
- BND-01: Header with name, label (description omitted)
- BND-02: Modules list
- BND-03: Computed closure view (all modules via dependencies)
- BND-04: Edit icons for adding/removing modules in draft mode
- BND-05: Suggested version increment display (placeholder - needs Phase 14 validation)
  </action>
  <verify>
BundleDetail exists and uses hook:
```bash
grep -n "export function BundleDetail" frontend/src/components/entity/detail/BundleDetail.tsx
grep -n "useBundle" frontend/src/components/entity/detail/BundleDetail.tsx
cd frontend && npm run build 2>&1 | head -20
```
  </verify>
  <done>BundleDetail component implemented with modules list, closure, and edit mode</done>
</task>

</tasks>

<verification>
1. ModuleDetail exists: `ls frontend/src/components/entity/detail/ModuleDetail.tsx`
2. BundleDetail exists: `ls frontend/src/components/entity/detail/BundleDetail.tsx`
3. Both use their respective hooks
4. TypeScript compiles: `cd frontend && npm run build`
</verification>

<success_criteria>
- ModuleDetail shows members grouped by entity type (Categories, Properties, etc.)
- ModuleDetail shows computed closure with transitive category dependencies
- ModuleDetail version displayed with badge
- BundleDetail shows modules list
- BundleDetail shows computed closure of dependent modules
- Edit mode enables add/remove on both modules and bundles
- Auto-save triggers on all changes
</success_criteria>

<output>
After completion, create `.planning/phases/13-entity-detail-pages/13-06-SUMMARY.md`
</output>
