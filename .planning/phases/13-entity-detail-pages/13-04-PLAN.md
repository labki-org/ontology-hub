---
phase: 13-entity-detail-pages
plan: 04
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - frontend/src/components/entity/detail/CategoryDetail.tsx
  - frontend/src/components/entity/sections/PropertiesSection.tsx
autonomous: true

must_haves:
  truths:
    - "Category page shows parents list with click-to-navigate"
    - "Category page shows direct properties separate from inherited properties"
    - "Inherited properties grouped by parent with provenance (source category, depth)"
    - "Edit mode shows add/remove icons for parents and properties"
    - "Changes auto-save with visual feedback markers"
  artifacts:
    - path: "frontend/src/components/entity/detail/CategoryDetail.tsx"
      provides: "Full category detail view with edit mode"
      exports: ["CategoryDetail"]
    - path: "frontend/src/components/entity/sections/PropertiesSection.tsx"
      provides: "Properties list with direct/inherited grouping"
      exports: ["PropertiesSection"]
  key_links:
    - from: "frontend/src/components/entity/detail/CategoryDetail.tsx"
      to: "frontend/src/api/entitiesV2.ts"
      via: "useCategory hook"
      pattern: "useCategory"
    - from: "frontend/src/components/entity/detail/CategoryDetail.tsx"
      to: "frontend/src/hooks/useAutoSave.ts"
      via: "auto-save changes"
      pattern: "useAutoSave"
---

<objective>
Implement the Category entity detail page with full view and edit modes, including parents list, direct and inherited properties with provenance.

Purpose: Categories are the primary entity type users interact with. This plan delivers the complete Category detail experience including inheritance visualization and edit capabilities.

Output: CategoryDetail component showing parents, direct properties, inherited properties grouped by source, with edit mode for modifications.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-entity-detail-pages/13-CONTEXT.md
@.planning/phases/13-entity-detail-pages/13-02-SUMMARY.md
@.planning/phases/13-entity-detail-pages/13-03-SUMMARY.md
@frontend/src/api/types.ts
@frontend/src/api/entitiesV2.ts
@backend/app/schemas/entity_v2.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PropertiesSection component</name>
  <files>frontend/src/components/entity/sections/PropertiesSection.tsx</files>
  <action>
Create `frontend/src/components/entity/sections/PropertiesSection.tsx` - reusable properties display with direct/inherited grouping:

```typescript
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { useDetailStore } from '@/stores/detailStore'
import { AccordionSection } from './AccordionSection'
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible'
import { ChevronDown, X } from 'lucide-react'
import type { PropertyProvenance } from '@/api/types'

interface PropertiesSectionProps {
  properties: PropertyProvenance[]
  isEditing: boolean
  onRemoveProperty?: (propertyKey: string) => void
}

/**
 * Properties section showing direct and inherited properties.
 * Per CONTEXT.md: inherited properties grouped by parent with provenance.
 */
export function PropertiesSection({
  properties,
  isEditing,
  onRemoveProperty,
}: PropertiesSectionProps) {
  const openDetail = useDetailStore((s) => s.openDetail)

  // Separate direct and inherited
  const directProperties = properties.filter((p) => p.is_direct)
  const inheritedProperties = properties.filter((p) => p.is_inherited && !p.is_direct)

  // Group inherited by source category
  const groupedInherited = inheritedProperties.reduce(
    (acc, prop) => {
      const source = prop.source_category
      if (!acc[source]) acc[source] = []
      acc[source].push(prop)
      return acc
    },
    {} as Record<string, PropertyProvenance[]>
  )

  const renderProperty = (prop: PropertyProvenance) => (
    <div
      key={prop.entity_key}
      className="flex items-center justify-between p-2 rounded hover:bg-muted/50"
    >
      <div className="flex items-center gap-2">
        <button
          onClick={() => openDetail(prop.entity_key, 'property')}
          className="font-medium text-sm text-primary hover:underline"
        >
          {prop.label}
        </button>
        {prop.is_required && (
          <Badge variant="outline" className="text-xs">
            Required
          </Badge>
        )}
      </div>
      {isEditing && prop.is_direct && onRemoveProperty && (
        <Button
          variant="ghost"
          size="icon"
          className="h-6 w-6"
          onClick={() => onRemoveProperty(prop.entity_key)}
        >
          <X className="h-3 w-3" />
        </Button>
      )}
    </div>
  )

  return (
    <AccordionSection
      id="properties"
      title="Properties"
      count={properties.length}
    >
      <div className="space-y-6">
        {/* Direct Properties */}
        <div>
          <h4 className="text-sm font-semibold mb-2 flex items-center gap-2">
            Direct Properties
            <Badge variant="default" className="bg-blue-500 text-xs">
              {directProperties.length}
            </Badge>
          </h4>
          {directProperties.length > 0 ? (
            <div className="space-y-1 border rounded-md p-2">
              {directProperties.map(renderProperty)}
            </div>
          ) : (
            <p className="text-sm text-muted-foreground italic">
              No direct properties
            </p>
          )}
        </div>

        {/* Inherited Properties - grouped by source */}
        {Object.keys(groupedInherited).length > 0 && (
          <div>
            <h4 className="text-sm font-semibold mb-2 flex items-center gap-2">
              Inherited Properties
              <Badge variant="secondary" className="text-xs">
                {inheritedProperties.length}
              </Badge>
            </h4>
            <div className="space-y-2">
              {Object.entries(groupedInherited).map(([sourceCategory, props]) => (
                <Collapsible key={sourceCategory} defaultOpen>
                  <CollapsibleTrigger className="flex items-center gap-2 w-full p-2 rounded hover:bg-muted/50 text-left">
                    <ChevronDown className="h-4 w-4 transition-transform duration-200 [&[data-state=open]]:rotate-180" />
                    <span className="text-sm">
                      From{' '}
                      <button
                        onClick={(e) => {
                          e.stopPropagation()
                          openDetail(sourceCategory, 'category')
                        }}
                        className="text-primary hover:underline font-medium"
                      >
                        {sourceCategory}
                      </button>
                    </span>
                    <Badge variant="outline" className="text-xs ml-auto">
                      {props.length}
                    </Badge>
                    {props[0]?.inheritance_depth > 0 && (
                      <span className="text-xs text-muted-foreground">
                        (depth: {props[0].inheritance_depth})
                      </span>
                    )}
                  </CollapsibleTrigger>
                  <CollapsibleContent className="pl-6 border-l ml-2">
                    {props.map(renderProperty)}
                  </CollapsibleContent>
                </Collapsible>
              ))}
            </div>
          </div>
        )}
      </div>
    </AccordionSection>
  )
}
```

This implements the CONTEXT.md decision: "Grouped collapsible list where properties are grouped together, showing which parent category(s) they were inherited from."
  </action>
  <verify>
File exists with correct export:
```bash
grep -n "export function PropertiesSection" frontend/src/components/entity/sections/PropertiesSection.tsx
```
  </verify>
  <done>PropertiesSection component created with direct/inherited grouping and provenance display</done>
</task>

<task type="auto">
  <name>Task 2: Implement CategoryDetail component</name>
  <files>frontend/src/components/entity/detail/CategoryDetail.tsx</files>
  <action>
Replace the placeholder `frontend/src/components/entity/detail/CategoryDetail.tsx` with full implementation:

```typescript
import { useEffect, useState, useCallback } from 'react'
import { useCategory } from '@/api/entitiesV2'
import { useAutoSave } from '@/hooks/useAutoSave'
import { useDetailStore } from '@/stores/detailStore'
import { EntityHeader } from '../sections/EntityHeader'
import { AccordionSection } from '../sections/AccordionSection'
import { PropertiesSection } from '../sections/PropertiesSection'
import { MembershipSection } from '../sections/MembershipSection'
import { EditableList } from '../form/EditableList'
import { Badge } from '@/components/ui/badge'
import { Skeleton } from '@/components/ui/skeleton'

interface CategoryDetailProps {
  entityKey: string
  draftId?: string
  isEditing: boolean
}

/**
 * Category detail view with:
 * - Header (name, label, description)
 * - Parents list with add/remove in edit mode
 * - Direct properties
 * - Inherited properties grouped by parent with provenance
 * - Module/bundle membership
 */
export function CategoryDetail({
  entityKey,
  draftId,
  isEditing,
}: CategoryDetailProps) {
  const { data: category, isLoading, error } = useCategory(entityKey, draftId)
  const openDetail = useDetailStore((s) => s.openDetail)
  const pushBreadcrumb = useDetailStore((s) => s.pushBreadcrumb)

  // Track original values for change detection
  const [originalValues, setOriginalValues] = useState<{
    label?: string
    description?: string
    parents?: string[]
  }>({})

  // Local editable state
  const [editedLabel, setEditedLabel] = useState('')
  const [editedDescription, setEditedDescription] = useState('')
  const [editedParents, setEditedParents] = useState<string[]>([])

  // Auto-save hook
  const { saveChange, isSaving } = useAutoSave({
    draftToken: draftId || '',
    entityType: 'category',
    entityKey,
    debounceMs: 500,
  })

  // Initialize state when category loads
  useEffect(() => {
    if (category) {
      setEditedLabel(category.label)
      setEditedDescription(category.description || '')
      setEditedParents(category.parents || [])

      // Store originals for comparison
      setOriginalValues({
        label: category.label,
        description: category.description || '',
        parents: category.parents || [],
      })

      // Add to breadcrumbs
      pushBreadcrumb(entityKey, 'category', category.label)
    }
  }, [category, entityKey, pushBreadcrumb])

  // Change handlers with auto-save
  const handleLabelChange = useCallback(
    (value: string) => {
      setEditedLabel(value)
      if (draftId) {
        saveChange([{ op: 'replace', path: '/label', value }])
      }
    },
    [draftId, saveChange]
  )

  const handleDescriptionChange = useCallback(
    (value: string) => {
      setEditedDescription(value)
      if (draftId) {
        saveChange([{ op: 'replace', path: '/description', value }])
      }
    },
    [draftId, saveChange]
  )

  const handleAddParent = useCallback(
    (parent: string) => {
      const newParents = [...editedParents, parent]
      setEditedParents(newParents)
      if (draftId) {
        saveChange([{ op: 'replace', path: '/parents', value: newParents }])
      }
    },
    [editedParents, draftId, saveChange]
  )

  const handleRemoveParent = useCallback(
    (parent: string) => {
      const newParents = editedParents.filter((p) => p !== parent)
      setEditedParents(newParents)
      if (draftId) {
        saveChange([{ op: 'replace', path: '/parents', value: newParents }])
      }
    },
    [editedParents, draftId, saveChange]
  )

  const handleRevertLabel = useCallback(() => {
    setEditedLabel(originalValues.label || '')
    if (draftId) {
      saveChange([{ op: 'replace', path: '/label', value: originalValues.label }])
    }
  }, [originalValues.label, draftId, saveChange])

  const handleRevertDescription = useCallback(() => {
    setEditedDescription(originalValues.description || '')
    if (draftId) {
      saveChange([
        { op: 'replace', path: '/description', value: originalValues.description },
      ])
    }
  }, [originalValues.description, draftId, saveChange])

  if (isLoading) {
    return (
      <div className="p-6 space-y-4">
        <Skeleton className="h-8 w-64" />
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-4 w-3/4" />
        <Skeleton className="h-32 w-full" />
      </div>
    )
  }

  if (error || !category) {
    return (
      <div className="p-6 text-center text-destructive">
        <p className="font-medium">Failed to load category</p>
        <p className="text-sm text-muted-foreground mt-1">
          {error instanceof Error ? error.message : 'Category not found'}
        </p>
      </div>
    )
  }

  return (
    <div className="p-6 space-y-6">
      {/* Saving indicator */}
      {isSaving && (
        <div className="fixed top-4 right-4 bg-primary text-primary-foreground px-3 py-1 rounded text-sm">
          Saving...
        </div>
      )}

      {/* Header */}
      <EntityHeader
        entityKey={entityKey}
        label={editedLabel}
        description={editedDescription}
        entityType="category"
        changeStatus={category.change_status}
        isEditing={isEditing}
        originalLabel={originalValues.label}
        originalDescription={originalValues.description}
        onLabelChange={handleLabelChange}
        onDescriptionChange={handleDescriptionChange}
        onRevertLabel={handleRevertLabel}
        onRevertDescription={handleRevertDescription}
      />

      {/* Parents section */}
      <AccordionSection
        id="parents"
        title="Parent Categories"
        count={editedParents.length}
      >
        <EditableList
          items={editedParents}
          onAdd={handleAddParent}
          onRemove={handleRemoveParent}
          isEditing={isEditing}
          placeholder="Add parent category..."
          emptyMessage="No parent categories (root category)"
          renderItem={(parent) => (
            <Badge
              variant="secondary"
              className="cursor-pointer hover:bg-secondary/80"
              onClick={() => openDetail(parent, 'category')}
            >
              {parent}
            </Badge>
          )}
        />
      </AccordionSection>

      {/* Properties section with inheritance */}
      <PropertiesSection
        properties={category.properties || []}
        isEditing={isEditing}
        onRemoveProperty={(propKey) => {
          // TODO: Implement property removal from category
          console.log('Remove property:', propKey)
        }}
      />

      {/* Module/Bundle membership - TODO: fetch from module_entity table */}
      <MembershipSection modules={[]} bundles={[]} />
    </div>
  )
}
```

This implements requirements:
- CAT-01: Header with name, label, description
- CAT-02: Parents list with add/remove in edit mode
- CAT-03: Direct properties section
- CAT-04: Inherited properties section grouped by parent with provenance
- CAT-05: Module/bundle membership display (placeholder, needs API)
- CAT-06: Edit icons appear in draft mode for adding/removing
  </action>
  <verify>
File exists and compiles:
```bash
grep -n "export function CategoryDetail" frontend/src/components/entity/detail/CategoryDetail.tsx
cd frontend && npm run build 2>&1 | head -20
```
  </verify>
  <done>CategoryDetail component implemented with full view/edit functionality for parents, properties, and inheritance</done>
</task>

</tasks>

<verification>
1. PropertiesSection exists: `ls frontend/src/components/entity/sections/PropertiesSection.tsx`
2. CategoryDetail exists: `ls frontend/src/components/entity/detail/CategoryDetail.tsx`
3. TypeScript compiles: `cd frontend && npm run build`
4. Category detail uses useCategory hook: `grep "useCategory" frontend/src/components/entity/detail/CategoryDetail.tsx`
5. Auto-save integrated: `grep "useAutoSave" frontend/src/components/entity/detail/CategoryDetail.tsx`
</verification>

<success_criteria>
- CategoryDetail shows header with entity key, label, description
- Parents section displays as clickable badges with navigation
- Edit mode enables add/remove on parents list
- Direct properties shown separately from inherited
- Inherited properties grouped by source category with depth info
- Auto-save triggers on field changes with 500ms debounce
- Visual change markers appear on modified fields
</success_criteria>

<output>
After completion, create `.planning/phases/13-entity-detail-pages/13-04-SUMMARY.md`
</output>
