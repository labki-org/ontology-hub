---
phase: 13-entity-detail-pages
plan: 05
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - frontend/src/components/entity/detail/PropertyDetail.tsx
  - frontend/src/components/entity/detail/SubobjectDetail.tsx
  - frontend/src/api/entitiesV2.ts
autonomous: true

must_haves:
  truths:
    - "Property page shows datatype and cardinality"
    - "Property page shows where-used list of categories"
    - "Subobject page shows required/optional properties"
    - "Subobject page shows where-used list"
    - "Edit mode allows modifying property/subobject attributes"
  artifacts:
    - path: "frontend/src/components/entity/detail/PropertyDetail.tsx"
      provides: "Property detail view with datatype, cardinality, where-used"
      exports: ["PropertyDetail"]
    - path: "frontend/src/components/entity/detail/SubobjectDetail.tsx"
      provides: "Subobject detail view with properties, where-used"
      exports: ["SubobjectDetail"]
  key_links:
    - from: "frontend/src/components/entity/detail/PropertyDetail.tsx"
      to: "frontend/src/api/entitiesV2.ts"
      via: "useProperty, usePropertyUsedBy hooks"
      pattern: "useProperty|usePropertyUsedBy"
---

<objective>
Implement Property and Subobject entity detail pages with view and edit modes.

Purpose: Properties and Subobjects are referenced by Categories. These detail pages show their configuration and where they are used across the ontology.

Output: PropertyDetail and SubobjectDetail components with full attribute display and where-used lists.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-entity-detail-pages/13-CONTEXT.md
@.planning/phases/13-entity-detail-pages/13-02-SUMMARY.md
@.planning/phases/13-entity-detail-pages/13-03-SUMMARY.md
@frontend/src/api/types.ts
@frontend/src/api/entitiesV2.ts
@backend/app/routers/entities_v2.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add usePropertyUsedBy hook</name>
  <files>frontend/src/api/entitiesV2.ts</files>
  <action>
Add a hook to `frontend/src/api/entitiesV2.ts` for fetching the where-used list:

```typescript
// Add this hook after the existing useProperty hook

export function usePropertyUsedBy(entityKey: string, draftId?: string) {
  return useQuery({
    queryKey: ['v2', 'property', entityKey, 'used-by', { draftId }],
    queryFn: async () => {
      const params = new URLSearchParams()
      if (draftId) params.set('draft_id', draftId)
      const queryString = params.toString()
      const endpoint = `/properties/${entityKey}/used-by${queryString ? `?${queryString}` : ''}`
      return apiFetch(endpoint, { v2: true }) as Promise<EntityWithStatus[]>
    },
    enabled: !!entityKey,
  })
}
```

This calls the backend endpoint `GET /properties/{entity_key}/used-by` which returns categories using this property.
  </action>
  <verify>
Hook exists in entitiesV2.ts:
```bash
grep -n "usePropertyUsedBy" frontend/src/api/entitiesV2.ts
```
  </verify>
  <done>usePropertyUsedBy hook added for fetching categories that use a property</done>
</task>

<task type="auto">
  <name>Task 2: Implement PropertyDetail component</name>
  <files>frontend/src/components/entity/detail/PropertyDetail.tsx</files>
  <action>
Replace placeholder `frontend/src/components/entity/detail/PropertyDetail.tsx`:

```typescript
import { useEffect, useState, useCallback } from 'react'
import { useProperty, usePropertyUsedBy } from '@/api/entitiesV2'
import { useAutoSave } from '@/hooks/useAutoSave'
import { useDetailStore } from '@/stores/detailStore'
import { EntityHeader } from '../sections/EntityHeader'
import { AccordionSection } from '../sections/AccordionSection'
import { WhereUsedSection } from '../sections/WhereUsedSection'
import { MembershipSection } from '../sections/MembershipSection'
import { EditableField } from '../form/EditableField'
import { Badge } from '@/components/ui/badge'
import { Skeleton } from '@/components/ui/skeleton'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import type { PropertyDetailV2 } from '@/api/types'

interface PropertyDetailProps {
  entityKey: string
  draftId?: string
  isEditing: boolean
}

const DATATYPES = ['text', 'number', 'boolean', 'date', 'url', 'page', 'file']
const CARDINALITIES = ['single', 'multiple']

/**
 * Property detail view with:
 * - Header (name, label, description)
 * - Datatype and cardinality
 * - Where-used list (categories using this property)
 * - Module/bundle membership
 */
export function PropertyDetail({
  entityKey,
  draftId,
  isEditing,
}: PropertyDetailProps) {
  const { data, isLoading, error } = useProperty(entityKey, draftId)
  const { data: usedBy, isLoading: usedByLoading } = usePropertyUsedBy(entityKey, draftId)
  const pushBreadcrumb = useDetailStore((s) => s.pushBreadcrumb)

  // Cast to PropertyDetailV2
  const property = data as PropertyDetailV2 | undefined

  // Track original values
  const [originalValues, setOriginalValues] = useState<{
    label?: string
    description?: string
    datatype?: string
    cardinality?: string
  }>({})

  // Local editable state
  const [editedLabel, setEditedLabel] = useState('')
  const [editedDescription, setEditedDescription] = useState('')
  const [editedDatatype, setEditedDatatype] = useState('text')
  const [editedCardinality, setEditedCardinality] = useState('single')

  // Auto-save hook
  const { saveChange, isSaving } = useAutoSave({
    draftToken: draftId || '',
    entityType: 'property',
    entityKey,
    debounceMs: 500,
  })

  // Initialize state when property loads
  useEffect(() => {
    if (property) {
      setEditedLabel(property.label)
      setEditedDescription(property.description || '')
      setEditedDatatype(property.datatype || 'text')
      setEditedCardinality(property.cardinality || 'single')

      setOriginalValues({
        label: property.label,
        description: property.description || '',
        datatype: property.datatype || 'text',
        cardinality: property.cardinality || 'single',
      })

      pushBreadcrumb(entityKey, 'property', property.label)
    }
  }, [property, entityKey, pushBreadcrumb])

  // Change handlers
  const handleLabelChange = useCallback(
    (value: string) => {
      setEditedLabel(value)
      if (draftId) saveChange([{ op: 'replace', path: '/label', value }])
    },
    [draftId, saveChange]
  )

  const handleDescriptionChange = useCallback(
    (value: string) => {
      setEditedDescription(value)
      if (draftId) saveChange([{ op: 'replace', path: '/description', value }])
    },
    [draftId, saveChange]
  )

  const handleDatatypeChange = useCallback(
    (value: string) => {
      setEditedDatatype(value)
      if (draftId) saveChange([{ op: 'replace', path: '/datatype', value }])
    },
    [draftId, saveChange]
  )

  const handleCardinalityChange = useCallback(
    (value: string) => {
      setEditedCardinality(value)
      if (draftId) saveChange([{ op: 'replace', path: '/cardinality', value }])
    },
    [draftId, saveChange]
  )

  if (isLoading) {
    return (
      <div className="p-6 space-y-4">
        <Skeleton className="h-8 w-64" />
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-32 w-full" />
      </div>
    )
  }

  if (error || !property) {
    return (
      <div className="p-6 text-center text-destructive">
        <p className="font-medium">Failed to load property</p>
        <p className="text-sm text-muted-foreground mt-1">
          {error instanceof Error ? error.message : 'Property not found'}
        </p>
      </div>
    )
  }

  // Convert usedBy to WhereUsedSection format
  const whereUsedItems = (usedBy || []).map((cat) => ({
    entityKey: cat.entity_key,
    entityType: 'category',
    label: cat.label,
  }))

  return (
    <div className="p-6 space-y-6">
      {isSaving && (
        <div className="fixed top-4 right-4 bg-primary text-primary-foreground px-3 py-1 rounded text-sm">
          Saving...
        </div>
      )}

      {/* Header */}
      <EntityHeader
        entityKey={entityKey}
        label={editedLabel}
        description={editedDescription}
        entityType="property"
        changeStatus={property.change_status}
        isEditing={isEditing}
        originalLabel={originalValues.label}
        originalDescription={originalValues.description}
        onLabelChange={handleLabelChange}
        onDescriptionChange={handleDescriptionChange}
      />

      {/* Datatype and Cardinality */}
      <AccordionSection id="attributes" title="Attributes">
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="text-sm font-medium text-muted-foreground mb-2 block">
              Datatype
            </label>
            {isEditing ? (
              <Select value={editedDatatype} onValueChange={handleDatatypeChange}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {DATATYPES.map((dt) => (
                    <SelectItem key={dt} value={dt}>
                      {dt}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            ) : (
              <Badge variant="secondary">{editedDatatype}</Badge>
            )}
          </div>

          <div>
            <label className="text-sm font-medium text-muted-foreground mb-2 block">
              Cardinality
            </label>
            {isEditing ? (
              <Select value={editedCardinality} onValueChange={handleCardinalityChange}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {CARDINALITIES.map((c) => (
                    <SelectItem key={c} value={c}>
                      {c}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            ) : (
              <Badge variant="outline">{editedCardinality}</Badge>
            )}
          </div>
        </div>
      </AccordionSection>

      {/* Where Used */}
      <WhereUsedSection
        items={whereUsedItems}
        title="Used By Categories"
      />

      {/* Module membership - TODO: needs API */}
      <MembershipSection modules={[]} bundles={[]} />
    </div>
  )
}
```

Note: The Select component from shadcn/ui needs to be installed. Add it if not present:
```bash
cd frontend && npx shadcn@latest add select --yes
```

This implements:
- PRP-01: Header with name, label, description, datatype, cardinality
- PRP-02: Where-used list showing categories
- PRP-03: Module/bundle membership (placeholder)
- PRP-04: Edit icons for modifying attributes in draft mode
  </action>
  <verify>
PropertyDetail exists and uses hooks:
```bash
grep -n "export function PropertyDetail" frontend/src/components/entity/detail/PropertyDetail.tsx
grep -n "useProperty" frontend/src/components/entity/detail/PropertyDetail.tsx
```
  </verify>
  <done>PropertyDetail component implemented with datatype, cardinality, and where-used list</done>
</task>

<task type="auto">
  <name>Task 3: Implement SubobjectDetail component</name>
  <files>frontend/src/components/entity/detail/SubobjectDetail.tsx</files>
  <action>
Replace placeholder `frontend/src/components/entity/detail/SubobjectDetail.tsx`:

```typescript
import { useEffect, useState, useCallback } from 'react'
import { useSubobject } from '@/api/entitiesV2'
import { useAutoSave } from '@/hooks/useAutoSave'
import { useDetailStore } from '@/stores/detailStore'
import { EntityHeader } from '../sections/EntityHeader'
import { AccordionSection } from '../sections/AccordionSection'
import { WhereUsedSection } from '../sections/WhereUsedSection'
import { MembershipSection } from '../sections/MembershipSection'
import { EditableList } from '../form/EditableList'
import { Badge } from '@/components/ui/badge'
import { Skeleton } from '@/components/ui/skeleton'
import type { SubobjectDetailV2 } from '@/api/types'

interface SubobjectDetailProps {
  entityKey: string
  draftId?: string
  isEditing: boolean
}

/**
 * Subobject detail view with:
 * - Header (name, label, description)
 * - Required/optional properties lists
 * - Where-used list
 * - Module/bundle membership
 */
export function SubobjectDetail({
  entityKey,
  draftId,
  isEditing,
}: SubobjectDetailProps) {
  const { data, isLoading, error } = useSubobject(entityKey, draftId)
  const openDetail = useDetailStore((s) => s.openDetail)
  const pushBreadcrumb = useDetailStore((s) => s.pushBreadcrumb)

  // Cast to SubobjectDetailV2
  const subobject = data as SubobjectDetailV2 | undefined

  // Track original values
  const [originalValues, setOriginalValues] = useState<{
    label?: string
    description?: string
  }>({})

  // Local editable state
  const [editedLabel, setEditedLabel] = useState('')
  const [editedDescription, setEditedDescription] = useState('')
  const [editedProperties, setEditedProperties] = useState<string[]>([])

  // Auto-save hook
  const { saveChange, isSaving } = useAutoSave({
    draftToken: draftId || '',
    entityType: 'subobject',
    entityKey,
    debounceMs: 500,
  })

  // Initialize state
  useEffect(() => {
    if (subobject) {
      setEditedLabel(subobject.label)
      setEditedDescription(subobject.description || '')
      setEditedProperties(subobject.properties || [])

      setOriginalValues({
        label: subobject.label,
        description: subobject.description || '',
      })

      pushBreadcrumb(entityKey, 'subobject', subobject.label)
    }
  }, [subobject, entityKey, pushBreadcrumb])

  // Change handlers
  const handleLabelChange = useCallback(
    (value: string) => {
      setEditedLabel(value)
      if (draftId) saveChange([{ op: 'replace', path: '/label', value }])
    },
    [draftId, saveChange]
  )

  const handleDescriptionChange = useCallback(
    (value: string) => {
      setEditedDescription(value)
      if (draftId) saveChange([{ op: 'replace', path: '/description', value }])
    },
    [draftId, saveChange]
  )

  const handleAddProperty = useCallback(
    (propKey: string) => {
      const newProps = [...editedProperties, propKey]
      setEditedProperties(newProps)
      if (draftId) saveChange([{ op: 'replace', path: '/properties', value: newProps }])
    },
    [editedProperties, draftId, saveChange]
  )

  const handleRemoveProperty = useCallback(
    (propKey: string) => {
      const newProps = editedProperties.filter((p) => p !== propKey)
      setEditedProperties(newProps)
      if (draftId) saveChange([{ op: 'replace', path: '/properties', value: newProps }])
    },
    [editedProperties, draftId, saveChange]
  )

  if (isLoading) {
    return (
      <div className="p-6 space-y-4">
        <Skeleton className="h-8 w-64" />
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-32 w-full" />
      </div>
    )
  }

  if (error || !subobject) {
    return (
      <div className="p-6 text-center text-destructive">
        <p className="font-medium">Failed to load subobject</p>
        <p className="text-sm text-muted-foreground mt-1">
          {error instanceof Error ? error.message : 'Subobject not found'}
        </p>
      </div>
    )
  }

  // TODO: Where-used would need a backend endpoint
  const whereUsedItems: Array<{ entityKey: string; entityType: string; label?: string }> = []

  return (
    <div className="p-6 space-y-6">
      {isSaving && (
        <div className="fixed top-4 right-4 bg-primary text-primary-foreground px-3 py-1 rounded text-sm">
          Saving...
        </div>
      )}

      {/* Header */}
      <EntityHeader
        entityKey={entityKey}
        label={editedLabel}
        description={editedDescription}
        entityType="subobject"
        changeStatus={subobject.change_status}
        isEditing={isEditing}
        originalLabel={originalValues.label}
        originalDescription={originalValues.description}
        onLabelChange={handleLabelChange}
        onDescriptionChange={handleDescriptionChange}
      />

      {/* Properties */}
      <AccordionSection
        id="properties"
        title="Properties"
        count={editedProperties.length}
      >
        <EditableList
          items={editedProperties}
          onAdd={handleAddProperty}
          onRemove={handleRemoveProperty}
          isEditing={isEditing}
          placeholder="Add property..."
          emptyMessage="No properties defined"
          renderItem={(propKey) => (
            <Badge
              variant="secondary"
              className="cursor-pointer hover:bg-secondary/80"
              onClick={() => openDetail(propKey, 'property')}
            >
              {propKey}
            </Badge>
          )}
        />
      </AccordionSection>

      {/* Where Used - TODO: needs backend endpoint */}
      <WhereUsedSection
        items={whereUsedItems}
        title="Used By"
      />

      {/* Module membership - TODO: needs API */}
      <MembershipSection modules={[]} bundles={[]} />
    </div>
  )
}
```

This implements:
- SUB-01: Header with name, label, description
- SUB-02: Properties list (simplified - full required/optional separation needs backend enhancement)
- SUB-03: Where-used list (placeholder - needs backend endpoint)
- SUB-04: Edit icons in draft mode
  </action>
  <verify>
SubobjectDetail exists:
```bash
grep -n "export function SubobjectDetail" frontend/src/components/entity/detail/SubobjectDetail.tsx
cd frontend && npm run build 2>&1 | head -20
```
  </verify>
  <done>SubobjectDetail component implemented with properties list and edit mode</done>
</task>

</tasks>

<verification>
1. usePropertyUsedBy hook exists: `grep "usePropertyUsedBy" frontend/src/api/entitiesV2.ts`
2. PropertyDetail exists: `ls frontend/src/components/entity/detail/PropertyDetail.tsx`
3. SubobjectDetail exists: `ls frontend/src/components/entity/detail/SubobjectDetail.tsx`
4. Select component installed: `ls frontend/src/components/ui/select.tsx`
5. TypeScript compiles: `cd frontend && npm run build`
</verification>

<success_criteria>
- PropertyDetail shows label, description, datatype, cardinality
- Datatype/cardinality editable via Select in edit mode
- PropertyDetail shows where-used list of categories
- SubobjectDetail shows label, description, properties list
- Properties editable with add/remove in edit mode
- Auto-save triggers on changes
</success_criteria>

<output>
After completion, create `.planning/phases/13-entity-detail-pages/13-05-SUMMARY.md`
</output>
