---
phase: 13-entity-detail-pages
plan: 09
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/entity/detail/ModuleDetail.tsx
  - frontend/src/components/entity/detail/BundleDetail.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Module page shows edit icons in draft mode"
    - "Module edit mode allows adding/removing members with auto-save"
    - "Bundle page shows edit icons in draft mode"
    - "Bundle edit mode allows adding/removing modules with auto-save"
  artifacts:
    - path: "frontend/src/components/entity/detail/ModuleDetail.tsx"
      provides: "Module detail with full edit mode"
      contains: "useAutoSave"
    - path: "frontend/src/components/entity/detail/BundleDetail.tsx"
      provides: "Bundle detail with full edit mode"
      contains: "useAutoSave"
  key_links:
    - from: "ModuleDetail.tsx"
      to: "@/hooks/useAutoSave"
      via: "import and instantiation"
      pattern: "useAutoSave\\("
    - from: "BundleDetail.tsx"
      to: "@/hooks/useAutoSave"
      via: "import and instantiation"
      pattern: "useAutoSave\\("
    - from: "ModuleDetail.tsx"
      to: "EditableList"
      via: "component usage for member editing"
      pattern: "<EditableList"
    - from: "BundleDetail.tsx"
      to: "EditableList"
      via: "component usage for module editing"
      pattern: "<EditableList"
---

<objective>
Add edit mode functionality to ModuleDetail and BundleDetail components to close verification gaps.

Purpose: The original 13-06 plan specified full edit mode with useAutoSave, EditableList, and handlers. The current implementations are view-only stubs. This gap closure adds the missing edit functionality following the established patterns from CategoryDetail.tsx and SubobjectDetail.tsx.

Output: ModuleDetail and BundleDetail with functional add/remove capabilities that auto-save to draft API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-entity-detail-pages/13-VERIFICATION.md

# Working patterns to follow
@frontend/src/components/entity/detail/CategoryDetail.tsx
@frontend/src/components/entity/detail/SubobjectDetail.tsx

# Components and hooks to use
@frontend/src/hooks/useAutoSave.ts
@frontend/src/components/entity/form/EditableList.tsx

# Current view-only implementations to upgrade
@frontend/src/components/entity/detail/ModuleDetail.tsx
@frontend/src/components/entity/detail/BundleDetail.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edit mode to ModuleDetail</name>
  <files>frontend/src/components/entity/detail/ModuleDetail.tsx</files>
  <action>
Rewrite ModuleDetail.tsx to add edit mode functionality. Follow the pattern from CategoryDetail.tsx.

**Required changes:**

1. **Add imports** at the top:
```typescript
import { useEffect, useState, useCallback } from 'react'
import { useAutoSave } from '@/hooks/useAutoSave'
import { useDetailStore } from '@/stores/detailStore'
import { EditableList } from '../form/EditableList'
import { EntityHeader } from '../sections/EntityHeader'
import { Skeleton } from '@/components/ui/skeleton'
```

2. **Add useAutoSave hook** after the useModule call:
```typescript
const { saveChange, isSaving } = useAutoSave({
  draftToken: draftId || '',
  entityType: 'module',
  entityKey,
  debounceMs: 500,
})
```

3. **Add state for edited values**:
```typescript
const [originalValues, setOriginalValues] = useState<{ label?: string }>({})
const [editedLabel, setEditedLabel] = useState('')
const [editedEntities, setEditedEntities] = useState<Record<string, string[]>>({})
```

4. **Add useEffect to initialize state** when module loads:
```typescript
useEffect(() => {
  if (moduleDetail) {
    setEditedLabel(moduleDetail.label)
    setEditedEntities(moduleDetail.entities || {})
    setOriginalValues({ label: moduleDetail.label })
    pushBreadcrumb(entityKey, 'module', moduleDetail.label)
  }
}, [moduleDetail, entityKey, pushBreadcrumb])
```

5. **Add handler callbacks**:
```typescript
const handleLabelChange = useCallback((value: string) => {
  setEditedLabel(value)
  if (draftId) saveChange([{ op: 'replace', path: '/label', value }])
}, [draftId, saveChange])

const handleAddEntity = useCallback((entityType: string, entKey: string) => {
  const newEntities = { ...editedEntities }
  if (!newEntities[entityType]) newEntities[entityType] = []
  newEntities[entityType] = [...newEntities[entityType], entKey]
  setEditedEntities(newEntities)
  if (draftId) saveChange([{ op: 'replace', path: '/entities', value: newEntities }])
}, [editedEntities, draftId, saveChange])

const handleRemoveEntity = useCallback((entityType: string, entKey: string) => {
  const newEntities = { ...editedEntities }
  newEntities[entityType] = (newEntities[entityType] || []).filter((k) => k !== entKey)
  setEditedEntities(newEntities)
  if (draftId) saveChange([{ op: 'replace', path: '/entities', value: newEntities }])
}, [editedEntities, draftId, saveChange])
```

6. **Add isSaving indicator** at top of rendered content (inside the return):
```typescript
{isSaving && (
  <div className="fixed top-4 right-4 bg-primary text-primary-foreground px-3 py-1 rounded text-sm z-50">
    Saving...
  </div>
)}
```

7. **Replace static member display** with EditableList for each entity type in the Direct Members section. Instead of the current inline `<ul>` with hardcoded buttons, use:
```typescript
<EditableList
  items={editedEntities[entityType] || []}
  onAdd={(key) => handleAddEntity(entityType, key)}
  onRemove={(key) => handleRemoveEntity(entityType, key)}
  isEditing={isEditing}
  placeholder={`Add ${entityType}...`}
  emptyMessage={`No ${entityType}s in module`}
  renderItem={(key) => (
    <Badge
      variant="secondary"
      className="cursor-pointer hover:bg-secondary/80"
      onClick={() => openDetail(key, entityType as EntityType)}
    >
      {key}
    </Badge>
  )}
/>
```

8. **Use EntityHeader component** with edit props:
```typescript
<EntityHeader
  entityKey={entityKey}
  label={editedLabel}
  description={null}
  entityType="module"
  changeStatus={moduleDetail.change_status}
  isEditing={isEditing}
  originalLabel={originalValues.label}
  onLabelChange={handleLabelChange}
/>
```

**Key implementation details:**
- Use `editedEntities` state instead of `moduleDetail.entities` for display so edits are reflected immediately
- Get `openDetail` and `pushBreadcrumb` from `useDetailStore`
- Keep the existing loading/error handling but use Skeleton component for consistency
- The entities structure is `Record<string, string[]>` mapping entity type to keys
- Entity types to iterate: 'category', 'property', 'subobject', 'template'
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/frontend
grep -n "useAutoSave" src/components/entity/detail/ModuleDetail.tsx
grep -n "EditableList" src/components/entity/detail/ModuleDetail.tsx
grep -n "handleAddEntity" src/components/entity/detail/ModuleDetail.tsx
grep -n "isSaving" src/components/entity/detail/ModuleDetail.tsx
```
  </verify>
  <done>ModuleDetail has useAutoSave hook, EditableList components, add/remove handlers, and isSaving indicator</done>
</task>

<task type="auto">
  <name>Task 2: Add edit mode to BundleDetail</name>
  <files>frontend/src/components/entity/detail/BundleDetail.tsx</files>
  <action>
Rewrite BundleDetail.tsx to add edit mode functionality. Follow the same pattern as ModuleDetail and CategoryDetail.

**Required changes:**

1. **Add imports** at the top:
```typescript
import { useEffect, useState, useCallback } from 'react'
import { useAutoSave } from '@/hooks/useAutoSave'
import { useDetailStore } from '@/stores/detailStore'
import { EditableList } from '../form/EditableList'
import { EntityHeader } from '../sections/EntityHeader'
import { Skeleton } from '@/components/ui/skeleton'
```

2. **Add useAutoSave hook** after the useBundle call:
```typescript
const { saveChange, isSaving } = useAutoSave({
  draftToken: draftId || '',
  entityType: 'bundle',
  entityKey,
  debounceMs: 500,
})
```

3. **Add state for edited values**:
```typescript
const [originalValues, setOriginalValues] = useState<{ label?: string }>({})
const [editedLabel, setEditedLabel] = useState('')
const [editedModules, setEditedModules] = useState<string[]>([])
```

4. **Add useEffect to initialize state** when bundle loads:
```typescript
useEffect(() => {
  if (bundleDetail) {
    setEditedLabel(bundleDetail.label)
    setEditedModules(bundleDetail.modules || [])
    setOriginalValues({ label: bundleDetail.label })
    pushBreadcrumb(entityKey, 'bundle', bundleDetail.label)
  }
}, [bundleDetail, entityKey, pushBreadcrumb])
```

5. **Add handler callbacks**:
```typescript
const handleLabelChange = useCallback((value: string) => {
  setEditedLabel(value)
  if (draftId) saveChange([{ op: 'replace', path: '/label', value }])
}, [draftId, saveChange])

const handleAddModule = useCallback((moduleKey: string) => {
  const newModules = [...editedModules, moduleKey]
  setEditedModules(newModules)
  if (draftId) saveChange([{ op: 'replace', path: '/modules', value: newModules }])
}, [editedModules, draftId, saveChange])

const handleRemoveModule = useCallback((moduleKey: string) => {
  const newModules = editedModules.filter((m) => m !== moduleKey)
  setEditedModules(newModules)
  if (draftId) saveChange([{ op: 'replace', path: '/modules', value: newModules }])
}, [editedModules, draftId, saveChange])
```

6. **Add isSaving indicator** at top of rendered content:
```typescript
{isSaving && (
  <div className="fixed top-4 right-4 bg-primary text-primary-foreground px-3 py-1 rounded text-sm z-50">
    Saving...
  </div>
)}
```

7. **Replace static module display** in the Modules section with EditableList:
```typescript
<EditableList
  items={editedModules}
  onAdd={handleAddModule}
  onRemove={handleRemoveModule}
  isEditing={isEditing}
  placeholder="Add module..."
  emptyMessage="No modules in bundle"
  renderItem={(moduleKey) => (
    <Badge
      variant="secondary"
      className="cursor-pointer hover:bg-secondary/80"
      onClick={() => openDetail(moduleKey, 'module')}
    >
      {moduleKey}
    </Badge>
  )}
/>
```

8. **Use EntityHeader component** with edit props:
```typescript
<EntityHeader
  entityKey={entityKey}
  label={editedLabel}
  description={null}
  entityType="bundle"
  changeStatus={bundleDetail.change_status}
  isEditing={isEditing}
  originalLabel={originalValues.label}
  onLabelChange={handleLabelChange}
/>
```

**Key implementation details:**
- Use `editedModules` state instead of `bundleDetail.modules` for display
- Get `openDetail` and `pushBreadcrumb` from `useDetailStore`
- Keep the computed closure section read-only (closure is computed server-side)
- The modules structure is `string[]` (simpler than Module's `Record<string, string[]>`)
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/frontend
grep -n "useAutoSave" src/components/entity/detail/BundleDetail.tsx
grep -n "EditableList" src/components/entity/detail/BundleDetail.tsx
grep -n "handleAddModule" src/components/entity/detail/BundleDetail.tsx
grep -n "isSaving" src/components/entity/detail/BundleDetail.tsx
```
  </verify>
  <done>BundleDetail has useAutoSave hook, EditableList component, add/remove handlers, and isSaving indicator</done>
</task>

<task type="auto">
  <name>Task 3: Verify TypeScript compilation</name>
  <files>frontend/src/components/entity/detail/ModuleDetail.tsx, frontend/src/components/entity/detail/BundleDetail.tsx</files>
  <action>
Run TypeScript compilation to verify no type errors in the updated components.

```bash
cd /home/daharoni/dev/ontology-hub/frontend
npm run build
```

If there are type errors:
- Check that all imports are correct
- Ensure EntityType is imported if needed for the openDetail call
- Verify useDetailStore exports openDetail and pushBreadcrumb
- Check that moduleDetail/bundleDetail type assertions are correct

Common fixes if needed:
- Import EntityType: `import type { EntityType } from '@/api/types'`
- Cast entity type string: `entityType as EntityType`
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/frontend && npm run build 2>&1 | tail -20
```
  </verify>
  <done>TypeScript compiles without errors for both ModuleDetail and BundleDetail</done>
</task>

</tasks>

<verification>
1. ModuleDetail has useAutoSave: `grep "useAutoSave" frontend/src/components/entity/detail/ModuleDetail.tsx`
2. ModuleDetail has EditableList: `grep "EditableList" frontend/src/components/entity/detail/ModuleDetail.tsx`
3. ModuleDetail has handlers: `grep "handleAddEntity\|handleRemoveEntity" frontend/src/components/entity/detail/ModuleDetail.tsx`
4. BundleDetail has useAutoSave: `grep "useAutoSave" frontend/src/components/entity/detail/BundleDetail.tsx`
5. BundleDetail has EditableList: `grep "EditableList" frontend/src/components/entity/detail/BundleDetail.tsx`
6. BundleDetail has handlers: `grep "handleAddModule\|handleRemoveModule" frontend/src/components/entity/detail/BundleDetail.tsx`
7. Build succeeds: `cd frontend && npm run build`
</verification>

<success_criteria>
- ModuleDetail.tsx contains useAutoSave hook instantiation with entityType='module'
- ModuleDetail.tsx contains handleAddEntity and handleRemoveEntity callbacks that call saveChange
- ModuleDetail.tsx uses EditableList for each entity type (categories, properties, subobjects, templates)
- ModuleDetail.tsx shows isSaving indicator when auto-save is in progress
- BundleDetail.tsx contains useAutoSave hook instantiation with entityType='bundle'
- BundleDetail.tsx contains handleAddModule and handleRemoveModule callbacks that call saveChange
- BundleDetail.tsx uses EditableList for modules list
- BundleDetail.tsx shows isSaving indicator when auto-save is in progress
- TypeScript compilation passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-entity-detail-pages/13-09-SUMMARY.md`
</output>
