---
phase: 03-entity-browsing
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/routers/entities.py
  - backend/tests/test_entities_api.py
  - frontend/src/api/types.ts
  - frontend/src/api/entities.ts
  - frontend/src/components/entity/EntityDetail.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Entity detail pages show which modules contain the entity"
    - "Module membership is retrieved via dedicated API endpoint"
    - "Module badges are clickable (future-ready for Phase 4 module pages)"
  artifacts:
    - path: "backend/app/routers/entities.py"
      provides: "GET /entities/{type}/{id}/modules endpoint"
      contains: "def get_entity_modules"
    - path: "frontend/src/api/entities.ts"
      provides: "useEntityModules hook"
      exports: ["useEntityModules"]
    - path: "frontend/src/components/entity/EntityDetail.tsx"
      provides: "Module badges display"
      contains: "useEntityModules"
  key_links:
    - from: "EntityDetail.tsx"
      to: "/api/v1/entities/{type}/{id}/modules"
      via: "useEntityModules hook"
      pattern: "useEntityModules\\(entityType, entity\\.entity_id\\)"
---

<objective>
Add module membership display to entity detail pages.

Purpose: Complete BRWS-05 requirement - "Entity pages show ID, label, description, module membership, and schema definition." Currently missing module membership.

Output: Entity detail pages show module badges, backed by new API endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Gap source
@.planning/phases/03-entity-browsing/03-VERIFICATION.md

# Existing implementation to extend
@backend/app/routers/entities.py
@backend/app/models/module.py
@frontend/src/api/entities.ts
@frontend/src/api/types.ts
@frontend/src/components/entity/EntityDetail.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend endpoint for entity modules</name>
  <files>
    backend/app/routers/entities.py
    backend/tests/test_entities_api.py
  </files>
  <action>
Add GET /entities/{entity_type}/{entity_id}/modules endpoint to entities.py.

Implementation:
1. Import Module and ModulePublic from app.models.module
2. Add new endpoint after the existing get_used_by endpoint:
   - Route: @router.get("/{entity_type}/{entity_id}/modules", response_model=list[ModulePublic])
   - Rate limit: RATE_LIMITS["entity_read"] (200/minute)
   - Query logic:
     - For categories: Find modules where entity_id is in category_ids array
     - For properties/subobjects: Find modules containing categories that use this entity
       (This requires a join: get categories from used-by, then get modules containing those categories)
   - Use cast to String and contains for JSONB array search (same pattern as used-by endpoint)
   - Return list of ModulePublic

Simplified approach for properties/subobjects:
- First query: Get category entity_ids that use this property/subobject (reuse used-by logic)
- Second query: Find modules where any of those category_ids are in module.category_ids

Add tests in test_entities_api.py:
- test_get_entity_modules_category: Category returns modules containing it
- test_get_entity_modules_property: Property returns modules via category membership
- test_get_entity_modules_not_found: Returns 404 for non-existent entity
- test_get_entity_modules_empty: Returns empty list when entity in no modules
  </action>
  <verify>
Run: docker compose exec backend pytest tests/test_entities_api.py -k "modules" -v
Expected: All new module-related tests pass
  </verify>
  <done>
GET /entities/{type}/{id}/modules endpoint returns modules containing the entity.
Tests verify: category direct membership, property indirect membership, 404 handling, empty list.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add frontend hook and display module badges</name>
  <files>
    frontend/src/api/types.ts
    frontend/src/api/entities.ts
    frontend/src/components/entity/EntityDetail.tsx
  </files>
  <action>
1. In types.ts, add ModulePublic interface:
   ```typescript
   export interface ModulePublic {
     id: string
     module_id: string
     label: string
     description: string | null
     category_ids: string[]
     dependencies: string[]
     commit_sha: string | null
     created_at: string
     updated_at: string
   }
   ```

2. In entities.ts, add fetch function and hook:
   ```typescript
   async function fetchEntityModules(
     entityType: EntityType,
     entityId: string
   ): Promise<ModulePublic[]> {
     return apiFetch(`/entities/${entityType}/${entityId}/modules`)
   }

   export function useEntityModules(entityType: EntityType, entityId: string) {
     return useQuery({
       queryKey: ['entity-modules', entityType, entityId],
       queryFn: () => fetchEntityModules(entityType, entityId),
       enabled: !!entityType && !!entityId,
     })
   }
   ```
   Add ModulePublic to the import from './types'

3. In EntityDetail.tsx:
   - Import useEntityModules from '@/api/entities'
   - Add entityType prop to EntityDetailProps (needed to call hook)
   - Call useEntityModules(entityType, entity.entity_id)
   - Add module badges section after description, before footer:
   ```tsx
   {modules && modules.length > 0 && (
     <CardContent className="pt-0">
       <div className="flex flex-wrap gap-2">
         <span className="text-sm text-muted-foreground">Modules:</span>
         {modules.map((module) => (
           <Badge key={module.id} variant="secondary">
             {module.label}
           </Badge>
         ))}
       </div>
     </CardContent>
   )}
   ```
   - Handle loading state (show skeleton or nothing while loading)
   - Use Badge component (already imported)

4. Update all usages of EntityDetail to pass entityType prop:
   - CategoryPage.tsx: entityType="category"
   - PropertyPage.tsx: entityType="property"
   - SubobjectPage.tsx: entityType="subobject"
  </action>
  <verify>
Run: docker compose exec frontend npm run build
Expected: Build succeeds without type errors

Manual check: Navigate to any entity page, confirm module badges appear (or nothing if entity not in any modules)
  </verify>
  <done>
EntityDetail component displays module badges for entities.
useEntityModules hook fetches module membership from API.
All entity pages pass entityType prop to EntityDetail.
  </done>
</task>

</tasks>

<verification>
1. Backend endpoint works:
   ```bash
   docker compose exec backend pytest tests/test_entities_api.py -k "modules" -v
   ```

2. Frontend builds:
   ```bash
   docker compose exec frontend npm run build
   ```

3. End-to-end manual check:
   - Navigate to a category that exists in a module
   - Verify module badge(s) appear on the detail page
   - Navigate to a property used by categories in modules
   - Verify module badge(s) appear
</verification>

<success_criteria>
- GET /entities/{type}/{id}/modules returns correct modules
- EntityDetail shows module badges when entity belongs to modules
- EntityDetail shows nothing (no error) when entity in no modules
- All existing tests still pass
- BRWS-05 requirement fully satisfied: ID, label, description, module membership, schema definition all displayed
</success_criteria>

<output>
After completion, create `.planning/phases/03-entity-browsing/03-04-SUMMARY.md`
</output>
