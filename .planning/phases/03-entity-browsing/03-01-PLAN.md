---
phase: 03-entity-browsing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/vite.config.ts
  - frontend/tsconfig.json
  - frontend/tailwind.config.ts
  - frontend/src/main.tsx
  - frontend/src/App.tsx
  - frontend/src/index.css
  - frontend/src/lib/utils.ts
  - frontend/src/api/client.ts
  - frontend/src/api/entities.ts
  - frontend/src/api/types.ts
  - frontend/src/components/layout/Sidebar.tsx
  - frontend/src/components/layout/MainLayout.tsx
  - frontend/src/components/entity/EntityDetail.tsx
  - frontend/src/components/entity/SchemaTable.tsx
  - frontend/src/components/entity/PropertyList.tsx
  - frontend/src/pages/HomePage.tsx
  - frontend/src/pages/CategoryPage.tsx
  - frontend/src/pages/PropertyPage.tsx
  - frontend/src/pages/SubobjectPage.tsx
  - frontend/components.json
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "User can view detail page for any category showing ID, label, description, properties, subobjects"
    - "User can view detail page for any property showing ID, label, description, datatype, cardinality"
    - "User can view detail page for any subobject showing ID, label, description, properties"
    - "User can navigate between entities using sidebar tree browser"
    - "Entity pages display parsed schema as structured table, not raw JSON"
  artifacts:
    - path: "frontend/package.json"
      provides: "React project dependencies"
      contains: "react"
    - path: "frontend/src/App.tsx"
      provides: "Router configuration"
      contains: "RouterProvider"
    - path: "frontend/src/pages/CategoryPage.tsx"
      provides: "Category detail page"
      min_lines: 30
    - path: "frontend/src/pages/PropertyPage.tsx"
      provides: "Property detail page"
      min_lines: 20
    - path: "frontend/src/pages/SubobjectPage.tsx"
      provides: "Subobject detail page"
      min_lines: 20
    - path: "frontend/src/components/layout/Sidebar.tsx"
      provides: "Navigation sidebar with entity tree"
      min_lines: 40
  key_links:
    - from: "frontend/src/pages/CategoryPage.tsx"
      to: "/api/v1/entities/category/{id}"
      via: "TanStack Query useEntity hook"
      pattern: "useEntity.*category"
    - from: "frontend/src/components/layout/Sidebar.tsx"
      to: "/api/v1/entities/{type}"
      via: "TanStack Query for entity lists"
      pattern: "useEntities"
---

<objective>
Set up React frontend with Vite, establish layout with sidebar navigation, and create entity detail pages for categories, properties, and subobjects.

Purpose: This plan creates the frontend foundation and core browsing experience. Users need to view entity details to understand the ontology structure before searching or exploring relationships.

Output: Working React app with entity detail pages accessible via routes like /category/Person, /property/has_name, /subobject/Address
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-entity-browsing/03-CONTEXT.md
@.planning/phases/03-entity-browsing/03-RESEARCH.md

# Existing API to consume
@backend/app/routers/entities.py
@backend/app/schemas/entity.py
@backend/app/models/entity.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: React App Scaffolding with Vite + TanStack Query + shadcn/ui</name>
  <files>
    frontend/package.json
    frontend/vite.config.ts
    frontend/tsconfig.json
    frontend/tailwind.config.ts
    frontend/src/main.tsx
    frontend/src/App.tsx
    frontend/src/index.css
    frontend/src/lib/utils.ts
    frontend/components.json
    frontend/index.html
    docker-compose.yml
  </files>
  <action>
    Create React frontend in `frontend/` directory:

    1. Initialize Vite project:
       ```bash
       npm create vite@latest frontend -- --template react-ts
       cd frontend
       ```

    2. Install dependencies:
       ```bash
       npm install @tanstack/react-query react-router-dom lucide-react clsx tailwind-merge
       npm install -D tailwindcss @tailwindcss/vite
       ```

    3. Initialize shadcn/ui:
       ```bash
       npx shadcn@latest init
       ```
       - Style: New York
       - Base color: Neutral
       - CSS variables: yes

    4. Add shadcn components needed:
       ```bash
       npx shadcn@latest add card button collapsible badge skeleton
       ```

    5. Configure vite.config.ts:
       - Add tailwindcss plugin
       - Set up proxy for /api to backend at localhost:8080
       - Configure path aliases (@/ -> src/)

    6. Configure main.tsx:
       - QueryClientProvider wrapping app
       - QueryClient with staleTime: 5min, gcTime: 30min
       - RouterProvider with router

    7. Configure App.tsx:
       - React Router with routes:
         - / -> HomePage
         - /category/:entityId -> CategoryPage
         - /property/:entityId -> PropertyPage
         - /subobject/:entityId -> SubobjectPage

    8. Update docker-compose.yml:
       - Add frontend service
       - Node 20 alpine image
       - Mount frontend/ directory
       - Port 5173:5173
       - Command: npm run dev -- --host
       - Depends on backend

    CRITICAL: Use @xyflow/react package name (not reactflow) - will be installed in Plan 03-03
  </action>
  <verify>
    ```bash
    cd /home/daharoni/dev/ontology-hub/frontend && npm run build
    ```
    Build completes without errors.
  </verify>
  <done>
    - Vite React app builds successfully
    - TanStack Query provider configured
    - React Router routes defined
    - shadcn/ui components available
    - Docker Compose updated with frontend service
  </done>
</task>

<task type="auto">
  <name>Task 2: API Client and Entity Hooks</name>
  <files>
    frontend/src/api/client.ts
    frontend/src/api/entities.ts
    frontend/src/api/types.ts
  </files>
  <action>
    Create API layer for entity data fetching:

    1. frontend/src/api/types.ts - TypeScript types matching backend schemas:
       ```typescript
       export type EntityType = 'category' | 'property' | 'subobject';

       export interface EntityPublic {
         id: string;           // UUID
         entity_id: string;    // Schema ID like "Person"
         entity_type: EntityType;
         label: string;
         description: string | null;
         schema_definition: Record<string, unknown>;
         commit_sha: string | null;
         created_at: string;
         updated_at: string;
       }

       export interface EntityListResponse {
         items: EntityPublic[];
         next_cursor: string | null;
         has_next: boolean;
       }

       export interface EntityOverviewResponse {
         types: { entity_type: string; count: number }[];
         total: number;
       }
       ```

    2. frontend/src/api/client.ts - Fetch wrapper:
       - Base URL from import.meta.env.VITE_API_URL or '/api/v1'
       - Generic fetch function with error handling
       - Throw on non-ok responses

    3. frontend/src/api/entities.ts - TanStack Query hooks:
       - useEntityOverview() - GET /entities
       - useEntities(type, cursor?, limit?) - GET /entities/{type}
       - useEntity(type, entityId) - GET /entities/{type}/{id}
       - useAllEntitiesByType() - Fetches all three types for sidebar
       - All hooks use queryKey patterns: ['entity', type, id] or ['entities', type]
       - Enable only when params are defined
  </action>
  <verify>
    TypeScript compiles without errors:
    ```bash
    cd /home/daharoni/dev/ontology-hub/frontend && npx tsc --noEmit
    ```
  </verify>
  <done>
    - API types match backend EntityPublic schema
    - TanStack Query hooks for all entity endpoints
    - Proper query key patterns for caching
  </done>
</task>

<task type="auto">
  <name>Task 3: Layout Components and Entity Detail Pages</name>
  <files>
    frontend/src/components/layout/Sidebar.tsx
    frontend/src/components/layout/MainLayout.tsx
    frontend/src/components/entity/EntityDetail.tsx
    frontend/src/components/entity/SchemaTable.tsx
    frontend/src/components/entity/PropertyList.tsx
    frontend/src/pages/HomePage.tsx
    frontend/src/pages/CategoryPage.tsx
    frontend/src/pages/PropertyPage.tsx
    frontend/src/pages/SubobjectPage.tsx
  </files>
  <action>
    Create layout and entity page components:

    1. MainLayout.tsx:
       - Sidebar on left (w-64, fixed or sticky)
       - Main content area with padding
       - Responsive: sidebar collapses on mobile (future enhancement OK to skip)

    2. Sidebar.tsx:
       - Collapsible sections for each entity type (Categories, Properties, Subobjects)
       - Use shadcn Collapsible component
       - Fetch entity lists using useAllEntitiesByType hook
       - Each entity links to its detail page
       - Loading skeleton while fetching
       - Show entity count badge per type

    3. EntityDetail.tsx - Shared detail component:
       - Header: label as h1, entity_id as subtitle, description
       - Badge showing entity_type
       - commit_sha and updated_at in footer

    4. SchemaTable.tsx - Structured schema display:
       - Parse schema_definition into rows
       - For categories: show parent, properties array, subobjects array
       - For properties: show datatype, cardinality, allowed_values if present
       - For subobjects: show properties array
       - Use shadcn Table or Card components
       - NO raw JSON display

    5. PropertyList.tsx - For category pages:
       - Display properties and subobjects
       - Each item is a clickable link to property/subobject page
       - Show "declared" badge (inherited indicators added in Plan 03-03)

    6. HomePage.tsx:
       - Welcome message
       - Entity overview counts from useEntityOverview
       - Quick links to browse each type

    7. CategoryPage.tsx:
       - useParams to get entityId
       - useEntity('category', entityId) to fetch
       - EntityDetail component for header
       - PropertyList for properties/subobjects
       - SchemaTable for full schema view
       - Loading/error states

    8. PropertyPage.tsx:
       - Similar structure to CategoryPage
       - Show datatype, cardinality prominently
       - Show allowed_values if present
       - Used-by section placeholder (implemented in Plan 03-03)

    9. SubobjectPage.tsx:
       - Similar structure
       - Show properties list
       - Used-by section placeholder (implemented in Plan 03-03)

    Use from CONTEXT.md decisions:
    - Sidebar + main content structure
    - Parsed table view showing fields, types, constraints (not raw JSON)
    - Visual indicators for properties/subobjects on category pages
  </action>
  <verify>
    Start frontend and verify pages render:
    ```bash
    cd /home/daharoni/dev/ontology-hub && docker compose up -d
    # Wait for services
    sleep 5
    curl -s http://localhost:5173/ | grep -q "html"
    ```
  </verify>
  <done>
    - Sidebar shows entity tree with collapsible sections
    - Category page shows properties and subobjects as clickable links
    - Property page shows datatype, cardinality, description
    - Subobject page shows properties list
    - All pages show structured schema table (not raw JSON)
    - Navigation between pages works via sidebar and links
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build passes: `cd frontend && npm run build`
2. Docker Compose starts frontend: `docker compose up frontend -d`
3. Navigate to http://localhost:5173/ - see home page with entity counts
4. Click on a category in sidebar - see detail page with properties/subobjects
5. Click on a property - navigate to property detail page
6. All pages show structured schema info, no raw JSON blobs
</verification>

<success_criteria>
- User can view detail page for any category showing ID, label, description, properties, subobjects
- User can view detail page for any property showing ID, label, description, datatype, cardinality
- User can view detail page for any subobject showing ID, label, description, properties
- User can navigate between entities using sidebar tree browser
- Entity pages display parsed schema as structured table, not raw JSON
- Frontend builds without errors
- Docker Compose runs frontend alongside backend
</success_criteria>

<output>
After completion, create `.planning/phases/03-entity-browsing/03-01-SUMMARY.md`
</output>
