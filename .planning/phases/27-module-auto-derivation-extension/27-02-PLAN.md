---
phase: 27-module-auto-derivation-extension
plan: 02
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - backend/app/routers/draft_changes.py
  - backend/tests/test_module_derived.py
autonomous: true

must_haves:
  truths:
    - "Draft auto-populate includes resources in module patch"
    - "Draft patch uses 'add' op for /resources path (not 'replace')"
    - "Module CREATE gets resources in replacement_json"
    - "Tests verify transitive derivation chain"
    - "Tests verify cycle handling terminates"
  artifacts:
    - path: "backend/app/routers/draft_changes.py"
      provides: "Updated auto_populate_module_derived with resources"
      contains: "/resources"
    - path: "backend/tests/test_module_derived.py"
      provides: "Unit tests for module derivation"
      min_lines: 50
  key_links:
    - from: "auto_populate_module_derived"
      to: "compute_module_derived_entities"
      via: "function call"
      pattern: "derived\\[.resources.\\]"
    - from: "test_module_derived.py"
      to: "module_derived.py"
      via: "test import"
      pattern: "from app.services.module_derived import"
---

<objective>
Integrate transitive derivation into draft system and add comprehensive tests.

Purpose: Wire up the new derivation algorithm to auto_populate_module_derived so drafts include resources, and validate the algorithm with unit tests covering transitive chains and cycle handling.

Output: Updated draft_changes.py with resource support, new test file validating derivation behavior.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-module-auto-derivation-extension/27-01-SUMMARY.md
@backend/app/routers/draft_changes.py
@backend/app/services/module_derived.py
@backend/tests/conftest.py
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update auto_populate_module_derived for resources</name>
  <files>backend/app/routers/draft_changes.py</files>
  <action>
Update `auto_populate_module_derived()` to handle the new "resources" key from derivation:

1. **For CREATE changes (lines 172-178):**
   - After setting properties/subobjects/templates on replacement_json
   - Add: `replacement["resources"] = derived.get("resources", [])`

2. **For UPDATE changes (lines 181-199):**
   - Add `/resources` to `derived_paths` set (line 184)
   - Add `/resources` patch operation in the loop (lines 192-197):
     ```python
     for path, values in [
         ("/properties", derived["properties"]),
         ("/subobjects", derived["subobjects"]),
         ("/templates", derived["templates"]),
         ("/resources", derived.get("resources", [])),  # NEW
     ]:
         filtered_patches.append({"op": "add", "path": path, "value": values})
     ```

**Critical per CLAUDE.md:**
- Use `"op": "add"` for `/resources` path (never "replace")
- This is the existing pattern for other derived arrays - follow it exactly
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/backend
python -c "
from app.routers.draft_changes import auto_populate_module_derived
import inspect
source = inspect.getsource(auto_populate_module_derived)
assert '/resources' in source, 'Missing /resources path'
assert 'add' in source and 'replace' not in source.split('derived_paths')[1].split('commit')[0], 'Should use add op'
print('/resources path handling: OK')
print('Uses add op: OK')
"
```
  </verify>
  <done>
- `auto_populate_module_derived()` handles "resources" key from derivation
- CREATE changes include resources in replacement_json
- UPDATE changes add `/resources` patch with "add" op
- Existing functionality preserved for properties/subobjects/templates
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for module derivation</name>
  <files>backend/tests/test_module_derived.py</files>
  <action>
Create comprehensive unit tests for the transitive derivation algorithm:

```python
"""Unit tests for module derived entities computation.

Tests verify:
- Basic derivation (categories -> properties/subobjects/templates)
- Category reference extraction from properties
- Resource collection for categories
- Transitive derivation chains
- Cycle handling
"""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from uuid import uuid4

# Test helper functions
class TestExtractCategoryRefsFromProperties:
    """Test _extract_category_refs_from_properties helper."""

    @pytest.mark.asyncio
    async def test_extracts_allows_value_from_category(self):
        """Property with Allows_value_from_category field triggers category inclusion."""
        # Mock session and property with top-level format
        # Verify category key extracted

    @pytest.mark.asyncio
    async def test_extracts_allowed_values_from_category(self):
        """Property with allowed_values.from_category triggers category inclusion."""
        # Mock session and property with nested format
        # Verify category key extracted

    @pytest.mark.asyncio
    async def test_extracts_both_formats(self):
        """Handles both category reference formats."""
        # Test with properties using both formats
        # Verify both are extracted

    @pytest.mark.asyncio
    async def test_ignores_static_allowed_values(self):
        """Static allowed_values arrays don't trigger category inclusion."""
        # Property with allowed_values: ["A", "B", "C"]
        # Verify no category extracted


class TestGetCategoryResources:
    """Test _get_category_resources helper."""

    @pytest.mark.asyncio
    async def test_queries_canonical_resources(self):
        """Fetches resources from Resource table by category_key."""
        # Mock Resource query
        # Verify correct category_key filter

    @pytest.mark.asyncio
    async def test_includes_draft_created_resources(self):
        """Includes resources from draft CREATE changes."""
        # Mock draft_changes with resource CREATE
        # Verify included in result


class TestComputeModuleDerivedEntities:
    """Test main derivation function."""

    @pytest.mark.asyncio
    async def test_returns_all_entity_types(self):
        """Returns properties, subobjects, templates, and resources."""
        # Basic derivation from single category
        # Verify all keys present

    @pytest.mark.asyncio
    async def test_transitive_derivation(self):
        """Follows category refs through properties."""
        # Category A -> Property P -> references Category B
        # Verify B's entities included

    @pytest.mark.asyncio
    async def test_max_depth_enforced(self):
        """Stops at max_depth even if more categories pending."""
        # Deep chain: A -> B -> C -> D -> ... (11 levels)
        # Verify terminates at max_depth

    @pytest.mark.asyncio
    async def test_cycle_handling(self):
        """Handles cyclic category references without infinite loop."""
        # Category A -> Property -> Category B -> Property -> Category A
        # Verify terminates, both categories processed once

    @pytest.mark.asyncio
    async def test_empty_categories_returns_empty(self):
        """Empty category list returns empty derived entities."""
        # Call with []
        # Verify all lists empty
```

**Implementation notes:**
- Use pytest-asyncio for async tests
- Mock database session with AsyncMock
- Mock Property/Resource model responses
- Focus on algorithm correctness, not database integration
- Each test should be self-contained
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/backend
# Check test file exists and has expected structure
python -c "
import ast
with open('tests/test_module_derived.py') as f:
    tree = ast.parse(f.read())
classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]
print(f'Test classes: {classes}')
assert 'TestExtractCategoryRefsFromProperties' in classes
assert 'TestGetCategoryResources' in classes
assert 'TestComputeModuleDerivedEntities' in classes
print('All test classes present: OK')
"

# Run tests (may need mocking setup)
pytest tests/test_module_derived.py -v --tb=short 2>&1 | head -50 || echo "Test execution attempted"
```
  </verify>
  <done>
- Test file exists at `backend/tests/test_module_derived.py`
- Tests cover category reference extraction (both formats)
- Tests cover resource collection
- Tests cover transitive derivation chains
- Tests cover cycle handling and max_depth
- Tests are properly structured with pytest markers
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate end-to-end with existing data</name>
  <files>None (validation only)</files>
  <action>
Run validation against the existing database to ensure derivation works with real data:

1. **Start the backend if not running**
2. **Test derivation with real categories:**
   ```python
   # In Python REPL or script
   from app.database import get_session
   from app.services.module_derived import compute_module_derived_entities
   import asyncio

   async def test_real_derivation():
       async for session in get_session():
           # Test with a known category that has properties with allowed_values
           result = await compute_module_derived_entities(
               session,
               ["Equipment"],  # Or another category known to exist
               draft_id=None,
               max_depth=10,
           )
           print(f"Properties: {len(result['properties'])}")
           print(f"Subobjects: {len(result['subobjects'])}")
           print(f"Templates: {len(result['templates'])}")
           print(f"Resources: {len(result['resources'])}")
           return result

   asyncio.run(test_real_derivation())
   ```

3. **Verify no errors and reasonable output**
   - All entity types returned
   - No infinite loops (completes in reasonable time)
   - No exceptions

**This is validation, not automated testing. Manually verify the output makes sense.**
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/backend

# Quick smoke test - module imports and function callable
python -c "
from app.services.module_derived import compute_module_derived_entities
print('compute_module_derived_entities is callable:', callable(compute_module_derived_entities))
"

# If database is available, try real derivation (will fail gracefully if DB not running)
python -c "
import asyncio
try:
    from app.database import get_session
    from app.services.module_derived import compute_module_derived_entities

    async def quick_test():
        async for session in get_session():
            result = await compute_module_derived_entities(session, [], None)
            assert 'resources' in result, 'Missing resources key'
            print('Empty derivation returns resources key: OK')
            return

    asyncio.run(quick_test())
except Exception as e:
    print(f'Database test skipped: {e}')
    print('(This is OK if database is not running)')
"
```
  </verify>
  <done>
- Module derivation function works with empty input
- Function returns all expected keys including "resources"
- No runtime errors during import or basic execution
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/daharoni/dev/ontology-hub/backend

# 1. draft_changes.py handles resources
grep -n "/resources" app/routers/draft_changes.py

# 2. Test file exists with correct structure
python -c "
import ast
with open('tests/test_module_derived.py') as f:
    content = f.read()
    tree = ast.parse(content)

# Count test methods
test_methods = []
for node in ast.walk(tree):
    if isinstance(node, ast.AsyncFunctionDef) and node.name.startswith('test_'):
        test_methods.append(node.name)

print(f'Test methods found: {len(test_methods)}')
for m in test_methods[:10]:
    print(f'  - {m}')
"

# 3. Run tests
pytest tests/test_module_derived.py -v --tb=short 2>&1 | tail -20

# 4. Type check
python -m mypy app/routers/draft_changes.py --ignore-missing-imports 2>&1 | tail -10 || echo "mypy complete"
```
</verification>

<success_criteria>
1. `auto_populate_module_derived()` includes `/resources` in derived paths set
2. UPDATE patches use `"op": "add"` for `/resources` path
3. CREATE changes include `resources` in replacement_json
4. Test file has classes for helper functions and main derivation function
5. Tests cover both category reference formats (`Allows_value_from_category`, `allowed_values.from_category`)
6. Tests cover transitive derivation and cycle handling
7. All tests pass or are properly marked as integration tests
</success_criteria>

<output>
After completion, create `.planning/phases/27-module-auto-derivation-extension/27-02-SUMMARY.md`
</output>
