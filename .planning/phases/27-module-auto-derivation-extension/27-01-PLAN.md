---
phase: 27-module-auto-derivation-extension
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/module_derived.py
autonomous: true

must_haves:
  truths:
    - "Properties with allowed_values.from_category derive that category into module"
    - "Properties with Allows_value_from_category derive that category into module"
    - "Derived categories include their resources in module derivation"
    - "Derivation follows transitive chains (category A -> property B -> category C)"
    - "Derivation terminates on cycles without infinite loops"
  artifacts:
    - path: "backend/app/services/module_derived.py"
      provides: "Transitive derivation with category refs and resources"
      exports: ["compute_module_derived_entities"]
      contains: "visited_categories"
  key_links:
    - from: "compute_module_derived_entities"
      to: "_extract_category_refs_from_properties"
      via: "property scanning loop"
      pattern: "Allows_value_from_category|from_category"
    - from: "compute_module_derived_entities"
      to: "_get_category_resources"
      via: "resource collection"
      pattern: "Resource.*category_key"
---

<objective>
Extend module auto-derivation to support transitive category references and resource inclusion.

Purpose: Enable full dependency chain derivation where property `allowed_values.from_category` or `Allows_value_from_category` pulls in referenced categories, and all derived categories bring their resources.

Output: Updated `module_derived.py` with iterative expansion algorithm that handles cycles safely.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-module-auto-derivation-extension/27-CONTEXT.md
@.planning/phases/27-module-auto-derivation-extension/27-RESEARCH.md
@backend/app/services/module_derived.py
@backend/app/models/v2/resource.py
@backend/app/models/v2/property.py
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement transitive derivation algorithm</name>
  <files>backend/app/services/module_derived.py</files>
  <action>
Refactor `compute_module_derived_entities()` to implement iterative expansion with visited set pattern:

1. **Add new helper function `_extract_category_refs_from_properties()`:**
   - Accept property_keys set and draft_changes dict
   - For each property, get effective JSON (handle draft overlays)
   - Check BOTH formats per schema:
     - Top-level: `Allows_value_from_category` field
     - Nested: `allowed_values.from_category` field
   - Return set of referenced category keys

2. **Add new helper function `_get_category_resources()`:**
   - Accept category_key and draft_changes dict
   - Query canonical resources from Resource table where `category_key` matches
   - Also check draft_changes for CREATE operations with matching category
   - Return set of resource entity_keys

3. **Refactor `compute_module_derived_entities()` to use iterative expansion:**
   - Add `max_depth: int = 10` parameter with default
   - Initialize: `visited_categories = set()`, `pending_categories = set(initial_category_keys)`
   - Initialize collectors: `all_properties`, `all_subobjects`, `all_templates`, `all_resources` as sets
   - Main loop (while pending_categories and depth < max_depth):
     - depth += 1
     - current_batch = pending_categories - visited_categories
     - if not current_batch: break
     - visited_categories.update(current_batch)
     - For each category in current_batch:
       - Call `_get_category_members()` for properties/subobjects
       - Call `_get_category_resources()` for resources
       - Add to collectors
     - After processing batch:
       - Call `_extract_category_refs_from_properties()` on newly collected properties
       - Add new category refs to pending_categories
   - After loop: collect templates from all_properties
   - Return dict with "properties", "subobjects", "templates", "resources" keys (sorted lists)

4. **Add helper `_get_effective_property_json()`:**
   - Accept property_key and draft_changes
   - Handle CREATE: return replacement_json
   - Handle UPDATE: apply patch to canonical_json
   - Handle canonical: return canonical_json directly
   - Used by `_extract_category_refs_from_properties()`

**Critical per RESEARCH.md:**
- Use `visited_categories` set to prevent reprocessing
- Use `max_depth` cap as safety against pathological graphs
- Check BOTH `Allows_value_from_category` AND `allowed_values.from_category` formats
- Include draft-created resources in `_get_category_resources()`
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/backend
python -c "
from app.services.module_derived import compute_module_derived_entities
import asyncio
print('Module imports successfully')
# Check function signature includes max_depth
import inspect
sig = inspect.signature(compute_module_derived_entities)
assert 'max_depth' in sig.parameters, 'max_depth parameter missing'
print('max_depth parameter present')
print('OK')
"
```
  </verify>
  <done>
- `compute_module_derived_entities()` accepts `max_depth` parameter
- Function returns dict with "resources" key in addition to existing keys
- `_extract_category_refs_from_properties()` helper exists and checks both formats
- `_get_category_resources()` helper exists and queries Resource table
- Code handles draft changes for CREATE/UPDATE operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Add provenance tracking (optional enhancement)</name>
  <files>backend/app/services/module_derived.py</files>
  <action>
Add optional provenance tracking to help debug derivation chains:

1. **Add `track_provenance: bool = False` parameter** to `compute_module_derived_entities()`

2. **Initialize provenance dict** if tracking enabled:
   - `provenance: dict[str, str] = {}` mapping entity_key to derivation reason

3. **Record provenance during expansion:**
   - Initial categories: `"manual (from module.categories)"`
   - Properties from category: `"derived from category {cat_key}"`
   - Categories from property refs: `"derived because property {prop_key} references it"`
   - Resources from category: `"derived from category {cat_key}"`

4. **Return provenance in result** if tracking enabled:
   - Add `"provenance": provenance` to return dict when `track_provenance=True`
   - Omit when `track_provenance=False` (default)

This is a debugging aid, not required for core functionality. Keep implementation simple.
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/backend
python -c "
from app.services.module_derived import compute_module_derived_entities
import inspect
sig = inspect.signature(compute_module_derived_entities)
params = list(sig.parameters.keys())
print(f'Parameters: {params}')
# Provenance is optional enhancement
if 'track_provenance' in params:
    print('Provenance tracking available')
else:
    print('Provenance tracking not implemented (optional)')
print('OK')
"
```
  </verify>
  <done>
- `track_provenance` parameter added (optional)
- When enabled, returns provenance dict explaining why each entity was derived
- Default behavior unchanged (no provenance returned)
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/daharoni/dev/ontology-hub/backend

# 1. Module imports without errors
python -c "from app.services.module_derived import compute_module_derived_entities; print('Import OK')"

# 2. Check function signature
python -c "
from app.services.module_derived import compute_module_derived_entities
import inspect
sig = inspect.signature(compute_module_derived_entities)
print(f'Signature: {sig}')
assert 'max_depth' in sig.parameters
print('max_depth parameter: OK')
"

# 3. Type check passes
python -m mypy app/services/module_derived.py --ignore-missing-imports || echo "mypy check complete"

# 4. Verify helper functions exist
python -c "
from app.services import module_derived
helpers = ['_extract_category_refs_from_properties', '_get_category_resources', '_get_effective_property_json']
for h in helpers:
    assert hasattr(module_derived, h), f'Missing helper: {h}'
    print(f'{h}: OK')
"
```
</verification>

<success_criteria>
1. `compute_module_derived_entities()` returns dict with "properties", "subobjects", "templates", "resources" keys
2. Function has `max_depth` parameter with default value 10
3. `_extract_category_refs_from_properties()` checks both `Allows_value_from_category` and `allowed_values.from_category`
4. `_get_category_resources()` queries Resource table and includes draft creates
5. Module imports successfully with no syntax errors
6. Type hints are correct (mypy passes or only has expected warnings)
</success_criteria>

<output>
After completion, create `.planning/phases/27-module-auto-derivation-extension/27-01-SUMMARY.md`
</output>
