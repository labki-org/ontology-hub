---
phase: 14-validation-workflow-pr
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/validation/validator_v2.py
  - backend/app/services/validation/reference_v2.py
  - backend/app/services/validation/inheritance_v2.py
  - backend/app/services/validation/breaking_v2.py
  - backend/app/services/validation/schema_v2.py
  - backend/app/schemas/validation_v2.py
autonomous: true

must_haves:
  truths:
    - "Validation detects issues in draft entities including all pending changes"
    - "Reference validation checks all parents, properties, modules exist"
    - "Circular inheritance detection returns cycle path"
    - "Breaking change detection identifies deletions affecting other entities"
    - "JSON Schema validation checks entity JSON against _schema.json definitions"
  artifacts:
    - path: "backend/app/services/validation/validator_v2.py"
      provides: "Main validation orchestrator for v2 draft model"
      exports: ["validate_draft_v2"]
    - path: "backend/app/services/validation/reference_v2.py"
      provides: "Reference existence checks for v2"
      exports: ["check_references_v2"]
    - path: "backend/app/services/validation/schema_v2.py"
      provides: "JSON Schema validation against _schema.json definitions"
      exports: ["check_schema_v2"]
    - path: "backend/app/schemas/validation_v2.py"
      provides: "Validation result schemas with entity_key field"
      exports: ["ValidationResultV2", "DraftValidationReportV2"]
  key_links:
    - from: "backend/app/services/validation/validator_v2.py"
      to: "draft_overlay.py"
      via: "DraftOverlayService for effective entity reconstruction"
      pattern: "DraftOverlayService"
    - from: "backend/app/services/validation/validator_v2.py"
      to: "backend/app/services/validation/schema_v2.py"
      via: "import and call check_schema_v2 in validation pipeline"
      pattern: "check_schema_v2"
---

<objective>
Create v2 validation service that validates drafts using the DraftChange model.

Purpose: The existing v1 validation works on DraftPayload (monolithic JSON). V2 uses granular DraftChange records. This plan adapts validation to reconstruct effective entities from DraftChanges, then validate — including JSON Schema validation against _schema.json definitions.

Output: validation/validator_v2.py and supporting modules that validate v2 drafts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-validation-workflow-pr/14-CONTEXT.md
@.planning/phases/14-validation-workflow-pr/14-RESEARCH.md

# Existing v1 validation (adapt patterns)
@backend/app/services/validation/validator.py
@backend/app/services/validation/reference.py
@backend/app/services/validation/inheritance.py
@backend/app/services/validation/breaking.py
@backend/app/schemas/validation.py

# v2 draft model
@backend/app/models/v2/draft.py
@backend/app/services/draft_overlay.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create v2 validation schemas and supporting validation modules</name>
  <files>
    backend/app/schemas/validation_v2.py
    backend/app/services/validation/reference_v2.py
    backend/app/services/validation/inheritance_v2.py
    backend/app/services/validation/breaking_v2.py
  </files>
  <action>
Create Pydantic schemas and three validation service modules for v2:

**A. validation_v2.py (schemas)**

1. ValidationResultV2:
   - entity_type: Literal["category", "property", "subobject", "module", "bundle", "template"]
   - entity_key: str (NOT entity_id - v2 uses entity_key)
   - field_path: Optional[str] (JSON path like "/parents/0" or "label")
   - code: str (e.g., "MISSING_PARENT", "CIRCULAR_INHERITANCE", "BREAKING_DELETE", "SCHEMA_VIOLATION")
   - message: str (human-readable description)
   - severity: Literal["error", "warning", "info"]
   - suggested_semver: Optional[Literal["major", "minor", "patch"]] = None
   - old_value: Optional[str] = None
   - new_value: Optional[str] = None

2. DraftValidationReportV2:
   - is_valid: bool (True if no errors)
   - errors: list[ValidationResultV2]
   - warnings: list[ValidationResultV2]
   - info: list[ValidationResultV2]
   - suggested_semver: Literal["major", "minor", "patch"]
   - semver_reasons: list[str]
   - module_suggestions: dict[str, str] = {} (module_key -> suggested version)
   - bundle_suggestions: dict[str, str] = {} (bundle_key -> suggested version)

**B. reference_v2.py** - check_references_v2(effective_entities: dict, session: AsyncSession) -> list[ValidationResultV2]
   - effective_entities is a dict like {"category": {"Person": {...}, ...}, "property": {...}, ...}
   - Check category parents exist (in canonical OR effective)
   - Check category properties exist
   - Check module entity_keys exist
   - Check bundle module_keys exist
   - Return ValidationResultV2 with entity_key (not entity_id)

**C. inheritance_v2.py** - check_circular_inheritance_v2(effective_entities: dict) -> list[ValidationResultV2]
   - Build parent graph from effective categories
   - Use graphlib.TopologicalSorter for cycle detection
   - On CycleError, extract cycle path and return ValidationResultV2 with:
     - code: "CIRCULAR_INHERITANCE"
     - message: f"Circular inheritance detected: {' -> '.join(cycle_path)}"
     - severity: "error"

**D. breaking_v2.py** - detect_breaking_changes_v2(effective_entities: dict, draft_changes: list[DraftChange], session: AsyncSession) -> list[ValidationResultV2]
   - For DELETE changes: check if any other entity references the deleted entity
   - For UPDATE changes that remove properties/parents: check if breaking
   - Return warnings with suggested_semver="major" for breaking changes
  </action>
  <verify>python -c "from app.schemas.validation_v2 import ValidationResultV2, DraftValidationReportV2; from app.services.validation.reference_v2 import check_references_v2; from app.services.validation.inheritance_v2 import check_circular_inheritance_v2; print('OK')"</verify>
  <done>ValidationResultV2 and DraftValidationReportV2 schemas exist with entity_key field; reference, inheritance, and breaking change validation modules adapted for v2</done>
</task>

<task type="auto">
  <name>Task 2: Create JSON Schema validation module</name>
  <files>backend/app/services/validation/schema_v2.py</files>
  <action>
Create a JSON Schema validation module that validates effective entity JSON against _schema.json definitions from the canonical repo.

```python
async def check_schema_v2(
    effective_entities: dict[str, dict[str, dict]],
    session: AsyncSession,
) -> list[ValidationResultV2]:
    """Validate effective entity JSON against _schema.json definitions."""
```

Implementation:
1. Load _schema.json definitions for each entity type. These schemas define the structure that entity JSON files must conform to in the canonical repo. Look for how _schema.json files are stored:
   - Check if they're ingested into the database during sync (check models for a schema storage table)
   - If stored in DB: query them via session
   - If not in DB: load from the canonical repo files on disk (check settings for repo path) or fetch from GitHub
   - Use the jsonschema library (or the json schema validation approach already in the codebase) to validate each effective entity's JSON against its type's _schema.json

2. For each entity type in effective_entities:
   - Find the corresponding _schema.json (e.g., categories/_schema.json for category entities)
   - For each entity in that type:
     - Validate entity JSON against the schema
     - On validation error, create ValidationResultV2 with:
       - code: "SCHEMA_VIOLATION"
       - message: Human-readable description of what failed (e.g., "Missing required field 'label'", "Invalid type for field 'parents': expected array")
       - severity: "error"
       - field_path: JSON path to the invalid field (from schema validation error)

3. If _schema.json is not found for an entity type, skip validation for that type (do NOT error — some types may not have schemas yet). Optionally emit an "info" level result noting the missing schema.

4. Return list of all ValidationResultV2 findings.

Note: If the codebase already has a pattern for loading schema files (check services/sync or services/ingest for schema handling), follow that pattern. If jsonschema is not installed, use a lightweight alternative or manual validation of required fields and types based on the schema structure.
  </action>
  <verify>python -c "from app.services.validation.schema_v2 import check_schema_v2; print('OK')"</verify>
  <done>check_schema_v2 validates entity JSON against _schema.json definitions and returns SCHEMA_VIOLATION results for non-conforming entities</done>
</task>

<task type="auto">
  <name>Task 3: Create main validator_v2.py orchestrator</name>
  <files>backend/app/services/validation/validator_v2.py</files>
  <action>
Create the main validation orchestrator:

```python
async def validate_draft_v2(
    draft_id: UUID,
    session: AsyncSession,
) -> DraftValidationReportV2:
    """Validate v2 draft by reconstructing effective entities from DraftChanges."""
```

Implementation:
1. Query all DraftChange records for draft_id
2. Build effective_entities dict by:
   - Loading canonical entities of each type
   - Applying CREATE/UPDATE/DELETE changes via DraftOverlayService patterns
   - Result: {"category": {"Person": {effective_json}, ...}, ...}
3. Run validation checks (including JSON Schema validation):
   - results.extend(await check_references_v2(effective_entities, session))
   - results.extend(check_circular_inheritance_v2(effective_entities))
   - results.extend(await detect_breaking_changes_v2(effective_entities, draft_changes, session))
   - results.extend(await check_schema_v2(effective_entities, session))
   - results.extend(check_datatypes_v2(effective_entities)) # reuse v1 pattern if applicable
4. Separate by severity (errors, warnings, info)
5. Compute suggested_semver using v1 semver.compute_semver_suggestion pattern
6. Compute module_suggestions and bundle_suggestions for changed modules/bundles
7. Return DraftValidationReportV2

Helper function for step 2:
```python
async def build_effective_entities(
    draft_changes: list[DraftChange],
    session: AsyncSession,
) -> dict[str, dict[str, dict]]:
    """Build effective entity state from draft changes overlaid on canonical."""
```
  </action>
  <verify>python -c "from app.services.validation.validator_v2 import validate_draft_v2; print('OK')"</verify>
  <done>validate_draft_v2 function exists and orchestrates all validation checks including JSON Schema validation against v2 draft model</done>
</task>

</tasks>

<verification>
- All new files exist in backend/app/services/validation/ and backend/app/schemas/
- Import test passes for all new modules including schema_v2
- No syntax errors in validation code
- validate_draft_v2 calls check_schema_v2 in its pipeline
</verification>

<success_criteria>
- ValidationResultV2 uses entity_key field (not entity_id)
- validate_draft_v2 reconstructs effective entities from DraftChange records
- Reference, inheritance, breaking change, and JSON Schema validation adapted for v2
- JSON Schema validation checks entities against _schema.json definitions
- Validation pipeline returns structured DraftValidationReportV2
</success_criteria>

<output>
After completion, create `.planning/phases/14-validation-workflow-pr/14-01-SUMMARY.md`
</output>
