---
phase: 14-validation-workflow-pr
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/validation/validator_v2.py
  - backend/app/services/validation/reference_v2.py
  - backend/app/services/validation/inheritance_v2.py
  - backend/app/services/validation/breaking_v2.py
  - backend/app/schemas/validation_v2.py
autonomous: true

must_haves:
  truths:
    - "Validation runs against effective entity state reconstructed from DraftChanges"
    - "Reference validation checks all parents, properties, modules exist"
    - "Circular inheritance detection returns cycle path"
    - "Breaking change detection identifies deletions affecting other entities"
  artifacts:
    - path: "backend/app/services/validation/validator_v2.py"
      provides: "Main validation orchestrator for v2 draft model"
      exports: ["validate_draft_v2"]
    - path: "backend/app/services/validation/reference_v2.py"
      provides: "Reference existence checks for v2"
      exports: ["check_references_v2"]
    - path: "backend/app/schemas/validation_v2.py"
      provides: "Validation result schemas with entity_key field"
      exports: ["ValidationResultV2", "DraftValidationReportV2"]
  key_links:
    - from: "backend/app/services/validation/validator_v2.py"
      to: "draft_overlay.py"
      via: "DraftOverlayService for effective entity reconstruction"
      pattern: "DraftOverlayService"
---

<objective>
Create v2 validation service that validates drafts using the DraftChange model.

Purpose: The existing v1 validation works on DraftPayload (monolithic JSON). V2 uses granular DraftChange records. This plan adapts validation to reconstruct effective entities from DraftChanges, then validate.

Output: validation/validator_v2.py and supporting modules that validate v2 drafts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-validation-workflow-pr/14-CONTEXT.md
@.planning/phases/14-validation-workflow-pr/14-RESEARCH.md

# Existing v1 validation (adapt patterns)
@backend/app/services/validation/validator.py
@backend/app/services/validation/reference.py
@backend/app/services/validation/inheritance.py
@backend/app/services/validation/breaking.py
@backend/app/schemas/validation.py

# v2 draft model
@backend/app/models/v2/draft.py
@backend/app/services/draft_overlay.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create v2 validation schemas</name>
  <files>backend/app/schemas/validation_v2.py</files>
  <action>
Create Pydantic schemas for v2 validation results:

1. ValidationResultV2:
   - entity_type: Literal["category", "property", "subobject", "module", "bundle", "template"]
   - entity_key: str (NOT entity_id - v2 uses entity_key)
   - field_path: Optional[str] (JSON path like "/parents/0" or "label")
   - code: str (e.g., "MISSING_PARENT", "CIRCULAR_INHERITANCE", "BREAKING_DELETE")
   - message: str (human-readable description)
   - severity: Literal["error", "warning", "info"]
   - suggested_semver: Optional[Literal["major", "minor", "patch"]] = None
   - old_value: Optional[str] = None
   - new_value: Optional[str] = None

2. DraftValidationReportV2:
   - is_valid: bool (True if no errors)
   - errors: list[ValidationResultV2]
   - warnings: list[ValidationResultV2]
   - info: list[ValidationResultV2]
   - suggested_semver: Literal["major", "minor", "patch"]
   - semver_reasons: list[str]
   - module_suggestions: dict[str, str] = {} (module_key -> suggested version)
   - bundle_suggestions: dict[str, str] = {} (bundle_key -> suggested version)
  </action>
  <verify>python -c "from app.schemas.validation_v2 import ValidationResultV2, DraftValidationReportV2; print('OK')"</verify>
  <done>ValidationResultV2 and DraftValidationReportV2 schemas exist with entity_key field</done>
</task>

<task type="auto">
  <name>Task 2: Create v2 validation services</name>
  <files>
    backend/app/services/validation/reference_v2.py
    backend/app/services/validation/inheritance_v2.py
    backend/app/services/validation/breaking_v2.py
  </files>
  <action>
Create three validation service modules adapted for v2 DraftChange model:

1. reference_v2.py - check_references_v2(effective_entities: dict, session: AsyncSession) -> list[ValidationResultV2]
   - effective_entities is a dict like {"category": {"Person": {...}, ...}, "property": {...}, ...}
   - Check category parents exist (in canonical OR effective)
   - Check category properties exist
   - Check module entity_keys exist
   - Check bundle module_keys exist
   - Return ValidationResultV2 with entity_key (not entity_id)

2. inheritance_v2.py - check_circular_inheritance_v2(effective_entities: dict) -> list[ValidationResultV2]
   - Build parent graph from effective categories
   - Use graphlib.TopologicalSorter for cycle detection
   - On CycleError, extract cycle path and return ValidationResultV2 with:
     - code: "CIRCULAR_INHERITANCE"
     - message: f"Circular inheritance detected: {' -> '.join(cycle_path)}"
     - severity: "error"

3. breaking_v2.py - detect_breaking_changes_v2(effective_entities: dict, draft_changes: list[DraftChange], session: AsyncSession) -> list[ValidationResultV2]
   - For DELETE changes: check if any other entity references the deleted entity
   - For UPDATE changes that remove properties/parents: check if breaking
   - Return warnings with suggested_semver="major" for breaking changes
  </action>
  <verify>python -c "from app.services.validation.reference_v2 import check_references_v2; from app.services.validation.inheritance_v2 import check_circular_inheritance_v2; print('OK')"</verify>
  <done>Three validation modules exist that work with effective entity dictionaries</done>
</task>

<task type="auto">
  <name>Task 3: Create main validator_v2.py orchestrator</name>
  <files>backend/app/services/validation/validator_v2.py</files>
  <action>
Create the main validation orchestrator:

```python
async def validate_draft_v2(
    draft_id: UUID,
    session: AsyncSession,
) -> DraftValidationReportV2:
    """Validate v2 draft by reconstructing effective entities from DraftChanges."""
```

Implementation:
1. Query all DraftChange records for draft_id
2. Build effective_entities dict by:
   - Loading canonical entities of each type
   - Applying CREATE/UPDATE/DELETE changes via DraftOverlayService patterns
   - Result: {"category": {"Person": {effective_json}, ...}, ...}
3. Run validation checks:
   - results.extend(await check_references_v2(effective_entities, session))
   - results.extend(check_circular_inheritance_v2(effective_entities))
   - results.extend(await detect_breaking_changes_v2(effective_entities, draft_changes, session))
   - results.extend(check_datatypes_v2(effective_entities)) # reuse v1 pattern
4. Separate by severity (errors, warnings, info)
5. Compute suggested_semver using v1 semver.compute_semver_suggestion pattern
6. Compute module_suggestions and bundle_suggestions for changed modules/bundles
7. Return DraftValidationReportV2

Helper function for step 2:
```python
async def build_effective_entities(
    draft_changes: list[DraftChange],
    session: AsyncSession,
) -> dict[str, dict[str, dict]]:
    """Build effective entity state from draft changes overlaid on canonical."""
```
  </action>
  <verify>python -c "from app.services.validation.validator_v2 import validate_draft_v2; print('OK')"</verify>
  <done>validate_draft_v2 function exists and orchestrates all validation checks against v2 draft model</done>
</task>

</tasks>

<verification>
- All four new files exist in backend/app/services/validation/ and backend/app/schemas/
- Import test passes for all new modules
- No syntax errors in validation code
</verification>

<success_criteria>
- ValidationResultV2 uses entity_key field (not entity_id)
- validate_draft_v2 reconstructs effective entities from DraftChange records
- Reference, inheritance, and breaking change validation adapted for v2
- Validation pipeline returns structured DraftValidationReportV2
</success_criteria>

<output>
After completion, create `.planning/phases/14-validation-workflow-pr/14-01-SUMMARY.md`
</output>
