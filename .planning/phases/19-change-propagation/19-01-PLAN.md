---
phase: 19-change-propagation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/stores/draftStoreV2.ts
  - frontend/src/lib/dependencyGraph.ts
  - frontend/src/hooks/useAutoSave.ts
autonomous: true

must_haves:
  truths:
    - "System tracks which entities have been directly edited in current draft session"
    - "System can compute transitive dependencies from any edited entity"
    - "Editing an entity automatically triggers change tracking after save succeeds"
  artifacts:
    - path: "frontend/src/stores/draftStoreV2.ts"
      provides: "Change tracking state and actions"
      contains: "directlyEditedEntities"
    - path: "frontend/src/lib/dependencyGraph.ts"
      provides: "BFS traversal for transitive dependencies"
      exports: ["computeAffectedEntities"]
    - path: "frontend/src/hooks/useAutoSave.ts"
      provides: "Auto-save hook with change tracking wiring"
      contains: "markEntityEdited"
  key_links:
    - from: "frontend/src/stores/draftStoreV2.ts"
      to: "frontend/src/lib/dependencyGraph.ts"
      via: "computeAffectedEntities in store action"
      pattern: "computeAffectedEntities"
    - from: "frontend/src/hooks/useAutoSave.ts"
      to: "frontend/src/stores/draftStoreV2.ts"
      via: "markEntityEdited in onSuccess callback"
      pattern: "markEntityEdited"
---

<objective>
Add change tracking foundation to draftStoreV2, create dependency graph utility, and wire it into the auto-save flow.

Purpose: Enable downstream components (sidebar, graph, detail modal) to highlight directly edited entities with strong visual indicators and transitively affected entities with subtle indicators. This is the data layer that UI components will consume.

Output: Extended draftStoreV2 with Sets for tracking edited/affected entities, a utility function for computing transitive dependencies via BFS, and automatic change tracking when edits are saved.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-change-propagation/19-CONTEXT.md
@.planning/phases/19-change-propagation/19-RESEARCH.md

@frontend/src/stores/draftStoreV2.ts
@frontend/src/stores/graphStore.ts
@frontend/src/hooks/useAutoSave.ts
@frontend/src/api/types.ts
@frontend/src/lib/utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend draftStoreV2 with change tracking state</name>
  <files>frontend/src/stores/draftStoreV2.ts</files>
  <action>
Add change tracking state and actions to the existing draftStoreV2 Zustand store:

1. Enable immer's Map/Set support at top of file:
   ```typescript
   import { immer } from 'zustand/middleware/immer'
   import { enableMapSet } from 'immer'
   enableMapSet()
   ```

2. Add state fields to DraftStoreV2State interface:
   - `directlyEditedEntities: Set<string>` - entity_keys of entities user has edited
   - `transitivelyAffectedEntities: Set<string>` - entity_keys computed from dependencies

3. Add actions to interface:
   - `markEntityEdited: (entityKey: string, allNodes: GraphNode[], allEdges: GraphEdge[]) => void`
   - `clearChangeTracking: () => void` (exists, extend to clear new Sets)

4. Update initialState to include empty Sets

5. Implement markEntityEdited action:
   - Add entityKey to directlyEditedEntities Set
   - Import and call computeAffectedEntities from lib/dependencyGraph.ts
   - Store result in transitivelyAffectedEntities (excluding direct edits)

6. Update clearChangeTracking to also clear both new Sets

7. Wrap store with immer middleware (change `create<DraftStoreV2State>((set) => ...)` to `create<DraftStoreV2State>()(immer((set) => ...))`)

Import GraphNode and GraphEdge types from @/api/types.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd frontend && npx tsc --noEmit
```
  </verify>
  <done>
draftStoreV2 exports directlyEditedEntities and transitivelyAffectedEntities Sets, plus markEntityEdited action that populates both based on dependency graph.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dependency graph utility</name>
  <files>frontend/src/lib/dependencyGraph.ts</files>
  <action>
Create new utility file for computing transitive dependencies via BFS:

```typescript
import type { GraphNode, GraphEdge } from '@/api/types'

/**
 * Compute all entities transitively affected by an edit.
 * Uses BFS to traverse reverse dependencies (entities that depend ON the edited entity).
 *
 * @param editedEntityKey - The entity_key that was edited
 * @param allNodes - All nodes in the current graph view
 * @param allEdges - All edges in the current graph view
 * @returns Set of entity_keys that are transitively affected (not including the edited entity itself)
 */
export function computeAffectedEntities(
  editedEntityKey: string,
  allNodes: GraphNode[],
  allEdges: GraphEdge[]
): Set<string> {
  const affected = new Set<string>()
  const visited = new Set<string>()
  const queue: string[] = [editedEntityKey]

  // Build adjacency list for reverse edges (who depends on this node?)
  // In our graph, edge.source depends on edge.target (source inherits from target)
  // So reverse dependency: if edge.target === currentNode, then edge.source is affected

  while (queue.length > 0) {
    const current = queue.shift()!
    if (visited.has(current)) continue
    visited.add(current)

    // Find all entities that depend on current (reverse edges)
    for (const edge of allEdges) {
      // source -> target means source depends on target
      // So if current is the target, source is affected
      if (edge.target === current && !visited.has(edge.source)) {
        affected.add(edge.source)
        queue.push(edge.source)
      }
    }
  }

  // Remove the originally edited entity from affected set (it's "direct", not "transitive")
  affected.delete(editedEntityKey)

  return affected
}

/**
 * Get count of total affected entities (direct + transitive, deduplicated).
 */
export function getAffectedEntityCount(
  directEdits: Set<string>,
  transitiveEffects: Set<string>
): number {
  const total = new Set([...directEdits, ...transitiveEffects])
  return total.size
}
```

Note on edge direction: In the ontology graph, `edge.source` inherits from `edge.target` (child -> parent). So if a parent is edited, all children (source nodes pointing to it) are affected.
  </action>
  <verify>
TypeScript compiles:
```bash
cd frontend && npx tsc --noEmit
```
  </verify>
  <done>
dependencyGraph.ts exports computeAffectedEntities and getAffectedEntityCount functions that correctly traverse reverse dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire markEntityEdited into useAutoSave success callback</name>
  <files>frontend/src/hooks/useAutoSave.ts</files>
  <action>
Update useAutoSave hook to call markEntityEdited when a save succeeds:

1. Import useGraphStore from '@/stores/graphStore' (to get current graph nodes/edges)

2. In the mutation onSuccess callback, after invalidating queries:
   ```typescript
   // Track this entity as edited for change propagation visualization
   const { nodes, edges } = useGraphStore.getState()
   useDraftStoreV2.getState().markEntityEdited(entityKey, nodes, edges)
   ```

3. The hook already has access to `entityKey` from the options.

4. Add the import for useGraphStore at the top of the file.

This ensures that every successful auto-save triggers change tracking, which in turn computes transitive effects based on the current graph state.

Note: The graph may not always be loaded (e.g., user is on a different page). The markEntityEdited action should handle empty nodes/edges gracefully - it will still track the direct edit, just won't compute transitives until graph data is available.
  </action>
  <verify>
TypeScript compiles:
```bash
cd frontend && npx tsc --noEmit
```
  </verify>
  <done>
useAutoSave calls markEntityEdited on successful saves, wiring the change tracking into the edit flow automatically.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
2. No import errors when running dev server: `cd frontend && npm run dev`
3. Store can be imported and used (verify via browser console or quick test)
</verification>

<success_criteria>
1. draftStoreV2 has directlyEditedEntities and transitivelyAffectedEntities as Set<string>
2. markEntityEdited action adds entity to directEdits and computes transitives
3. computeAffectedEntities correctly traverses reverse dependencies via BFS
4. getAffectedEntityCount returns deduplicated total
5. useAutoSave calls markEntityEdited on successful save
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-change-propagation/19-01-SUMMARY.md`
</output>
