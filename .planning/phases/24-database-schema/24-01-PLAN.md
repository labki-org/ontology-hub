---
phase: 24-database-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/v2/dashboard.py
  - backend/app/models/v2/resource.py
  - backend/app/models/v2/relationships.py
  - backend/app/models/v2/enums.py
  - backend/app/models/v2/__init__.py
autonomous: true

must_haves:
  truths:
    - "Dashboard model class exists with canonical_json for pages storage"
    - "Resource model class exists with category_key column"
    - "ModuleDashboard and BundleDashboard junction tables defined"
    - "EntityType enum includes DASHBOARD and RESOURCE values"
  artifacts:
    - path: "backend/app/models/v2/dashboard.py"
      provides: "Dashboard, DashboardBase, DashboardPublic SQLModel classes"
      contains: "class Dashboard"
    - path: "backend/app/models/v2/resource.py"
      provides: "Resource, ResourceBase, ResourcePublic SQLModel classes"
      contains: "class Resource"
    - path: "backend/app/models/v2/relationships.py"
      provides: "ModuleDashboard, BundleDashboard junction tables"
      contains: "class ModuleDashboard"
    - path: "backend/app/models/v2/enums.py"
      provides: "EntityType enum with DASHBOARD and RESOURCE"
      contains: "DASHBOARD"
    - path: "backend/app/models/v2/__init__.py"
      provides: "Re-exports for all new models"
      contains: "Dashboard"
  key_links:
    - from: "backend/app/models/v2/__init__.py"
      to: "backend/app/models/v2/dashboard.py"
      via: "import statement"
      pattern: "from app\\.models\\.v2\\.dashboard import"
    - from: "backend/app/models/v2/__init__.py"
      to: "backend/app/models/v2/resource.py"
      via: "import statement"
      pattern: "from app\\.models\\.v2\\.resource import"
---

<objective>
Create SQLModel classes for Dashboard and Resource entities, plus junction tables for module/bundle associations.

Purpose: Establish the Python model layer that maps to database tables. These models follow the exact pattern established by Category, Property, and other v2.0 entities.

Output: Four modified/created files defining Dashboard, Resource, ModuleDashboard, BundleDashboard, and updated EntityType enum.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-database-schema/24-CONTEXT.md
@.planning/phases/24-database-schema/24-RESEARCH.md

# Existing model patterns to follow exactly
@backend/app/models/v2/category.py
@backend/app/models/v2/relationships.py
@backend/app/models/v2/enums.py
@backend/app/models/v2/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dashboard and Resource model files</name>
  <files>
    backend/app/models/v2/dashboard.py
    backend/app/models/v2/resource.py
  </files>
  <action>
Create two new model files following the exact pattern from category.py:

**dashboard.py:**
- DashboardBase(SQLModel): entity_key (indexed), source_path, label (indexed), description (optional), canonical_json (JSON column via sa_column=Column(JSON))
- Dashboard(DashboardBase, table=True): __tablename__="dashboards", UniqueConstraint on entity_key named "uq_dashboards_entity_key", id (UUID primary key), created_at, updated_at
- DashboardPublic(DashboardBase): id, created_at, updated_at

**resource.py:**
- ResourceBase(SQLModel): entity_key (indexed), source_path, label (indexed), description (optional), category_key (indexed, plain String - NOT a foreign key per CONTEXT.md decision), canonical_json (JSON column)
- Resource(ResourceBase, table=True): __tablename__="resources", UniqueConstraint on entity_key named "uq_resources_entity_key", id (UUID primary key), created_at, updated_at
- ResourcePublic(ResourceBase): id, created_at, updated_at

Use imports matching existing files: uuid, datetime, sqlalchemy as sa, Column/JSON from sqlalchemy, Field/SQLModel from sqlmodel.
  </action>
  <verify>
python -c "from app.models.v2.dashboard import Dashboard, DashboardBase, DashboardPublic; print('Dashboard OK')"
python -c "from app.models.v2.resource import Resource, ResourceBase, ResourcePublic; print('Resource OK')"
  </verify>
  <done>Dashboard and Resource model classes importable with Base and Public variants</done>
</task>

<task type="auto">
  <name>Task 2: Add junction tables and update enum</name>
  <files>
    backend/app/models/v2/relationships.py
    backend/app/models/v2/enums.py
  </files>
  <action>
**relationships.py** - Add two junction table classes after BundleModule:

```python
class ModuleDashboard(SQLModel, table=True):
    """Module-to-dashboard relationship.

    Represents: "module X includes dashboard Y"
    CASCADE: Deleting module removes junction rows (dashboard survives).
    RESTRICT: Cannot delete dashboard if any module references it.
    """

    __tablename__ = "module_dashboard"

    module_id: uuid.UUID = Field(foreign_key="modules_v2.id", primary_key=True)
    dashboard_id: uuid.UUID = Field(foreign_key="dashboards.id", primary_key=True)


class BundleDashboard(SQLModel, table=True):
    """Bundle-to-dashboard relationship.

    Represents: "bundle X includes dashboard Y"
    """

    __tablename__ = "bundle_dashboard"

    bundle_id: uuid.UUID = Field(foreign_key="bundles.id", primary_key=True)
    dashboard_id: uuid.UUID = Field(foreign_key="dashboards.id", primary_key=True)
```

**enums.py** - Add two new values to EntityType enum:

```python
class EntityType(str, Enum):
    """Types of schema entities in v2.0 (extended from v1.0)."""

    CATEGORY = "category"
    PROPERTY = "property"
    SUBOBJECT = "subobject"
    MODULE = "module"
    BUNDLE = "bundle"
    TEMPLATE = "template"
    DASHBOARD = "dashboard"  # NEW
    RESOURCE = "resource"    # NEW
```
  </action>
  <verify>
python -c "from app.models.v2.relationships import ModuleDashboard, BundleDashboard; print('Junctions OK')"
python -c "from app.models.v2.enums import EntityType; assert EntityType.DASHBOARD.value == 'dashboard'; print('Enum OK')"
  </verify>
  <done>ModuleDashboard, BundleDashboard junction tables defined; EntityType includes DASHBOARD and RESOURCE</done>
</task>

<task type="auto">
  <name>Task 3: Update model exports</name>
  <files>backend/app/models/v2/__init__.py</files>
  <action>
Update __init__.py to export all new models:

1. Add import statements (alphabetically sorted with existing imports):
```python
from app.models.v2.dashboard import Dashboard, DashboardBase, DashboardPublic
from app.models.v2.resource import Resource, ResourceBase, ResourcePublic
```

2. Add to relationship imports:
```python
from app.models.v2.relationships import (
    BundleDashboard,  # NEW
    BundleModule,
    CategoryParent,
    CategoryProperty,
    CategorySubobject,
    ModuleDashboard,  # NEW
    ModuleDependency,
    ModuleEntity,
    SubobjectProperty,
)
```

3. Add to __all__ list (in appropriate sections):
- After Template section: "Dashboard", "DashboardBase", "DashboardPublic", "Resource", "ResourceBase", "ResourcePublic"
- In Relationship tables section: "ModuleDashboard", "BundleDashboard"
  </action>
  <verify>
python -c "from app.models.v2 import Dashboard, Resource, ModuleDashboard, BundleDashboard, EntityType; print('All exports OK')"
  </verify>
  <done>All new models importable via single import from app.models.v2</done>
</task>

</tasks>

<verification>
Run from backend directory:

```bash
cd /home/daharoni/dev/ontology-hub/backend

# Verify all imports work
python -c "
from app.models.v2 import (
    Dashboard, DashboardBase, DashboardPublic,
    Resource, ResourceBase, ResourcePublic,
    ModuleDashboard, BundleDashboard,
    EntityType
)
print('Dashboard:', Dashboard.__tablename__)
print('Resource:', Resource.__tablename__)
print('ModuleDashboard:', ModuleDashboard.__tablename__)
print('BundleDashboard:', BundleDashboard.__tablename__)
print('EntityType.DASHBOARD:', EntityType.DASHBOARD.value)
print('EntityType.RESOURCE:', EntityType.RESOURCE.value)
print('All models OK')
"

# Verify model fields
python -c "
from app.models.v2 import Dashboard, Resource
d_fields = [f for f in Dashboard.model_fields.keys()]
r_fields = [f for f in Resource.model_fields.keys()]
assert 'entity_key' in d_fields
assert 'canonical_json' in d_fields
assert 'category_key' in r_fields
print('Model fields OK')
"
```
</verification>

<success_criteria>
1. dashboard.py exists with Dashboard, DashboardBase, DashboardPublic classes
2. resource.py exists with Resource, ResourceBase, ResourcePublic classes
3. relationships.py includes ModuleDashboard and BundleDashboard junction tables
4. enums.py EntityType includes DASHBOARD and RESOURCE
5. __init__.py exports all new models
6. All imports succeed without errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-database-schema/24-01-SUMMARY.md`
</output>
