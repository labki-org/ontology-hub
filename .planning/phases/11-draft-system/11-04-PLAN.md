---
phase: 11-draft-system
plan: 04
type: execute
wave: 2
depends_on: ["11-02"]
files_modified:
  - backend/app/routers/mediawiki_import.py
  - backend/app/routers/__init__.py
  - backend/app/schemas/mediawiki_import.py
autonomous: true

must_haves:
  truths:
    - "MediaWiki push creates a new draft with changes"
    - "Each change requires explicit action field (create/modify/delete)"
    - "Unknown entity_key with modify action is rejected"
    - "Existing entity_key with create action is rejected"
    - "Payload schema documented for MediaWiki extension team"
  artifacts:
    - path: "backend/app/routers/mediawiki_import.py"
      provides: "MediaWiki push import endpoint"
      exports: ["router"]
    - path: "backend/app/schemas/mediawiki_import.py"
      provides: "MediaWiki payload schemas with validation"
      exports: ["MediaWikiImportPayload", "MediaWikiChange"]
  key_links:
    - from: "backend/app/routers/mediawiki_import.py"
      to: "backend/app/models/v2/draft.py"
      via: "Draft, DraftChange creation"
      pattern: "from app.models.v2 import Draft, DraftChange"
    - from: "backend/app/schemas/mediawiki_import.py"
      to: "jsonpatch"
      via: "patch validation for modify action"
      pattern: "jsonpatch.JsonPatch"
---

<objective>
Create MediaWiki push import endpoint for receiving schema changes from wiki instances.

Purpose: Enable MediaWiki extensions to push proposed changes with explicit action signals (create/modify/delete) that create draft_change rows. This fulfills DRF-06 (MediaWiki push import).

Output: `/api/v2/mediawiki/import` endpoint with documented payload schema.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-draft-system/11-CONTEXT.md
@.planning/phases/11-draft-system/11-RESEARCH.md

# Existing code patterns
@backend/app/models/v2/draft.py
@backend/app/schemas/draft_change.py
@backend/app/dependencies/capability.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MediaWiki import schemas</name>
  <files>backend/app/schemas/mediawiki_import.py</files>
  <action>
Create Pydantic schemas for MediaWiki import payload:

```python
"""MediaWiki import payload schemas.

Payload format documentation for MediaWiki extension team:

```json
{
  "source": "mediawiki_push",
  "wiki_url": "https://smw.example.com",
  "user": "WikiUser",
  "comment": "Updated Person category properties",
  "changes": [
    {
      "action": "modify",
      "entity_type": "category",
      "entity_key": "Person",
      "patch": [
        {"op": "replace", "path": "/description", "value": "A human being (updated)"}
      ]
    },
    {
      "action": "create",
      "entity_type": "property",
      "entity_key": "birthPlace",
      "entity": {
        "entity_key": "birthPlace",
        "label": "Birth place",
        "description": "Location where person was born",
        "data_type": "Page"
      }
    },
    {
      "action": "delete",
      "entity_type": "property",
      "entity_key": "deprecated_field"
    }
  ]
}
```

Action field meanings:
- "create": Add new entity (entity_key must NOT exist in canonical)
- "modify": Update existing entity (entity_key MUST exist in canonical)
- "delete": Remove entity (entity_key MUST exist in canonical)
"""

from typing import Literal

import jsonpatch
from pydantic import BaseModel, field_validator, model_validator

VALID_ENTITY_TYPES = {"category", "property", "subobject", "module", "bundle", "template"}


class MediaWikiChange(BaseModel):
    """Single entity change from MediaWiki.

    Explicit action field prevents ambiguity from entity_key typos.
    """
    action: Literal["create", "modify", "delete"]
    entity_type: str
    entity_key: str
    patch: list[dict] | None = None  # For action="modify"
    entity: dict | None = None  # For action="create"

    @field_validator("entity_type")
    @classmethod
    def validate_entity_type(cls, v: str) -> str:
        if v not in VALID_ENTITY_TYPES:
            raise ValueError(
                f"Invalid entity_type: {v}. "
                f"Must be one of: {', '.join(sorted(VALID_ENTITY_TYPES))}"
            )
        return v

    @field_validator("patch")
    @classmethod
    def validate_patch(cls, v: list[dict] | None) -> list[dict] | None:
        if v is None:
            return v
        try:
            jsonpatch.JsonPatch(v)
        except jsonpatch.InvalidJsonPatch as e:
            raise ValueError(f"Invalid JSON Patch: {e}")
        return v

    @model_validator(mode="after")
    def validate_action_fields(self) -> "MediaWikiChange":
        """Validate action-specific field requirements."""
        if self.action == "modify":
            if not self.patch:
                raise ValueError("action 'modify' requires patch field")
            if self.entity:
                raise ValueError("action 'modify' must not have entity field")
        elif self.action == "create":
            if not self.entity:
                raise ValueError("action 'create' requires entity field")
            if self.patch:
                raise ValueError("action 'create' must not have patch field")
            # Validate entity has required fields
            if "entity_key" not in self.entity:
                raise ValueError("entity must have 'entity_key' field")
            if self.entity["entity_key"] != self.entity_key:
                raise ValueError(
                    f"entity.entity_key ({self.entity['entity_key']}) "
                    f"must match change.entity_key ({self.entity_key})"
                )
        elif self.action == "delete":
            if self.patch or self.entity:
                raise ValueError(
                    "action 'delete' must not have patch or entity field"
                )
        return self


class MediaWikiImportPayload(BaseModel):
    """Complete payload from MediaWiki push.

    Each push creates a NEW draft (not appended to existing).
    """
    source: str = "mediawiki_push"
    wiki_url: str
    user: str
    comment: str
    changes: list[MediaWikiChange]

    @field_validator("changes")
    @classmethod
    def validate_changes_not_empty(cls, v: list) -> list:
        if not v:
            raise ValueError("changes list cannot be empty")
        return v


class MediaWikiImportResponse(BaseModel):
    """Response after successful MediaWiki import."""
    draft_id: str  # UUID as string
    capability_url: str
    change_count: int
    expires_at: str  # ISO datetime
```
  </action>
  <verify>cd /home/daharoni/dev/ontology-hub/backend && python -c "
from app.schemas.mediawiki_import import MediaWikiImportPayload, MediaWikiChange

# Valid payload
payload = MediaWikiImportPayload(
    wiki_url='https://smw.example.com',
    user='TestUser',
    comment='Test import',
    changes=[
        MediaWikiChange(
            action='modify',
            entity_type='category',
            entity_key='Person',
            patch=[{'op': 'replace', 'path': '/description', 'value': 'Updated'}]
        )
    ]
)
print(f'Valid payload: {len(payload.changes)} changes')

# Invalid action should fail
try:
    MediaWikiChange(
        action='modify',
        entity_type='category',
        entity_key='X',
        patch=None  # Missing required patch
    )
except ValueError as e:
    print(f'Invalid rejected: modify without patch')
"</verify>
  <done>MediaWiki import schemas with action-specific validation</done>
</task>

<task type="auto">
  <name>Task 2: Create MediaWiki import endpoint</name>
  <files>backend/app/routers/mediawiki_import.py, backend/app/routers/__init__.py</files>
  <action>
Create endpoint for MediaWiki push imports:

```python
"""MediaWiki push import endpoint.

Receives schema change proposals from MediaWiki instances and creates
drafts with change rows. Each push creates a NEW draft.
"""

import logging
from datetime import datetime, timedelta

from fastapi import APIRouter, HTTPException, Request
from sqlalchemy import select
from sqlmodel.ext.asyncio.session import AsyncSession

from app.database import SessionDep
from app.dependencies.capability import (
    build_capability_url,
    generate_capability_token,
    hash_token,
)
from app.dependencies.rate_limit import RATE_LIMITS, limiter
from app.models.v2 import (
    Bundle, Category, ChangeType, Draft, DraftChange, DraftSource,
    DraftStatus, Module, OntologyVersion, Property, Subobject, Template,
)
from app.schemas.mediawiki_import import (
    MediaWikiImportPayload,
    MediaWikiImportResponse,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/mediawiki", tags=["mediawiki"])

DEFAULT_EXPIRATION_DAYS = 7

# Map entity_type to model class
ENTITY_MODELS = {
    "category": Category,
    "property": Property,
    "subobject": Subobject,
    "module": Module,
    "bundle": Bundle,
    "template": Template,
}


async def entity_exists(
    session: AsyncSession,
    entity_type: str,
    entity_key: str,
) -> bool:
    """Check if entity exists in canonical tables."""
    model = ENTITY_MODELS.get(entity_type)
    if not model:
        return False
    result = await session.execute(
        select(model).where(model.entity_key == entity_key)
    )
    return result.scalars().first() is not None


@router.post("/import", response_model=MediaWikiImportResponse, status_code=201)
@limiter.limit(RATE_LIMITS["draft_create"])
async def import_from_mediawiki(
    request: Request,
    payload: MediaWikiImportPayload,
    session: SessionDep,
) -> MediaWikiImportResponse:
    """Import schema changes from MediaWiki push.

    Creates a new draft with draft_change rows for each change.
    Each push creates a NEW draft (not appended to existing).

    Validation rules:
    - action="modify" or "delete": entity_key MUST exist in canonical
    - action="create": entity_key must NOT exist in canonical

    Args:
        request: HTTP request (for rate limiting and base URL)
        payload: MediaWiki import payload with changes
        session: Database session

    Returns:
        MediaWikiImportResponse with draft_id and capability_url

    Raises:
        HTTPException 400: If entity existence check fails
        HTTPException 422: If payload validation fails
    """
    # Validate entity existence for each change
    errors = []
    for i, change in enumerate(payload.changes):
        exists = await entity_exists(session, change.entity_type, change.entity_key)

        if change.action in ("modify", "delete") and not exists:
            errors.append(
                f"Change {i}: Unknown entity_key '{change.entity_key}' "
                f"with action '{change.action}'. "
                f"Use action='create' for new entities or fix the entity_key."
            )
        elif change.action == "create" and exists:
            errors.append(
                f"Change {i}: Entity '{change.entity_key}' already exists. "
                f"Use action='modify' to update existing entities."
            )

    if errors:
        raise HTTPException(
            status_code=400,
            detail={"errors": errors}
        )

    # Get current ontology version for base_commit_sha
    version_result = await session.execute(
        select(OntologyVersion).order_by(OntologyVersion.created_at.desc())
    )
    current_version = version_result.scalars().first()
    if not current_version:
        raise HTTPException(
            status_code=500,
            detail="No ontology version found. Run ingest first."
        )

    # Generate capability token
    token = generate_capability_token()

    # Create draft
    draft = Draft(
        capability_hash=hash_token(token),
        base_commit_sha=current_version.commit_sha,
        status=DraftStatus.DRAFT,
        source=DraftSource.MEDIAWIKI_PUSH,
        title=f"MediaWiki import: {payload.comment[:100]}",
        description=f"From {payload.wiki_url} by {payload.user}",
        expires_at=datetime.utcnow() + timedelta(days=DEFAULT_EXPIRATION_DAYS),
    )
    session.add(draft)
    await session.flush()  # Get draft.id

    # Create draft_change rows
    for change in payload.changes:
        # Map action to ChangeType
        change_type = {
            "create": ChangeType.CREATE,
            "modify": ChangeType.UPDATE,
            "delete": ChangeType.DELETE,
        }[change.action]

        draft_change = DraftChange(
            draft_id=draft.id,
            change_type=change_type,
            entity_type=change.entity_type,
            entity_key=change.entity_key,
            patch=change.patch if change.action == "modify" else None,
            replacement_json=change.entity if change.action == "create" else None,
        )
        session.add(draft_change)

    await session.commit()

    # Build capability URL
    base_url = str(request.base_url).rstrip("/")
    capability_url = build_capability_url(token, f"{base_url}/api/v2")

    logger.info(
        "MediaWiki import: created draft %s with %d changes from %s",
        draft.id,
        len(payload.changes),
        payload.wiki_url,
    )

    return MediaWikiImportResponse(
        draft_id=str(draft.id),
        capability_url=capability_url,
        change_count=len(payload.changes),
        expires_at=draft.expires_at.isoformat(),
    )
```

Register in __init__.py:
```python
from app.routers import mediawiki_import
router.include_router(mediawiki_import.router, prefix="/api/v2")
```
  </action>
  <verify>cd /home/daharoni/dev/ontology-hub/backend && python -c "from app.routers.mediawiki_import import router; print(f'Routes: {len(router.routes)}')"</verify>
  <done>MediaWiki import endpoint creates draft with validated changes</done>
</task>

</tasks>

<verification>
1. Schema validation:
   ```bash
   cd backend && python -c "
   from app.schemas.mediawiki_import import MediaWikiChange

   # Test entity_key mismatch rejected
   try:
       MediaWikiChange(
           action='create',
           entity_type='category',
           entity_key='Foo',
           entity={'entity_key': 'Bar', 'label': 'X'}  # Mismatch!
       )
   except ValueError as e:
       print(f'Mismatch rejected: OK')
   "
   ```

2. Router registered:
   ```bash
   cd backend && python -c "
   from app.routers import router
   routes = [r.path for r in router.routes if 'mediawiki' in r.path]
   print(f'MediaWiki routes: {routes}')
   "
   ```
</verification>

<success_criteria>
- MediaWiki payload requires explicit action field on each change
- action="modify" with unknown entity_key returns 400 with helpful message
- action="create" with existing entity_key returns 400 with helpful message
- Each MediaWiki push creates a NEW draft (not appended)
- Draft binds to current OntologyVersion.commit_sha
- Capability URL returned for draft access
- Payload schema documented in module docstring
</success_criteria>

<output>
After completion, create `.planning/phases/11-draft-system/11-04-SUMMARY.md`
</output>
