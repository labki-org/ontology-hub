---
phase: 11-draft-system
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - backend/app/services/draft_rebase.py
  - backend/app/routers/webhooks.py
autonomous: true

must_haves:
  truths:
    - "Auto-rebase triggers after successful canonical ingest"
    - "Patches that apply cleanly get rebase_status='clean'"
    - "Patches that fail to apply get rebase_status='conflict'"
    - "Original draft_change rows are never modified during rebase"
    - "Only DRAFT and VALIDATED status drafts are rebased"
  artifacts:
    - path: "backend/app/services/draft_rebase.py"
      provides: "Auto-rebase service with conflict detection"
      exports: ["auto_rebase_drafts"]
  key_links:
    - from: "backend/app/services/draft_rebase.py"
      to: "jsonpatch"
      via: "try-apply with JsonPatchConflict"
      pattern: "jsonpatch.JsonPatchConflict"
    - from: "backend/app/routers/webhooks.py"
      to: "backend/app/services/draft_rebase.py"
      via: "call after ingest"
      pattern: "auto_rebase_drafts"
---

<objective>
Implement auto-rebase service that detects conflicts when canonical data changes.

Purpose: When new canonical data is ingested, automatically test if existing draft patches still apply cleanly. Mark conflicting drafts for user review. This fulfills DRF-07 (auto-rebase on canonical updates).

Output: Draft rebase service integrated with webhook ingest flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-draft-system/11-CONTEXT.md
@.planning/phases/11-draft-system/11-RESEARCH.md

# Existing code to integrate with
@backend/app/routers/webhooks.py
@backend/app/models/v2/draft.py
@backend/app/services/draft_overlay.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create draft rebase service</name>
  <files>backend/app/services/draft_rebase.py</files>
  <action>
Create auto-rebase service that tests patch applicability:

```python
"""Draft rebase service for auto-rebase after canonical updates."""

import logging
from copy import deepcopy
from typing import Any

import jsonpatch
from sqlalchemy import select
from sqlmodel.ext.asyncio.session import AsyncSession

from app.models.v2 import (
    Bundle, Category, Draft, DraftChange, DraftStatus,
    ChangeType, Module, Property, Subobject, Template,
)

logger = logging.getLogger(__name__)

# Map entity_type string to model class
ENTITY_MODELS = {
    "category": Category,
    "property": Property,
    "subobject": Subobject,
    "module": Module,
    "bundle": Bundle,
    "template": Template,
}


async def load_canonical_entity(
    session: AsyncSession,
    entity_type: str,
    entity_key: str,
) -> dict | None:
    """Load canonical entity JSON by type and key."""
    model = ENTITY_MODELS.get(entity_type)
    if not model:
        return None

    result = await session.execute(
        select(model).where(model.entity_key == entity_key)
    )
    entity = result.scalars().first()
    if entity and hasattr(entity, 'canonical_json'):
        return entity.canonical_json
    return None


async def check_patch_applies(
    patch_ops: list[dict],
    canonical_json: dict,
) -> tuple[bool, str | None]:
    """Test if patch applies cleanly to canonical.

    Returns:
        (success, error_message)
    """
    try:
        test_base = deepcopy(canonical_json)
        patch = jsonpatch.JsonPatch(patch_ops)
        patch.apply(test_base)
        return (True, None)
    except jsonpatch.JsonPatchConflict as e:
        return (False, f"Patch conflict: {e}")
    except jsonpatch.JsonPatchException as e:
        return (False, f"Patch error: {e}")


async def auto_rebase_drafts(
    session: AsyncSession,
    old_commit_sha: str,
    new_commit_sha: str,
) -> dict[str, Any]:
    """Rebase all in-progress drafts after canonical update.

    For each draft with base_commit_sha == old_commit_sha:
    1. Load all draft_change rows
    2. For UPDATE changes: try to apply patch to new canonical
    3. For DELETE changes: verify entity still exists
    4. Mark draft as "clean" or "conflict" based on results

    IMPORTANT: Never modify draft_change rows - keep original patches
    for manual conflict resolution.

    Args:
        session: Database session
        old_commit_sha: Previous canonical commit
        new_commit_sha: New canonical commit after ingest

    Returns:
        Stats dict with counts of rebased/conflicted drafts
    """
    stats = {"rebased": 0, "conflicted": 0, "skipped": 0}

    # Find drafts that need rebase
    drafts_query = select(Draft).where(
        Draft.base_commit_sha == old_commit_sha,
        Draft.status.in_([DraftStatus.DRAFT, DraftStatus.VALIDATED])
    )
    result = await session.execute(drafts_query)
    drafts = result.scalars().all()

    for draft in drafts:
        conflict_detected = False
        conflict_reason = None

        # Load all changes for this draft
        changes_query = select(DraftChange).where(
            DraftChange.draft_id == draft.id
        )
        changes_result = await session.execute(changes_query)
        changes = changes_result.scalars().all()

        for change in changes:
            if change.change_type == ChangeType.UPDATE:
                # Load new canonical entity
                canonical = await load_canonical_entity(
                    session,
                    change.entity_type,
                    change.entity_key,
                )

                if canonical is None:
                    # Entity was deleted in new canonical
                    conflict_detected = True
                    conflict_reason = f"Entity {change.entity_key} deleted in canonical"
                    break

                # Try to apply patch
                if change.patch:
                    success, error = await check_patch_applies(
                        change.patch,
                        canonical,
                    )
                    if not success:
                        conflict_detected = True
                        conflict_reason = error
                        break

            elif change.change_type == ChangeType.DELETE:
                # Verify entity still exists (can't delete what's gone)
                canonical = await load_canonical_entity(
                    session,
                    change.entity_type,
                    change.entity_key,
                )
                if canonical is None:
                    # Entity already deleted
                    conflict_detected = True
                    conflict_reason = f"Entity {change.entity_key} already deleted"
                    break

            # CREATE changes don't need rebase check - they're new entities

        # Update draft rebase status
        draft.rebase_commit_sha = new_commit_sha
        if conflict_detected:
            draft.rebase_status = "conflict"
            logger.warning(
                "Draft %s has conflict: %s",
                draft.id,
                conflict_reason,
            )
            stats["conflicted"] += 1
        else:
            draft.rebase_status = "clean"
            stats["rebased"] += 1

        session.add(draft)

    await session.commit()

    logger.info(
        "Auto-rebase complete: %d rebased, %d conflicted",
        stats["rebased"],
        stats["conflicted"],
    )

    return stats
```
  </action>
  <verify>cd /home/daharoni/dev/ontology-hub/backend && python -c "from app.services.draft_rebase import auto_rebase_drafts, check_patch_applies; print('OK')"</verify>
  <done>Draft rebase service with try-apply conflict detection</done>
</task>

<task type="auto">
  <name>Task 2: Integrate rebase into webhook flow</name>
  <files>backend/app/routers/webhooks.py</files>
  <action>
Update webhook handler to call auto_rebase_drafts instead of mark_drafts_stale:

1. Import the new service:
   ```python
   from app.services.draft_rebase import auto_rebase_drafts
   ```

2. In `trigger_sync_background_v2`, replace the mark_drafts_stale call:

   Before:
   ```python
   if result.get("status") == "completed" and old_commit_sha:
       stale_count = await mark_drafts_stale(
           session, old_commit_sha, result["commit_sha"]
       )
   ```

   After:
   ```python
   if result.get("status") == "completed" and old_commit_sha:
       rebase_stats = await auto_rebase_drafts(
           session, old_commit_sha, result["commit_sha"]
       )
       logger.info(
           "Auto-rebase: %d clean, %d conflicts",
           rebase_stats["rebased"],
           rebase_stats["conflicted"],
       )
   ```

3. Remove or keep mark_drafts_stale function:
   - Keep it for backward compatibility but don't call it
   - Add deprecation comment: "# Deprecated: Use auto_rebase_drafts instead"

The rebase runs as part of the background task, so it won't block the webhook response.
  </action>
  <verify>cd /home/daharoni/dev/ontology-hub/backend && python -c "
from app.routers.webhooks import trigger_sync_background_v2
import inspect
source = inspect.getsource(trigger_sync_background_v2)
assert 'auto_rebase_drafts' in source, 'Should call auto_rebase_drafts'
print('OK: webhook calls auto_rebase_drafts')
"</verify>
  <done>Webhook triggers auto-rebase after successful ingest</done>
</task>

</tasks>

<verification>
1. Rebase service functions:
   ```bash
   cd backend && python -c "
   from app.services.draft_rebase import check_patch_applies
   import asyncio

   # Test patch that applies
   result = asyncio.run(check_patch_applies(
       [{'op': 'replace', 'path': '/name', 'value': 'new'}],
       {'name': 'old', 'other': 'field'}
   ))
   print(f'Valid patch: {result}')

   # Test patch that conflicts
   result = asyncio.run(check_patch_applies(
       [{'op': 'replace', 'path': '/missing', 'value': 'x'}],
       {'name': 'old'}
   ))
   print(f'Conflict patch: {result}')
   "
   ```

2. Webhook integration:
   ```bash
   cd backend && grep -n "auto_rebase_drafts" app/routers/webhooks.py
   ```
</verification>

<success_criteria>
- auto_rebase_drafts tests all UPDATE patches against new canonical
- JsonPatchConflict exceptions caught and marked as conflict
- Deleted canonical entities detected as conflict
- draft.rebase_status updated to "clean" or "conflict"
- draft.rebase_commit_sha updated to new commit
- Original draft_change.patch never modified
- Webhook triggers rebase after successful ingest
</success_criteria>

<output>
After completion, create `.planning/phases/11-draft-system/11-03-SUMMARY.md`
</output>
