---
phase: 25-backend-ingest-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/parsers/entity_parser.py
autonomous: true

must_haves:
  truths:
    - "EntityParser can parse dashboard JSON files into Dashboard model instances"
    - "EntityParser can parse resource JSON files (nested paths) into Resource model instances"
    - "ParsedEntities dataclass includes dashboards and resources lists"
    - "Module parsing extracts dashboard and resource relationships"
    - "Bundle parsing extracts dashboard relationships"
  artifacts:
    - path: "backend/app/services/parsers/entity_parser.py"
      provides: "parse_dashboard, parse_resource methods and updated ParsedEntities"
      contains: "def parse_dashboard"
    - path: "backend/app/services/parsers/entity_parser.py"
      provides: "Dashboard and Resource imports"
      contains: "from app.models.v2 import"
  key_links:
    - from: "backend/app/services/parsers/entity_parser.py"
      to: "backend/app/models/v2/dashboard.py"
      via: "import statement"
      pattern: "Dashboard"
    - from: "backend/app/services/parsers/entity_parser.py"
      to: "backend/app/models/v2/resource.py"
      via: "import statement"
      pattern: "Resource"
---

<objective>
Extend EntityParser to parse Dashboard and Resource entities from labki-ontology repository.

Purpose: Add parsing capability for the two new entity types. Dashboards are flat files in dashboards/, Resources use nested paths like templates (resources/{Category}/{key}.json). Module and bundle parsing must also extract dashboard relationships.

Output: Updated entity_parser.py with parse_dashboard(), parse_resource() methods, updated ParsedEntities dataclass, and relationship extraction in parse_module/parse_bundle.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-backend-ingest-pipeline/25-CONTEXT.md

# Existing parser patterns to follow
@backend/app/services/parsers/entity_parser.py
@backend/app/models/v2/dashboard.py
@backend/app/models/v2/resource.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Dashboard and Resource imports to EntityParser</name>
  <files>backend/app/services/parsers/entity_parser.py</files>
  <action>
Update the imports from app.models.v2 to include Dashboard and Resource:

```python
from app.models.v2 import (
    Bundle,
    Category,
    Dashboard,      # ADD
    EntityType,
    Module,
    Property,
    Resource,       # ADD
    Subobject,
    Template,
)
```

Maintain alphabetical order.
  </action>
  <verify>
cd /home/daharoni/dev/ontology-hub/backend && python -c "from app.services.parsers.entity_parser import EntityParser; print('Import OK')"
  </verify>
  <done>Dashboard and Resource models imported in entity_parser.py without import errors</done>
</task>

<task type="auto">
  <name>Task 2: Add parse_dashboard and parse_resource methods</name>
  <files>backend/app/services/parsers/entity_parser.py</files>
  <action>
Add two new methods after parse_template():

```python
def parse_dashboard(self, content: dict, source_path: str) -> Dashboard:
    """Parse dashboard JSON into model instance.

    Args:
        content: Parsed JSON content from dashboard file
        source_path: Original file path, e.g., "dashboards/Core_overview.json"

    Returns:
        Dashboard instance (no relationships extracted - module/bundle declares dashboard membership)
    """
    entity_key = content["id"]

    return Dashboard(
        entity_key=entity_key,
        source_path=source_path,
        label=content.get("label", entity_key),
        description=content.get("description"),
        canonical_json=content,  # Contains 'pages' array with wikitext
    )

def parse_resource(self, content: dict, source_path: str) -> Resource:
    """Parse resource JSON into model instance.

    Args:
        content: Parsed JSON content from resource file
        source_path: Original file path, e.g., "resources/Person/John_doe.json"

    Returns:
        Resource instance (category_key extracted from content)

    Note:
        Resource entity_key includes category prefix for uniqueness
        (e.g., "Person/John_doe" from resources/Person/John_doe.json)
    """
    entity_key = content["id"]  # Already includes category: "Person/John_doe"

    return Resource(
        entity_key=entity_key,
        source_path=source_path,
        label=content.get("label", entity_key),
        description=content.get("description"),
        category_key=content.get("category"),  # "Person"
        canonical_json=content,  # Includes additional properties
    )
```
  </action>
  <verify>
cd /home/daharoni/dev/ontology-hub/backend && python -c "
from app.services.parsers.entity_parser import EntityParser
ep = EntityParser()
assert hasattr(ep, 'parse_dashboard')
assert hasattr(ep, 'parse_resource')
print('Methods exist OK')
"
  </verify>
  <done>parse_dashboard and parse_resource methods exist and follow existing parse_* method patterns</done>
</task>

<task type="auto">
  <name>Task 3: Update ParsedEntities dataclass with dashboards and resources</name>
  <files>backend/app/services/parsers/entity_parser.py</files>
  <action>
Update the ParsedEntities dataclass:

1. Add two new fields after templates:
```python
@dataclass
class ParsedEntities:
    """Container for all parsed data from a repository."""

    categories: list[Category]
    properties: list[Property]
    subobjects: list[Subobject]
    modules: list[Module]
    bundles: list[Bundle]
    templates: list[Template]
    dashboards: list[Dashboard]    # ADD
    resources: list[Resource]      # ADD
    relationships: list[PendingRelationship]
```

2. Update entity_counts() method to include the new fields:
```python
def entity_counts(self) -> dict[str, int]:
    """Return counts for each entity type (for OntologyVersion tracking)."""
    return {
        "categories": len(self.categories),
        "properties": len(self.properties),
        "subobjects": len(self.subobjects),
        "modules": len(self.modules),
        "bundles": len(self.bundles),
        "templates": len(self.templates),
        "dashboards": len(self.dashboards),    # ADD
        "resources": len(self.resources),      # ADD
        "relationships": len(self.relationships),
    }
```
  </action>
  <verify>
cd /home/daharoni/dev/ontology-hub/backend && python -c "
from app.services.parsers.entity_parser import ParsedEntities
import inspect
sig = inspect.signature(ParsedEntities)
params = list(sig.parameters.keys())
assert 'dashboards' in params, 'dashboards field missing'
assert 'resources' in params, 'resources field missing'
print('ParsedEntities fields OK')
"
  </verify>
  <done>ParsedEntities dataclass includes dashboards and resources fields with entity_counts() updated</done>
</task>

<task type="auto">
  <name>Task 4: Update parse_module to extract dashboard and resource relationships</name>
  <files>backend/app/services/parsers/entity_parser.py</files>
  <action>
In parse_module(), add extraction of dashboard and resource relationships. Add this code BEFORE the `return module, relationships` line:

```python
# Extract dashboard memberships
for dash_key in content.get("dashboards", []):
    relationships.append(
        PendingRelationship(
            type="module_dashboard",
            source_key=entity_key,
            target_key=dash_key,
        )
    )

# Extract resource memberships
for res_key in content.get("resources", []):
    relationships.append(
        PendingRelationship(
            type="module_entity",
            source_key=entity_key,
            target_key=res_key,
            extra={"entity_type": EntityType.RESOURCE},
        )
    )
```
  </action>
  <verify>
cd /home/daharoni/dev/ontology-hub/backend && python -c "
from app.services.parsers.entity_parser import EntityParser
ep = EntityParser()
module, rels = ep.parse_module({'id': 'Test', 'dashboards': ['D1'], 'resources': ['R1']}, 'modules/Test.json')
rel_types = [r.type for r in rels]
assert 'module_dashboard' in rel_types, 'module_dashboard relationship not extracted'
print('parse_module extracts dashboard relationships OK')
"
  </verify>
  <done>parse_module extracts module_dashboard and module_entity (resource) relationships</done>
</task>

<task type="auto">
  <name>Task 5: Update parse_bundle to extract dashboard relationships</name>
  <files>backend/app/services/parsers/entity_parser.py</files>
  <action>
In parse_bundle(), add extraction of dashboard relationships. Add this code BEFORE the `return bundle, relationships` line:

```python
# Extract dashboard memberships
for dash_key in content.get("dashboards", []):
    relationships.append(
        PendingRelationship(
            type="bundle_dashboard",
            source_key=entity_key,
            target_key=dash_key,
        )
    )
```
  </action>
  <verify>
cd /home/daharoni/dev/ontology-hub/backend && python -c "
from app.services.parsers.entity_parser import EntityParser
ep = EntityParser()
bundle, rels = ep.parse_bundle({'id': 'Test', 'dashboards': ['D1']}, 'bundles/Test.json')
rel_types = [r.type for r in rels]
assert 'bundle_dashboard' in rel_types, 'bundle_dashboard relationship not extracted'
print('parse_bundle extracts dashboard relationships OK')
"
  </verify>
  <done>parse_bundle extracts bundle_dashboard relationships</done>
</task>

<task type="auto">
  <name>Task 6: Update parse_all to handle dashboards and resources</name>
  <files>backend/app/services/parsers/entity_parser.py</files>
  <action>
In parse_all():

1. Add list initializers after templates:
```python
dashboards: list[Dashboard] = []
resources: list[Resource] = []
```

2. Add parsing loops after templates parsing:
```python
# Parse dashboards
for path, content in files.get("dashboards", []):
    dashboard = self.parse_dashboard(content, path)
    dashboards.append(dashboard)

# Parse resources
for path, content in files.get("resources", []):
    resource = self.parse_resource(content, path)
    resources.append(resource)
```

3. Update the return statement to include new fields:
```python
return ParsedEntities(
    categories=categories,
    properties=properties,
    subobjects=subobjects,
    modules=modules,
    bundles=bundles,
    templates=templates,
    dashboards=dashboards,    # ADD
    resources=resources,      # ADD
    relationships=relationships,
)
```
  </action>
  <verify>
cd /home/daharoni/dev/ontology-hub/backend && python -c "
from app.services.parsers.entity_parser import EntityParser
ep = EntityParser()
# Test with minimal files dict including dashboards and resources
result = ep.parse_all({
    'categories': [], 'properties': [], 'subobjects': [],
    'modules': [], 'bundles': [], 'templates': [],
    'dashboards': [('dashboards/Test.json', {'id': 'Test', 'label': 'Test'})],
    'resources': [('resources/Person/John.json', {'id': 'Person/John', 'category': 'Person'})]
})
assert len(result.dashboards) == 1
assert len(result.resources) == 1
print('parse_all handles dashboards and resources OK')
"
  </verify>
  <done>parse_all parses dashboards and resources arrays and includes them in returned ParsedEntities</done>
</task>

</tasks>

<verification>
Run from backend directory:

```bash
cd /home/daharoni/dev/ontology-hub/backend

# Type check
uv run mypy app/services/parsers/entity_parser.py --ignore-missing-imports

# Unit tests (if any exist)
uv run pytest tests/ -v -k "parser" --tb=short

# Full integration test
python -c "
from app.services.parsers.entity_parser import EntityParser, ParsedEntities
from app.models.v2 import Dashboard, Resource

ep = EntityParser()

# Test parse_dashboard
dash = ep.parse_dashboard({'id': 'Test', 'label': 'Test Dashboard', 'pages': []}, 'dashboards/Test.json')
assert dash.entity_key == 'Test'
assert dash.label == 'Test Dashboard'

# Test parse_resource
res = ep.parse_resource({'id': 'Person/John', 'category': 'Person', 'label': 'John'}, 'resources/Person/John.json')
assert res.entity_key == 'Person/John'
assert res.category_key == 'Person'

# Test parse_all integration
result = ep.parse_all({
    'categories': [], 'properties': [], 'subobjects': [],
    'modules': [('modules/M1.json', {'id': 'M1', 'dashboards': ['Test']})],
    'bundles': [('bundles/B1.json', {'id': 'B1', 'dashboards': ['Test']})],
    'templates': [],
    'dashboards': [('dashboards/Test.json', {'id': 'Test'})],
    'resources': [('resources/Person/John.json', {'id': 'Person/John', 'category': 'Person'})]
})

counts = result.entity_counts()
assert counts['dashboards'] == 1
assert counts['resources'] == 1

# Check relationship extraction
rel_types = [r.type for r in result.relationships]
assert 'module_dashboard' in rel_types
assert 'bundle_dashboard' in rel_types

print('All EntityParser tests passed!')
"
```
</verification>

<success_criteria>
1. Dashboard and Resource imported in entity_parser.py
2. parse_dashboard() method exists and returns Dashboard instance
3. parse_resource() method exists and returns Resource instance with category_key
4. ParsedEntities includes dashboards and resources fields
5. entity_counts() includes dashboards and resources counts
6. parse_module() extracts module_dashboard relationships
7. parse_bundle() extracts bundle_dashboard relationships
8. parse_all() processes dashboards and resources arrays
</success_criteria>

<output>
After completion, create `.planning/phases/25-backend-ingest-pipeline/25-01-SUMMARY.md`
</output>
