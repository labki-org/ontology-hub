---
phase: 09-ingest-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/parsers/__init__.py
  - backend/app/services/parsers/entity_parser.py
autonomous: true

must_haves:
  truths:
    - "All 6 entity types can be parsed from JSON"
    - "Relationships are extracted from entity JSON for separate tables"
    - "Entity key and source path are captured for each entity"
  artifacts:
    - path: "backend/app/services/parsers/entity_parser.py"
      provides: "EntityParser class with parse methods for all entity types"
      exports: ["EntityParser", "ParsedEntities", "PendingRelationship"]
    - path: "backend/app/services/parsers/__init__.py"
      provides: "Package init with exports"
  key_links:
    - from: "entity_parser.py"
      to: "app.models.v2.*"
      via: "Model imports for entity creation"
      pattern: "from app.models.v2 import"
---

<objective>
Create entity parser service that converts raw JSON from labki-schemas repo into v2.0 model instances and extracts relationships for separate tables.

Purpose: ING-04 and ING-05 require parsing entity files and extracting relationships. This separates parsing from database operations for clean architecture.
Output: EntityParser class that parses all 6 entity types and extracts pending relationships.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ingest-pipeline/09-RESEARCH.md

# v2.0 models for entity creation
@backend/app/models/v2/__init__.py
@backend/app/models/v2/category.py
@backend/app/models/v2/relationships.py
@backend/app/models/v2/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityParser service</name>
  <files>
    backend/app/services/parsers/__init__.py
    backend/app/services/parsers/entity_parser.py
  </files>
  <action>
Create parsers package with EntityParser class that handles all 6 entity types.

**entity_parser.py:**

Define dataclasses for structured output:
- `PendingRelationship`: Holds relationship data before UUID resolution
  - type: str ("category_parent", "category_property", "module_entity", "bundle_module")
  - source_key: str (entity_key of the source entity)
  - target_key: str (entity_key of the target entity)
  - extra: dict (additional fields like is_required, entity_type)

- `ParsedEntities`: Container for all parsed data
  - categories: list[Category]
  - properties: list[Property]
  - subobjects: list[Subobject]
  - modules: list[Module]
  - bundles: list[Bundle]
  - templates: list[Template]
  - relationships: list[PendingRelationship]

**EntityParser class methods:**

1. `parse_category(content: dict, source_path: str) -> tuple[Category, list[PendingRelationship]]`
   - entity_key = content["id"]
   - Extract parents[] -> PendingRelationship(type="category_parent", source_key=entity_key, target_key=parent_key)
   - Extract required_properties[] -> PendingRelationship(type="category_property", ..., extra={"is_required": True})
   - Extract optional_properties[] -> PendingRelationship(type="category_property", ..., extra={"is_required": False})
   - Return Category instance with label, description, canonical_json=content

2. `parse_property(content: dict, source_path: str) -> Property`
   - entity_key = content["id"]
   - Return Property instance (no relationships extracted)

3. `parse_subobject(content: dict, source_path: str) -> Subobject`
   - entity_key = content["id"]
   - Return Subobject instance (no relationships extracted)

4. `parse_module(content: dict, source_path: str) -> tuple[Module, list[PendingRelationship]]`
   - entity_key = content["id"]
   - Extract categories[] -> PendingRelationship(type="module_entity", ..., extra={"entity_type": EntityType.CATEGORY})
   - Extract properties[] -> PendingRelationship(type="module_entity", ..., extra={"entity_type": EntityType.PROPERTY})
   - Extract subobjects[] -> PendingRelationship(type="module_entity", ..., extra={"entity_type": EntityType.SUBOBJECT})
   - Extract templates[] -> PendingRelationship(type="module_entity", ..., extra={"entity_type": EntityType.TEMPLATE})
   - Return Module instance with version, label, description, canonical_json=content

5. `parse_bundle(content: dict, source_path: str) -> tuple[Bundle, list[PendingRelationship]]`
   - entity_key = content["id"]
   - Extract modules[] -> PendingRelationship(type="bundle_module", source_key=entity_key, target_key=module_key)
   - Return Bundle instance

6. `parse_template(content: dict, source_path: str) -> Template`
   - entity_key = content["id"] (may include "/" for nested templates like "Property/Page")
   - Return Template instance with wikitext field

7. `parse_all(files: dict[str, list[tuple[str, dict]]]) -> ParsedEntities`
   - files = {"categories": [(path, content), ...], "properties": [...], ...}
   - Route to appropriate parser based on entity type
   - Aggregate all entities and relationships into ParsedEntities

**__init__.py:**
```python
"""Entity parsing services for v2.0 ingest pipeline."""
from app.services.parsers.entity_parser import (
    EntityParser,
    ParsedEntities,
    PendingRelationship,
)

__all__ = ["EntityParser", "ParsedEntities", "PendingRelationship"]
```

Use the v2.0 model imports:
```python
from app.models.v2 import (
    Category, Property, Subobject, Module, Bundle, Template,
    EntityType,
)
```
  </action>
  <verify>
Run Python import test:
```bash
cd /home/daharoni/dev/ontology-hub/backend
python -c "from app.services.parsers import EntityParser, ParsedEntities; print('OK')"
```
  </verify>
  <done>EntityParser class can parse all 6 entity types and extract relationships</done>
</task>

<task type="auto">
  <name>Task 2: Add entity count method</name>
  <files>backend/app/services/parsers/entity_parser.py</files>
  <action>
Add method to ParsedEntities dataclass for generating entity counts dict:

```python
def entity_counts(self) -> dict[str, int]:
    """Return counts for each entity type (for OntologyVersion tracking)."""
    return {
        "categories": len(self.categories),
        "properties": len(self.properties),
        "subobjects": len(self.subobjects),
        "modules": len(self.modules),
        "bundles": len(self.bundles),
        "templates": len(self.templates),
        "relationships": len(self.relationships),
    }
```

This will be used by the ingest service to populate OntologyVersion.entity_counts.
  </action>
  <verify>
Run Python test:
```bash
cd /home/daharoni/dev/ontology-hub/backend
python -c "
from app.services.parsers import ParsedEntities
p = ParsedEntities([], [], [], [], [], [], [])
print(p.entity_counts())
"
```
Expected output: `{'categories': 0, 'properties': 0, ...}`
  </verify>
  <done>ParsedEntities.entity_counts() returns dict for OntologyVersion tracking</done>
</task>

</tasks>

<verification>
1. `from app.services.parsers import EntityParser, ParsedEntities, PendingRelationship` succeeds
2. EntityParser has parse methods for all 6 entity types
3. ParsedEntities.entity_counts() returns dict with all entity type counts
4. PendingRelationship stores relationship data with type, keys, and extra fields
</verification>

<success_criteria>
- EntityParser class parses Category, Property, Subobject, Module, Bundle, Template
- Category parser extracts parents, required_properties, optional_properties as PendingRelationships
- Module parser extracts categories, properties, subobjects, templates as PendingRelationships
- Bundle parser extracts modules as PendingRelationships
- ParsedEntities provides entity_counts() for OntologyVersion
</success_criteria>

<output>
After completion, create `.planning/phases/09-ingest-pipeline/09-02-SUMMARY.md`
</output>
