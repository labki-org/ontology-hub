---
phase: 08-database-foundation
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - backend/app/models/v2/relationships.py
  - backend/app/models/v2/category_property_effective.py
  - backend/app/models/v2/__init__.py
autonomous: true

must_haves:
  truths:
    - "Category parent relationships are queryable via category_parent table"
    - "Property assignments to categories are stored with is_required flag"
    - "Module membership is tracked for all entity types via module_entity table"
    - "Bundle composition is tracked via bundle_module table"
    - "category_property_effective view SQL computes inherited properties with source and depth"
  artifacts:
    - path: "backend/app/models/v2/relationships.py"
      provides: "All relationship tables: CategoryParent, CategoryProperty, ModuleEntity, BundleModule"
      exports: ["CategoryParent", "CategoryProperty", "ModuleEntity", "BundleModule"]
    - path: "backend/app/models/v2/category_property_effective.py"
      provides: "Materialized view definition and refresh helper"
      exports: ["CATEGORY_PROPERTY_EFFECTIVE_SQL", "CategoryPropertyEffective"]
  key_links:
    - from: "backend/app/models/v2/relationships.py"
      to: "backend/app/models/v2/category.py"
      via: "Foreign key references"
      pattern: "foreign_key=\"category\\.id\""
    - from: "backend/app/models/v2/relationships.py"
      to: "backend/app/models/v2/property.py"
      via: "Foreign key references"
      pattern: "foreign_key=\"property\\.id\""
---

<objective>
Create relationship tables (category_parent, category_property, module_entity, bundle_module) and the category_property_effective materialized view SQL.

Purpose: Enable normalized storage of entity relationships instead of JSONB arrays (v1.0 pattern). The materialized view precomputes inherited properties with provenance for fast reads.

Output: SQLModel relationship tables and raw SQL for materialized view creation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-database-foundation/08-CONTEXT.md
@.planning/phases/08-database-foundation/08-RESEARCH.md
@.planning/phases/08-database-foundation/08-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create relationship tables</name>
  <files>backend/app/models/v2/relationships.py</files>
  <action>
Create relationship tables for normalized entity connections:

**1. CategoryParent (category inheritance):**
```python
class CategoryParent(SQLModel, table=True):
    __tablename__ = "category_parent"

    category_id: uuid.UUID = Field(foreign_key="category.id", primary_key=True)
    parent_id: uuid.UUID = Field(foreign_key="category.id", primary_key=True)
```
Represents: "category X inherits from parent Y"

**2. CategoryProperty (direct property assignments):**
```python
class CategoryProperty(SQLModel, table=True):
    __tablename__ = "category_property"

    category_id: uuid.UUID = Field(foreign_key="category.id", primary_key=True)
    property_id: uuid.UUID = Field(foreign_key="property.id", primary_key=True)
    is_required: bool = False
```
Only stores DIRECT property assignments (not inherited). Origin is always "direct" here; inherited comes from the view.

**3. ModuleEntity (module membership for all entity types):**
```python
class ModuleEntity(SQLModel, table=True):
    __tablename__ = "module_entity"

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    module_id: uuid.UUID = Field(foreign_key="module.id", index=True)
    entity_type: EntityType  # category, property, subobject, module, bundle, template
    entity_key: str = Field(index=True)  # References entity by key, not FK
```
Uses entity_key instead of FK because entity could be any of 6 types.

**4. BundleModule (bundle-to-module composition):**
```python
class BundleModule(SQLModel, table=True):
    __tablename__ = "bundle_module"

    bundle_id: uuid.UUID = Field(foreign_key="bundle.id", primary_key=True)
    module_id: uuid.UUID = Field(foreign_key="module.id", primary_key=True)
```

Add appropriate imports for uuid, EntityType, etc.
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub && python -c "
from backend.app.models.v2.relationships import (
    CategoryParent, CategoryProperty, ModuleEntity, BundleModule
)
print('Relationship models OK')
print(f'CategoryParent table: {CategoryParent.__tablename__}')
print(f'ModuleEntity table: {ModuleEntity.__tablename__}')
"
```
  </verify>
  <done>All 4 relationship tables created with proper foreign keys and composite primary keys</done>
</task>

<task type="auto">
  <name>Task 2: Create materialized view definition</name>
  <files>backend/app/models/v2/category_property_effective.py</files>
  <action>
Create the category_property_effective materialized view definition:

**1. SQL constant for view creation:**
```python
CATEGORY_PROPERTY_EFFECTIVE_SQL = """
CREATE MATERIALIZED VIEW IF NOT EXISTS category_property_effective AS
WITH RECURSIVE inheritance_chain AS (
    -- Base case: direct parents
    SELECT
        cp.category_id,
        cp.parent_id,
        1 as depth,
        ARRAY[cp.parent_id] as path
    FROM category_parent cp

    UNION ALL

    -- Recursive case: grandparents and beyond
    SELECT
        ic.category_id,
        cp.parent_id,
        ic.depth + 1,
        ic.path || cp.parent_id
    FROM inheritance_chain ic
    JOIN category_parent cp ON cp.category_id = ic.parent_id
    WHERE NOT cp.parent_id = ANY(ic.path)  -- Prevent cycles
),
all_properties AS (
    -- Direct properties (depth = 0)
    SELECT
        cp.category_id,
        cp.property_id,
        cp.category_id as source_category_id,
        0 as depth,
        cp.is_required
    FROM category_property cp

    UNION ALL

    -- Inherited properties
    SELECT
        ic.category_id,
        cp.property_id,
        cp.category_id as source_category_id,
        ic.depth,
        cp.is_required
    FROM inheritance_chain ic
    JOIN category_property cp ON cp.category_id = ic.parent_id
)
SELECT DISTINCT ON (category_id, property_id)
    category_id,
    property_id,
    source_category_id,
    depth,
    is_required
FROM all_properties
ORDER BY category_id, property_id, depth;
"""

CATEGORY_PROPERTY_EFFECTIVE_INDEX_SQL = """
CREATE UNIQUE INDEX IF NOT EXISTS idx_cpe_category_property
ON category_property_effective (category_id, property_id);
"""

CATEGORY_PROPERTY_EFFECTIVE_REFRESH_SQL = """
REFRESH MATERIALIZED VIEW CONCURRENTLY category_property_effective;
"""

DROP_CATEGORY_PROPERTY_EFFECTIVE_SQL = """
DROP MATERIALIZED VIEW IF EXISTS category_property_effective;
"""
```

**2. Read-only model for ORM access:**
```python
class CategoryPropertyEffective(SQLModel):
    """Read-only model for querying the materialized view.

    This is NOT a table=True model. It's used for type hints and ORM queries
    against the materialized view created by raw SQL.
    """
    category_id: uuid.UUID
    property_id: uuid.UUID
    source_category_id: uuid.UUID
    depth: int
    is_required: bool
```

**3. Async refresh helper:**
```python
async def refresh_category_property_effective(session: AsyncSession) -> None:
    """Refresh the materialized view concurrently (non-blocking)."""
    from sqlalchemy import text
    await session.execute(text(CATEGORY_PROPERTY_EFFECTIVE_REFRESH_SQL))
    await session.commit()
```
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub && python -c "
from backend.app.models.v2.category_property_effective import (
    CATEGORY_PROPERTY_EFFECTIVE_SQL,
    CategoryPropertyEffective,
    refresh_category_property_effective
)
print('View definition OK')
print(f'SQL length: {len(CATEGORY_PROPERTY_EFFECTIVE_SQL)} chars')
assert 'WITH RECURSIVE' in CATEGORY_PROPERTY_EFFECTIVE_SQL
assert 'DISTINCT ON' in CATEGORY_PROPERTY_EFFECTIVE_SQL
print('SQL contains required clauses')
"
```
  </verify>
  <done>Materialized view SQL with recursive CTE, read-only model, and refresh helper function</done>
</task>

<task type="auto">
  <name>Task 3: Update v2 __init__.py with relationship exports</name>
  <files>backend/app/models/v2/__init__.py</files>
  <action>
Update the v2 models __init__.py to include relationship table exports:

Add imports and re-exports for:
- CategoryParent, CategoryProperty, ModuleEntity, BundleModule (from relationships.py)
- CategoryPropertyEffective, CATEGORY_PROPERTY_EFFECTIVE_SQL, refresh_category_property_effective (from category_property_effective.py)

Ensure all exports are in __all__ list.
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub && python -c "
from backend.app.models.v2 import (
    # Entity models
    Category, Property, Subobject, Module, Bundle, Template,
    OntologyVersion, EntityType, IngestStatus,
    # Relationship models
    CategoryParent, CategoryProperty, ModuleEntity, BundleModule,
    # View
    CategoryPropertyEffective, CATEGORY_PROPERTY_EFFECTIVE_SQL
)
print('All v2 models and relationships importable')
"
```
  </verify>
  <done>All relationship tables and view exports available from backend.app.models.v2</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Import check:**
```bash
cd /home/daharoni/dev/ontology-hub && python -c "
from backend.app.models.v2 import (
    CategoryParent, CategoryProperty, ModuleEntity, BundleModule,
    CategoryPropertyEffective, CATEGORY_PROPERTY_EFFECTIVE_SQL
)
print('All relationship imports successful')
"
```

2. **Foreign key check:**
```bash
cd /home/daharoni/dev/ontology-hub && python -c "
from backend.app.models.v2.relationships import CategoryParent, CategoryProperty
# Verify FK references exist in model definition
import inspect
src = inspect.getsource(CategoryParent)
assert 'category.id' in src
src = inspect.getsource(CategoryProperty)
assert 'property.id' in src
print('Foreign keys verified')
"
```

3. **SQL validity check:**
```bash
cd /home/daharoni/dev/ontology-hub && python -c "
from backend.app.models.v2.category_property_effective import CATEGORY_PROPERTY_EFFECTIVE_SQL
# Basic SQL syntax checks
assert 'CREATE MATERIALIZED VIEW' in CATEGORY_PROPERTY_EFFECTIVE_SQL
assert 'WITH RECURSIVE' in CATEGORY_PROPERTY_EFFECTIVE_SQL
assert 'inheritance_chain' in CATEGORY_PROPERTY_EFFECTIVE_SQL
assert 'DISTINCT ON' in CATEGORY_PROPERTY_EFFECTIVE_SQL
print('Materialized view SQL structure verified')
"
```
</verification>

<success_criteria>
- CategoryParent table with category_id and parent_id foreign keys
- CategoryProperty table with category_id, property_id, is_required
- ModuleEntity table with module_id, entity_type, entity_key
- BundleModule table with bundle_id and module_id foreign keys
- Materialized view SQL with recursive CTE for inheritance traversal
- CategoryPropertyEffective read-only model for ORM queries
- All relationship exports available from backend.app.models.v2
</success_criteria>

<output>
After completion, create `.planning/phases/08-database-foundation/08-02-SUMMARY.md`
</output>
