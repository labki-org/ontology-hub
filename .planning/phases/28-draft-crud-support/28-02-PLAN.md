---
phase: 28-draft-crud-support
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/resource_validation.py
  - backend/app/routers/draft_changes.py
autonomous: true

must_haves:
  truths:
    - "Resource CREATE without category field returns 400"
    - "Resource CREATE with unknown property field returns 400"
    - "Resource UPDATE validates effective state after patch application"
  artifacts:
    - path: "backend/app/services/resource_validation.py"
      provides: "Resource field validation service"
      exports: ["validate_resource_fields", "get_category_effective_properties"]
    - path: "backend/app/routers/draft_changes.py"
      provides: "Resource validation integration in add_draft_change"
      contains: "validate_resource_fields"
  key_links:
    - from: "backend/app/routers/draft_changes.py"
      to: "backend/app/services/resource_validation.py"
      via: "import validate_resource_fields"
      pattern: "from app\\.services\\.resource_validation import"
    - from: "backend/app/services/resource_validation.py"
      to: "category_property_effective"
      via: "SQL query"
      pattern: "category_property_effective"
---

<objective>
Implement resource field validation that checks property fields against the category's effective properties.

Purpose: Ensure resources only contain valid properties for their category, supporting draft-aware resolution.
Output: Working resource validation that rejects unknown property fields on CREATE and UPDATE.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-draft-crud-support/28-RESEARCH.md
@backend/app/routers/draft_changes.py
@backend/app/models/v2/category_property_effective.py
@backend/app/services/module_derived.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resource validation service</name>
  <files>backend/app/services/resource_validation.py</files>
  <action>
Create a new service file for resource field validation. This service:
- Gets effective properties for a category (using materialized view)
- Supports draft-aware resolution (draft-created or draft-modified categories)
- Validates resource fields against valid property keys

```python
"""Resource field validation service.

Validates resource property fields against the category's effective properties,
supporting draft-aware resolution when a draft modifies the category.
"""

from uuid import UUID

from sqlalchemy import text
from sqlmodel.ext.asyncio.session import AsyncSession

from app.models.v2 import ChangeType, DraftChange

# Reserved keys that are NOT property fields
# These are either structural fields (id, label, description, category)
# or internal fields (entity_key, source_path)
RESERVED_KEYS = frozenset({"id", "label", "description", "category", "entity_key", "source_path"})


async def get_category_effective_properties(
    session: AsyncSession,
    category_key: str,
    draft_id: UUID | None = None,
) -> set[str]:
    """Get effective property keys for a category.

    Checks the category_property_effective materialized view for canonical categories,
    and draft changes for draft-created or draft-modified categories.

    Args:
        session: Database session
        category_key: Category key to look up
        draft_id: Optional draft ID for draft-aware resolution

    Returns:
        Set of valid property keys for this category
    """
    from sqlmodel import select

    from app.models.v2 import Category

    properties: set[str] = set()

    # 1. Check for draft-created category first
    if draft_id:
        draft_query = (
            select(DraftChange)
            .where(DraftChange.draft_id == draft_id)
            .where(DraftChange.entity_type == "category")
            .where(DraftChange.entity_key == category_key)
        )
        result = await session.execute(draft_query)
        draft_change = result.scalar_one_or_none()

        if draft_change and draft_change.change_type == ChangeType.CREATE:
            # Draft-created category: use replacement_json
            effective = draft_change.replacement_json or {}
            # Categories have required_properties and optional_properties lists
            properties.update(effective.get("required_properties", []))
            properties.update(effective.get("optional_properties", []))
            return properties

    # 2. Query canonical via materialized view
    # Join with properties table to get entity_key (property name)
    query = text("""
        SELECT p.entity_key
        FROM category_property_effective cpe
        JOIN properties p ON p.id = cpe.property_id
        JOIN categories c ON c.id = cpe.category_id
        WHERE c.entity_key = :category_key
    """)
    result = await session.execute(query, {"category_key": category_key})
    for row in result.fetchall():
        properties.add(row[0])

    # 3. If draft modifies the category (UPDATE), we'd need to apply patches
    # For now, we use the canonical + inherited properties from the view
    # Draft category modifications to property lists are complex edge cases
    # (This could be enhanced later if needed)

    # 4. If no properties found and no draft change, check if category exists
    if not properties and draft_id:
        # Category might be draft-created without properties defined yet
        # Return empty set (all fields would be invalid except reserved)
        pass

    return properties


async def get_canonical_category_exists(
    session: AsyncSession,
    category_key: str,
) -> bool:
    """Check if category exists in canonical database.

    Args:
        session: Database session
        category_key: Category key to check

    Returns:
        True if category exists, False otherwise
    """
    from sqlmodel import select

    from app.models.v2 import Category

    result = await session.execute(
        select(Category).where(Category.entity_key == category_key)
    )
    return result.scalar_one_or_none() is not None


async def get_draft_category_exists(
    session: AsyncSession,
    draft_id: UUID,
    category_key: str,
) -> bool:
    """Check if category exists as a CREATE in the draft.

    Args:
        session: Database session
        draft_id: Draft ID to check
        category_key: Category key to check

    Returns:
        True if category is created in draft, False otherwise
    """
    from sqlmodel import select

    result = await session.execute(
        select(DraftChange)
        .where(DraftChange.draft_id == draft_id)
        .where(DraftChange.entity_type == "category")
        .where(DraftChange.entity_key == category_key)
        .where(DraftChange.change_type == ChangeType.CREATE)
    )
    return result.scalar_one_or_none() is not None


async def validate_resource_fields(
    session: AsyncSession,
    resource_json: dict,
    draft_id: UUID | None = None,
) -> str | None:
    """Validate resource property fields against category's effective properties.

    Per CONTEXT.md decisions:
    - Resource creation requires category_key upfront
    - Validate resource fields against category properties immediately (reject invalid)
    - Resource key is the "id" field

    Args:
        session: Database session
        resource_json: Resource JSON with category and property fields
        draft_id: Optional draft ID for draft-aware category resolution

    Returns:
        Error message if validation fails, None if valid
    """
    # 1. Check category field exists
    category_key = resource_json.get("category")
    if not category_key:
        return "Resource requires 'category' field"

    # 2. Check category exists (canonical or in draft)
    category_exists = await get_canonical_category_exists(session, category_key)
    if not category_exists and draft_id:
        category_exists = await get_draft_category_exists(session, draft_id, category_key)

    if not category_exists:
        return f"Category '{category_key}' does not exist"

    # 3. Get effective properties for the category
    valid_properties = await get_category_effective_properties(
        session, category_key, draft_id
    )

    # 4. Check all non-reserved fields are valid properties
    provided_fields = set(resource_json.keys()) - RESERVED_KEYS
    invalid_fields = provided_fields - valid_properties

    if invalid_fields:
        # Sort for consistent error messages
        invalid_list = sorted(invalid_fields)
        if len(invalid_list) == 1:
            return f"Unknown property '{invalid_list[0]}' for category '{category_key}'"
        else:
            return f"Unknown properties {invalid_list} for category '{category_key}'"

    return None
```
  </action>
  <verify>
1. File exists: `ls -la backend/app/services/resource_validation.py`
2. Functions exported: `grep "^async def" backend/app/services/resource_validation.py`
3. Python syntax valid: `python -m py_compile backend/app/services/resource_validation.py`
  </verify>
  <done>
- resource_validation.py service created
- get_category_effective_properties queries materialized view with draft awareness
- validate_resource_fields validates category exists and fields are valid properties
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate resource validation into draft changes router</name>
  <files>backend/app/routers/draft_changes.py</files>
  <action>
1. Add import for the validation function at the top of the file (after other service imports):

```python
from app.services.resource_validation import validate_resource_fields
```

2. In add_draft_change(), add resource validation for CREATE. After the dashboard validation block (added in Plan 01), add:

```python
# Resource creation validation
if change_in.entity_type == "resource" and change_in.change_type == ChangeType.CREATE:
    error = await validate_resource_fields(
        session,
        change_in.replacement_json or {},
        draft_id=draft.id,
    )
    if error:
        raise HTTPException(status_code=400, detail=error)
```

3. For UPDATE operations on resources, we need to validate after patch application. Find the section where UPDATE on draft-created entities applies patches (around line 331-346), and add validation after the patch is applied. For UPDATE on canonical resources, validate the effective state.

In the existing UPDATE handling block, add resource validation:

For UPDATE on draft-created resource (inside "if existing_change.change_type == ChangeType.CREATE:" block, after patch application):
```python
# After: existing_change.replacement_json = updated_json
# Add validation for resource updates
if change_in.entity_type == "resource":
    error = await validate_resource_fields(
        session,
        updated_json,
        draft_id=draft.id,
    )
    if error:
        raise HTTPException(status_code=400, detail=error)
```

For UPDATE on canonical resource (in the else block for canonical updates), compute effective state and validate. This is more complex since we need to apply the patch to canonical_json first. Add after patches are merged:
```python
# After: change = existing_change (for canonical UPDATE merge)
# Validate resource UPDATE against effective state
if change_in.entity_type == "resource":
    import jsonpatch
    from app.models.v2 import Resource as ResourceModel

    # Get canonical resource JSON
    resource_query = select(ResourceModel).where(
        ResourceModel.entity_key == change_in.entity_key
    )
    resource_result = await session.execute(resource_query)
    resource = resource_result.scalar_one_or_none()
    if resource:
        try:
            patch = jsonpatch.JsonPatch(existing_change.patch or [])
            effective_json = patch.apply(resource.canonical_json.copy())
            error = await validate_resource_fields(
                session,
                effective_json,
                draft_id=draft.id,
            )
            if error:
                raise HTTPException(status_code=400, detail=error)
        except jsonpatch.JsonPatchException:
            # Patch application failed - this will be caught during apply
            pass
```

Note: The UPDATE validation for canonical resources is best-effort. If patch applies cleanly, validate the result. Patch conflicts will be caught at apply time anyway.
  </action>
  <verify>
1. Import added: `grep "resource_validation" backend/app/routers/draft_changes.py`
2. CREATE validation: `grep -A5 'entity_type == "resource".*CREATE' backend/app/routers/draft_changes.py`
3. Run tests: `cd /home/daharoni/dev/ontology-hub && python -m pytest backend/tests/test_draft_changes.py -v --tb=short`
  </verify>
  <done>
- validate_resource_fields imported from service
- Resource CREATE calls validation with draft_id
- Resource UPDATE validates effective state after patch
- Invalid fields return 400 with descriptive message
  </done>
</task>

</tasks>

<verification>
1. Resource CREATE without category returns 400: "Resource requires 'category' field"
2. Resource CREATE with nonexistent category returns 400: "Category 'X' does not exist"
3. Resource CREATE with unknown property returns 400: "Unknown property 'X' for category 'Y'"
4. Resource UPDATE with invalid field returns 400
5. Existing draft change tests pass (no regressions)
</verification>

<success_criteria>
- resource_validation.py service created with proper draft-aware logic
- validate_resource_fields integrated into add_draft_change for CREATE
- UPDATE operations validate effective state
- Error messages clearly indicate which field/category is problematic
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/28-draft-crud-support/28-02-SUMMARY.md`
</output>
