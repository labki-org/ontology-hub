---
phase: 26-backend-api-endpoints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/schemas/entity.py
  - backend/app/routers/entities.py
autonomous: true

must_haves:
  truths:
    - "GET /dashboards returns paginated list with draft overlay"
    - "GET /dashboards/{key} returns dashboard with pages array"
    - "GET /resources returns paginated list with optional category filter"
    - "GET /resources/{key:path} returns resource with dynamic properties"
    - "GET /categories/{key}/resources returns resources for that category"
    - "All endpoints apply draft overlay and include change_status"
  artifacts:
    - path: "backend/app/schemas/entity.py"
      provides: "DashboardPage, DashboardDetailResponse, ResourceDetailResponse models"
      contains: "class DashboardDetailResponse"
    - path: "backend/app/routers/entities.py"
      provides: "Dashboard and Resource API endpoints"
      contains: "async def list_dashboards"
  key_links:
    - from: "backend/app/routers/entities.py"
      to: "backend/app/models/v2"
      via: "model imports"
      pattern: "from app.models.v2 import.*Dashboard.*Resource"
    - from: "backend/app/routers/entities.py"
      to: "DraftContextDep"
      via: "draft overlay service"
      pattern: "draft_ctx.apply_overlay"
---

<objective>
Add list and detail endpoints for Dashboard and Resource entities.

Purpose: Complete the API layer for new entity types, enabling frontend to display dashboards and resources with full draft support.
Output: 5 new API endpoints following exact patterns established by existing entities.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-backend-api-endpoints/26-RESEARCH.md

# Key source files to follow patterns from:
@backend/app/routers/entities.py (existing endpoint patterns)
@backend/app/schemas/entity.py (existing response schemas)
@backend/app/models/v2/dashboard.py (Dashboard model)
@backend/app/models/v2/resource.py (Resource model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add response schemas for Dashboard and Resource</name>
  <files>backend/app/schemas/entity.py</files>
  <action>
Add three new Pydantic models to entity.py following existing patterns:

1. **DashboardPage** - nested model for dashboard page data:
   ```python
   class DashboardPage(BaseModel):
       """Dashboard page with wikitext content."""
       name: str = Field(description="Page name (empty string for root page)")
       wikitext: str = Field(description="MediaWiki wikitext content")
   ```

2. **DashboardDetailResponse** - following TemplateDetailResponse pattern:
   - entity_key: str
   - label: str
   - description: str | None = None
   - pages: list[DashboardPage] = Field(default_factory=list)
   - change_status: ChangeStatus | None with validation_alias="_change_status"
   - deleted: bool with validation_alias="_deleted"
   - model_config = ConfigDict(populate_by_name=True)

3. **ResourceDetailResponse** - with dynamic properties dict:
   - entity_key: str
   - label: str
   - description: str | None = None
   - category_key: str = Field(description="Category this resource belongs to")
   - properties: dict[str, Any] = Field(default_factory=dict, description="Dynamic property values")
   - change_status: ChangeStatus | None with validation_alias="_change_status"
   - deleted: bool with validation_alias="_deleted"
   - model_config = ConfigDict(populate_by_name=True)

Import `Any` from typing at the top of the file.
  </action>
  <verify>
Run: `cd /home/daharoni/dev/ontology-hub && python -c "from app.schemas.entity import DashboardPage, DashboardDetailResponse, ResourceDetailResponse; print('OK')"`
  </verify>
  <done>Three new schema models importable with correct fields and validation aliases.</done>
</task>

<task type="auto">
  <name>Task 2: Add Dashboard and Resource endpoints to entities router</name>
  <files>backend/app/routers/entities.py</files>
  <action>
Add 5 new endpoints following the exact patterns from existing endpoints. Study list_categories and get_template as reference implementations.

**1. Add imports at top of file:**
```python
from app.models.v2 import (
    # ... existing imports ...
    Dashboard,
    Resource,
)
from app.schemas.entity import (
    # ... existing imports ...
    DashboardDetailResponse,
    DashboardPage,
    ResourceDetailResponse,
)
```

**2. Add Dashboard section after Template section (around line 687):**

```python
# -----------------------------------------------------------------------------
# Dashboard endpoints
# -----------------------------------------------------------------------------

@router.get("/dashboards", response_model=EntityListResponse)
@limiter.limit(RATE_LIMITS["entity_list"])
async def list_dashboards(
    request: Request,
    session: SessionDep,
    draft_ctx: DraftContextDep,
    cursor: str | None = Query(None, description="Last entity_key from previous page for pagination"),
    limit: int = Query(20, ge=1, le=100, description="Max items per page"),
) -> EntityListResponse:
    """List dashboards with cursor-based pagination and draft overlay.

    Rate limited to 100/minute per IP.
    """
    # Follow exact pattern from list_categories (lines 97-154)
    query = select(Dashboard).order_by(Dashboard.entity_key)
    if cursor:
        query = query.where(Dashboard.entity_key > cursor)
    query = query.limit(limit + 1)

    result = await session.execute(query)
    dashboards = list(result.scalars().all())

    has_next = len(dashboards) > limit
    if has_next:
        dashboards = dashboards[:limit]

    items: list[EntityWithStatus] = []
    for dash in dashboards:
        effective = await draft_ctx.apply_overlay(dash, "dashboard", dash.entity_key)
        if effective:
            items.append(EntityWithStatus.model_validate(effective))

    draft_creates = await draft_ctx.get_draft_creates("dashboard")
    for create in draft_creates:
        items.append(EntityWithStatus.model_validate(create))

    items.sort(key=lambda x: x.entity_key)
    next_cursor = items[-1].entity_key if has_next and items else None

    return EntityListResponse(items=items, next_cursor=next_cursor, has_next=has_next)


@router.get("/dashboards/{entity_key}", response_model=DashboardDetailResponse)
@limiter.limit(RATE_LIMITS["entity_read"])
async def get_dashboard(
    request: Request,
    entity_key: str,
    session: SessionDep,
    draft_ctx: DraftContextDep,
) -> DashboardDetailResponse:
    """Get dashboard detail with pages.

    Rate limited to 200/minute per IP.
    """
    query = select(Dashboard).where(Dashboard.entity_key == entity_key)
    result = await session.execute(query)
    dashboard = result.scalar_one_or_none()

    effective = await draft_ctx.apply_overlay(dashboard, "dashboard", entity_key)

    if not effective:
        raise HTTPException(status_code=404, detail="Dashboard not found")

    # Extract pages from canonical_json (stored in effective after overlay)
    pages_data = effective.get("pages", [])
    pages = [DashboardPage(name=p.get("name", ""), wikitext=p.get("wikitext", "")) for p in pages_data]

    return DashboardDetailResponse(
        entity_key=effective.get("entity_key", entity_key),
        label=effective.get("label", ""),
        description=effective.get("description"),
        pages=pages,
        change_status=effective.get("_change_status"),
        deleted=effective.get("_deleted", False),
    )
```

**3. Add Resource section after Dashboard section:**

```python
# -----------------------------------------------------------------------------
# Resource endpoints
# -----------------------------------------------------------------------------

@router.get("/resources", response_model=EntityListResponse)
@limiter.limit(RATE_LIMITS["entity_list"])
async def list_resources(
    request: Request,
    session: SessionDep,
    draft_ctx: DraftContextDep,
    cursor: str | None = Query(None, description="Last entity_key from previous page for pagination"),
    limit: int = Query(20, ge=1, le=100, description="Max items per page"),
    category: str | None = Query(None, description="Filter by category key"),
) -> EntityListResponse:
    """List resources with cursor-based pagination, optional category filter, and draft overlay.

    Rate limited to 100/minute per IP.
    """
    query = select(Resource).order_by(Resource.entity_key)

    if category:
        query = query.where(Resource.category_key == category)
    if cursor:
        query = query.where(Resource.entity_key > cursor)

    query = query.limit(limit + 1)

    result = await session.execute(query)
    resources = list(result.scalars().all())

    has_next = len(resources) > limit
    if has_next:
        resources = resources[:limit]

    items: list[EntityWithStatus] = []
    for res in resources:
        effective = await draft_ctx.apply_overlay(res, "resource", res.entity_key)
        if effective:
            items.append(EntityWithStatus.model_validate(effective))

    # Include draft-created resources (filter by category if specified)
    draft_creates = await draft_ctx.get_draft_creates("resource")
    for create in draft_creates:
        if category is None or create.get("category") == category:
            items.append(EntityWithStatus.model_validate(create))

    items.sort(key=lambda x: x.entity_key)
    next_cursor = items[-1].entity_key if has_next and items else None

    return EntityListResponse(items=items, next_cursor=next_cursor, has_next=has_next)


@router.get("/resources/{entity_key:path}", response_model=ResourceDetailResponse)
@limiter.limit(RATE_LIMITS["entity_read"])
async def get_resource(
    request: Request,
    entity_key: str,
    session: SessionDep,
    draft_ctx: DraftContextDep,
) -> ResourceDetailResponse:
    """Get resource detail with dynamic property fields.

    Uses path converter for entity_key to support hierarchical keys like "Person/John_doe".

    Rate limited to 200/minute per IP.
    """
    query = select(Resource).where(Resource.entity_key == entity_key)
    result = await session.execute(query)
    resource = result.scalar_one_or_none()

    effective = await draft_ctx.apply_overlay(resource, "resource", entity_key)

    if not effective:
        raise HTTPException(status_code=404, detail="Resource not found")

    # Extract dynamic properties (everything except reserved keys)
    reserved_keys = {"id", "entity_key", "label", "description", "category", "source_path",
                     "_change_status", "_deleted", "_patch_error"}
    properties = {k: v for k, v in effective.items() if k not in reserved_keys}

    return ResourceDetailResponse(
        entity_key=effective.get("entity_key", entity_key),
        label=effective.get("label", ""),
        description=effective.get("description"),
        category_key=effective.get("category", ""),
        properties=properties,
        change_status=effective.get("_change_status"),
        deleted=effective.get("_deleted", False),
    )


@router.get("/categories/{entity_key}/resources", response_model=list[EntityWithStatus])
@limiter.limit(RATE_LIMITS["entity_read"])
async def get_category_resources(
    request: Request,
    entity_key: str,
    session: SessionDep,
    draft_ctx: DraftContextDep,
) -> list[EntityWithStatus]:
    """Get resources belonging to a category (RSRC-05).

    Returns list of resources that have this category_key, with draft change status.

    Rate limited to 200/minute per IP.
    """
    # Verify category exists (optional - could skip if we want to allow querying for any category)
    cat_query = select(Category).where(Category.entity_key == entity_key)
    cat_result = await session.execute(cat_query)
    category = cat_result.scalar_one_or_none()

    if not category:
        # Check if draft-created category
        effective = await draft_ctx.apply_overlay(None, "category", entity_key)
        if not effective:
            raise HTTPException(status_code=404, detail="Category not found")

    # Query resources for this category
    query = select(Resource).where(Resource.category_key == entity_key).order_by(Resource.entity_key)
    result = await session.execute(query)
    resources = result.scalars().all()

    # Apply draft overlay to each resource
    items: list[EntityWithStatus] = []
    for res in resources:
        effective = await draft_ctx.apply_overlay(res, "resource", res.entity_key)
        if effective:
            items.append(EntityWithStatus.model_validate(effective))

    # Include draft-created resources for this category
    draft_creates = await draft_ctx.get_draft_creates("resource")
    for create in draft_creates:
        if create.get("category") == entity_key:
            items.append(EntityWithStatus.model_validate(create))

    items.sort(key=lambda x: x.entity_key)

    return items
```
  </action>
  <verify>
1. Run: `cd /home/daharoni/dev/ontology-hub && python -c "from app.routers.entities import list_dashboards, get_dashboard, list_resources, get_resource, get_category_resources; print('OK')"`

2. Run backend tests: `cd /home/daharoni/dev/ontology-hub/backend && python -m pytest tests/ -x -v --tb=short -q 2>&1 | tail -30`

3. Start backend and test endpoints manually:
   - GET http://localhost:8000/api/v2/dashboards should return list
   - GET http://localhost:8000/api/v2/dashboards/Core_overview should return dashboard with pages
   - GET http://localhost:8000/api/v2/resources should return list
   - GET http://localhost:8000/api/v2/resources/Person/John_doe should return resource
   - GET http://localhost:8000/api/v2/categories/Person/resources should return resources for Person
  </verify>
  <done>
All 5 endpoints functional:
- GET /dashboards returns paginated list with draft overlay
- GET /dashboards/{key} returns dashboard detail with pages array
- GET /resources returns paginated list with optional category filter
- GET /resources/{key:path} returns resource with dynamic properties
- GET /categories/{key}/resources returns resources for specified category
  </done>
</task>

</tasks>

<verification>
1. Import test for schemas:
   ```bash
   cd /home/daharoni/dev/ontology-hub
   python -c "from app.schemas.entity import DashboardPage, DashboardDetailResponse, ResourceDetailResponse; print('Schemas OK')"
   ```

2. Import test for endpoints:
   ```bash
   cd /home/daharoni/dev/ontology-hub
   python -c "from app.routers.entities import list_dashboards, get_dashboard, list_resources, get_resource, get_category_resources; print('Endpoints OK')"
   ```

3. Backend tests pass:
   ```bash
   cd /home/daharoni/dev/ontology-hub/backend
   python -m pytest tests/ -x -v --tb=short
   ```

4. Manual endpoint verification (if backend running):
   - `curl http://localhost:8000/api/v2/dashboards | jq`
   - `curl http://localhost:8000/api/v2/dashboards/Core_overview | jq`
   - `curl http://localhost:8000/api/v2/resources | jq`
   - `curl http://localhost:8000/api/v2/resources/Person/John_doe | jq`
   - `curl http://localhost:8000/api/v2/categories/Person/resources | jq`
</verification>

<success_criteria>
1. Three new Pydantic models in entity.py (DashboardPage, DashboardDetailResponse, ResourceDetailResponse)
2. Five new endpoints in entities.py following established patterns
3. All endpoints support draft_id query parameter for effective view
4. Backend tests pass
5. Endpoints return correct data structure matching existing entity patterns
</success_criteria>

<output>
After completion, create `.planning/phases/26-backend-api-endpoints/26-01-SUMMARY.md`
</output>
