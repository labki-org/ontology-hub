---
phase: 02-github-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/app/routers/__init__.py
  - backend/app/routers/entities.py
  - backend/app/routers/webhooks.py
  - backend/app/main.py
  - backend/app/schemas/entity.py
  - backend/app/schemas/__init__.py
  - backend/tests/test_entities_api.py
  - backend/tests/test_webhook.py
autonomous: true

must_haves:
  truths:
    - "User can retrieve entity by type and ID via API"
    - "User can list entities by type with pagination"
    - "Webhook handler verifies GitHub signature"
    - "Push events trigger re-indexing of changed files"
  artifacts:
    - path: "backend/app/routers/entities.py"
      provides: "Entity API endpoints"
      exports: ["router"]
    - path: "backend/app/routers/webhooks.py"
      provides: "GitHub webhook handler"
      exports: ["router"]
    - path: "backend/app/schemas/entity.py"
      provides: "Entity response schemas with pagination"
      exports: ["EntityListResponse"]
  key_links:
    - from: "backend/app/routers/entities.py"
      to: "backend/app/models/entity.py"
      via: "SQLModel query"
      pattern: "select.*Entity.*where"
    - from: "backend/app/routers/webhooks.py"
      to: "backend/app/services/indexer.py"
      via: "sync function call"
      pattern: "from app.services.indexer import"
    - from: "backend/app/routers/webhooks.py"
      to: "HMAC verification"
      via: "hmac.compare_digest"
      pattern: "hmac\\.compare_digest"
---

<objective>
Create Entity API endpoints for retrieving indexed data and webhook handler for processing GitHub push events.

Purpose: Expose indexed entity data via REST API and enable real-time re-indexing when the canonical repository changes.
Output: GET /entities/{type}/{id} endpoint, GET /entities/{type} with pagination, and POST /webhooks/github with signature verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 patterns
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Research for this phase
@.planning/phases/02-github-integration/02-RESEARCH.md

# Plan 02-01 output (will exist after 02-01 completes)
@.planning/phases/02-github-integration/02-01-SUMMARY.md

# Existing codebase
@backend/app/main.py
@backend/app/database.py
@backend/app/models/entity.py
@backend/app/routers/drafts.py
@backend/app/services/github.py
@backend/app/services/indexer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Entity API Endpoints with Pagination</name>
  <files>
    backend/app/routers/entities.py
    backend/app/routers/__init__.py
    backend/app/schemas/entity.py
    backend/app/schemas/__init__.py
    backend/app/main.py
  </files>
  <action>
**Create backend/app/schemas/entity.py:**

1. Define pagination response schema:
   ```python
   from typing import Optional
   from pydantic import BaseModel
   from app.models.entity import EntityPublic

   class EntityListResponse(BaseModel):
       items: list[EntityPublic]
       next_cursor: Optional[str] = None
       has_next: bool
   ```

**Update backend/app/schemas/__init__.py:**
- Export EntityListResponse

**Create backend/app/routers/entities.py:**

1. Create router with prefix `/entities` and tag `entities`

2. Implement `GET /{entity_type}/{entity_id}`:
   - Path parameter entity_type: EntityType enum
   - Path parameter entity_id: str
   - Query database for matching entity where deleted_at is None
   - Return EntityPublic
   - Return 404 if not found
   - Rate limit: 100/minute (use existing RATE_LIMITS pattern)

3. Implement `GET /{entity_type}`:
   - Path parameter entity_type: EntityType enum
   - Query params: cursor (Optional[str]), limit (int, default 20, max 100)
   - Use cursor-based pagination on entity_id (from research Pattern 6)
   - Return EntityListResponse with items, next_cursor, has_next
   - Filter where deleted_at is None
   - Order by entity_id for consistent pagination
   - Rate limit: 100/minute

4. Implement `GET /` (list all entity types):
   - Returns summary: count per entity_type
   - Useful for dashboard/overview

**Update backend/app/routers/__init__.py:**
- Import and export entities_router

**Update backend/app/main.py:**
- Import entities_router from routers
- Add: `app.include_router(entities_router, prefix="/api/v1")`
  </action>
  <verify>
- OpenAPI docs at http://localhost:8080/docs show new endpoints
- `curl http://localhost:8080/api/v1/entities/category` returns valid JSON (empty list if no data)
- `curl http://localhost:8080/api/v1/entities/category/NonExistent` returns 404
  </verify>
  <done>
Entity API endpoints exist with cursor-based pagination. Users can retrieve entities by type and ID, and list entities with pagination.
  </done>
</task>

<task type="auto">
  <name>Task 2: GitHub Webhook Handler with HMAC Verification</name>
  <files>
    backend/app/routers/webhooks.py
    backend/app/routers/__init__.py
    backend/app/main.py
  </files>
  <action>
**Create backend/app/routers/webhooks.py:**

1. Create router with prefix `/webhooks` and tag `webhooks`

2. Implement HMAC signature verification function (from research Pattern 4):
   ```python
   import hmac
   import hashlib
   from fastapi import Request, HTTPException

   async def verify_github_signature(request: Request) -> bytes:
       """Verify GitHub webhook signature and return raw body."""
       from app.config import settings

       # If no webhook secret configured, skip verification (dev mode)
       if not settings.GITHUB_WEBHOOK_SECRET:
           return await request.body()

       signature_header = request.headers.get("x-hub-signature-256")
       if not signature_header:
           raise HTTPException(status_code=403, detail="Missing signature header")

       body = await request.body()

       expected_signature = "sha256=" + hmac.new(
           settings.GITHUB_WEBHOOK_SECRET.encode("utf-8"),
           body,
           hashlib.sha256
       ).hexdigest()

       if not hmac.compare_digest(expected_signature, signature_header):
           raise HTTPException(status_code=403, detail="Invalid signature")

       return body
   ```

3. Implement `POST /github`:
   - Verify signature using function above
   - Parse JSON from raw body
   - Check `x-github-event` header
   - If event != "push", return {"status": "ignored", "event": event_type}
   - Extract changed files from payload:
     ```python
     changed_files = set()
     for commit in payload.get("commits", []):
         changed_files.update(commit.get("added", []))
         changed_files.update(commit.get("modified", []))
         changed_files.update(commit.get("removed", []))
     ```
   - Check for force push: `payload.get("forced", False)`
   - Use FastAPI BackgroundTasks to trigger sync:
     - If forced: full re-index
     - Else: incremental sync of changed files (can simplify to full re-index for v1)
   - Return {"status": "accepted", "files_changed": len(changed_files)}

4. Create incremental sync function (or use full sync for v1):
   ```python
   async def sync_changed_files(
       github_client: GitHubClient,
       session: AsyncSession,
       changed_files: list[str],
       commit_sha: str,
       deleted_files: list[str]
   ):
       # For v1, can just do full sync
       # For optimization, fetch only changed files and update
   ```

**Update backend/app/routers/__init__.py:**
- Import and export webhooks_router

**Update backend/app/main.py:**
- Import webhooks_router from routers
- Add: `app.include_router(webhooks_router, prefix="/api/v1")`
  </action>
  <verify>
- OpenAPI docs show POST /api/v1/webhooks/github endpoint
- Without GITHUB_WEBHOOK_SECRET set, webhook accepts any payload (dev mode)
- With secret set, invalid signature returns 403
- Valid push event returns {"status": "accepted", ...}
  </verify>
  <done>
Webhook handler processes GitHub push events with HMAC-SHA256 signature verification. Push events trigger background re-indexing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Tests for Entity API and Webhook</name>
  <files>
    backend/tests/test_entities_api.py
    backend/tests/test_webhook.py
  </files>
  <action>
**Create backend/tests/test_entities_api.py:**

1. Test entity retrieval:
   - Create entity in database via test_session
   - GET /api/v1/entities/{type}/{id} returns entity
   - GET for non-existent entity returns 404

2. Test entity listing:
   - Create multiple entities
   - GET /api/v1/entities/{type} returns list
   - Test pagination: create >20 entities, verify cursor and has_next

3. Test entity type filtering:
   - Create entities of different types
   - Each type endpoint only returns that type

**Create backend/tests/test_webhook.py:**

1. Test signature verification:
   - Mock GITHUB_WEBHOOK_SECRET in settings
   - Valid signature passes
   - Invalid signature returns 403
   - Missing signature header returns 403

2. Test push event handling:
   - POST with valid push payload
   - Returns {"status": "accepted", "files_changed": N}

3. Test non-push event ignored:
   - POST with x-github-event: "ping"
   - Returns {"status": "ignored", "event": "ping"}

4. Test no secret (dev mode):
   - Without GITHUB_WEBHOOK_SECRET, signature check is skipped

Follow existing test patterns from backend/tests/conftest.py and test_drafts_api.py.
  </action>
  <verify>
- `docker compose exec backend pytest backend/tests/test_entities_api.py -v` passes
- `docker compose exec backend pytest backend/tests/test_webhook.py -v` passes
- All tests pass: `docker compose exec backend pytest -v`
  </verify>
  <done>
Test coverage exists for entity API endpoints (retrieval, listing, pagination) and webhook handler (signature verification, event handling).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Entity API works:**
   - GET /api/v1/entities/category/{id} returns entity or 404
   - GET /api/v1/entities/category returns paginated list
   - Pagination cursor works correctly

2. **Webhook handler works:**
   - POST /api/v1/webhooks/github with valid signature triggers sync
   - Invalid signature returns 403
   - Non-push events are ignored gracefully

3. **End-to-end flow:**
   - POST /admin/sync populates entities
   - GET /api/v1/entities/category returns populated list
   - Simulated webhook payload triggers re-sync

4. **Tests pass:**
   - `pytest backend/tests/ -v` all green
</verification>

<success_criteria>
- GET /api/v1/entities/{type}/{id} returns entity by type and ID
- GET /api/v1/entities/{type} returns paginated entity list
- POST /api/v1/webhooks/github verifies HMAC signature
- Push events trigger background re-indexing
- Non-push events return ignored status
- Tests cover all endpoints and signature verification
- Phase 2 success criteria 3 and 4 from roadmap are met
</success_criteria>

<output>
After completion, create `.planning/phases/02-github-integration/02-02-SUMMARY.md`
</output>
