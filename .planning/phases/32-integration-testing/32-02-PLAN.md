---
phase: 32-integration-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/test_module_derived.py
autonomous: true

must_haves:
  truths:
    - "Derivation from category A with property P (Allows_value_from_category: B) includes category B's resources"
    - "Full chain verified: module categories -> properties -> referenced categories -> resources"
    - "All existing tests pass (no regressions)"
  artifacts:
    - path: "backend/tests/test_module_derived.py"
      provides: "E2E derivation chain test"
      contains: "test_derivation_chain_e2e"
  key_links:
    - from: "backend/tests/test_module_derived.py"
      to: "compute_module_derived_entities"
      via: "async function call"
      pattern: "compute_module_derived_entities"
---

<objective>
Add E2E derivation chain test and verify all existing tests pass.

Purpose: Fulfill INTG-04 (End-to-end derivation chain verified) by adding a comprehensive test that verifies the full chain: property with allowed_values references category, which includes its resources.

Output: Extended test_module_derived.py with E2E derivation chain test, all tests pass.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md (INTG-04)

# Key source files
@backend/tests/test_module_derived.py
@backend/app/services/module_derived.py

# Fixture patterns
@backend/tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add E2E Derivation Chain Test</name>
  <files>backend/tests/test_module_derived.py</files>
  <action>
Add a new test class to test_module_derived.py that verifies the complete derivation chain end-to-end using database fixtures instead of mocks.

Add this new test class at the END of the file:

```python
# ============================================================================
# End-to-End Derivation Chain Tests
# ============================================================================


class TestDerivationChainE2E:
    """End-to-end tests for derivation chain with database fixtures.

    These tests verify INTG-04: full derivation chain works:
    - Category A has property P1
    - P1 has Allows_value_from_category: "CategoryB"
    - Category B has resources R1, R2

    Derivation from [CategoryA] should produce:
    - properties: [P1, P2] (P1 from A, P2 from B)
    - resources: [R1, R2] (from B via P1's reference)
    """

    @pytest.mark.asyncio
    async def test_derivation_chain_includes_referenced_category_resources(
        self, test_session
    ):
        """Full derivation chain: category -> property -> referenced category -> resources.

        Setup:
        - CategoryA with required_properties: ["PropRef"]
        - PropRef with Allows_value_from_category: "CategoryB"
        - CategoryB (no properties)
        - ResourceInB belonging to CategoryB

        Expected result from compute_module_derived_entities(["CategoryA"]):
        - properties: ["PropRef"]
        - resources: ["ResourceInB"] (derived from CategoryB which was pulled in via PropRef)
        """
        from app.services.module_derived import compute_module_derived_entities
        from app.models.v2 import Category, Property, Resource

        # Create CategoryB first (it will be referenced)
        cat_b = Category(
            entity_key="CategoryB",
            source_path="categories/CategoryB.json",
            label="Category B",
            canonical_json={
                "name": "CategoryB",
                "required_properties": [],
                "optional_properties": [],
            },
        )
        test_session.add(cat_b)

        # Create property that references CategoryB
        prop_ref = Property(
            entity_key="PropRef",
            source_path="properties/PropRef.json",
            label="Property with reference",
            canonical_json={
                "name": "PropRef",
                "type": "page",
                "Allows_value_from_category": "CategoryB",
            },
        )
        test_session.add(prop_ref)

        # Create CategoryA that uses PropRef
        cat_a = Category(
            entity_key="CategoryA",
            source_path="categories/CategoryA.json",
            label="Category A",
            canonical_json={
                "name": "CategoryA",
                "required_properties": ["PropRef"],
                "optional_properties": [],
            },
        )
        test_session.add(cat_a)

        # Create resource belonging to CategoryB
        resource_in_b = Resource(
            entity_key="ResourceInB",
            source_path="resources/CategoryB/ResourceInB.json",
            label="Resource in B",
            category_key="CategoryB",
            canonical_json={
                "id": "ResourceInB",
                "category": "CategoryB",
                "label": "Resource in B",
            },
        )
        test_session.add(resource_in_b)

        await test_session.commit()

        # Now derive from CategoryA
        result = await compute_module_derived_entities(
            test_session,
            ["CategoryA"],
            draft_id=None,
            max_depth=10
        )

        # Verify the chain worked:
        # 1. PropRef should be in properties (from CategoryA directly)
        assert "PropRef" in result["properties"], \
            "PropRef should be derived from CategoryA"

        # 2. ResourceInB should be in resources (from CategoryB, which was pulled in via PropRef)
        assert "ResourceInB" in result["resources"], \
            "ResourceInB should be derived transitively via PropRef -> CategoryB"

    @pytest.mark.asyncio
    async def test_derivation_with_allowed_values_from_category_format(
        self, test_session
    ):
        """Test derivation with nested allowed_values.from_category format.

        Setup:
        - CategoryX with required_properties: ["PropNested"]
        - PropNested with allowed_values: {"from_category": "CategoryY"}
        - CategoryY with resource ResourceInY
        """
        from app.services.module_derived import compute_module_derived_entities
        from app.models.v2 import Category, Property, Resource

        # Create CategoryY (referenced category)
        cat_y = Category(
            entity_key="CategoryY",
            source_path="categories/CategoryY.json",
            label="Category Y",
            canonical_json={
                "name": "CategoryY",
                "required_properties": [],
                "optional_properties": [],
            },
        )
        test_session.add(cat_y)

        # Create property with nested format
        prop_nested = Property(
            entity_key="PropNested",
            source_path="properties/PropNested.json",
            label="Property with nested allowed_values",
            canonical_json={
                "name": "PropNested",
                "type": "page",
                "allowed_values": {"from_category": "CategoryY"},
            },
        )
        test_session.add(prop_nested)

        # Create CategoryX
        cat_x = Category(
            entity_key="CategoryX",
            source_path="categories/CategoryX.json",
            label="Category X",
            canonical_json={
                "name": "CategoryX",
                "required_properties": ["PropNested"],
                "optional_properties": [],
            },
        )
        test_session.add(cat_x)

        # Create resource in CategoryY
        resource_in_y = Resource(
            entity_key="ResourceInY",
            source_path="resources/CategoryY/ResourceInY.json",
            label="Resource in Y",
            category_key="CategoryY",
            canonical_json={
                "id": "ResourceInY",
                "category": "CategoryY",
                "label": "Resource in Y",
            },
        )
        test_session.add(resource_in_y)

        await test_session.commit()

        # Derive from CategoryX
        result = await compute_module_derived_entities(
            test_session,
            ["CategoryX"],
            draft_id=None,
            max_depth=10
        )

        # Verify nested format works
        assert "PropNested" in result["properties"]
        assert "ResourceInY" in result["resources"], \
            "Resource should be derived via allowed_values.from_category format"

    @pytest.mark.asyncio
    async def test_derivation_with_multiple_resources_per_category(
        self, test_session
    ):
        """Test derivation includes all resources from referenced category."""
        from app.services.module_derived import compute_module_derived_entities
        from app.models.v2 import Category, Property, Resource

        # Create CategoryWithManyResources
        cat_many = Category(
            entity_key="CategoryManyRes",
            source_path="categories/CategoryManyRes.json",
            label="Category with many resources",
            canonical_json={
                "name": "CategoryManyRes",
                "required_properties": [],
                "optional_properties": [],
            },
        )
        test_session.add(cat_many)

        # Create property referencing it
        prop = Property(
            entity_key="PropToMany",
            source_path="properties/PropToMany.json",
            label="Property to many",
            canonical_json={
                "name": "PropToMany",
                "Allows_value_from_category": "CategoryManyRes",
            },
        )
        test_session.add(prop)

        # Create entry category
        cat_entry = Category(
            entity_key="CategoryEntry",
            source_path="categories/CategoryEntry.json",
            label="Entry category",
            canonical_json={
                "name": "CategoryEntry",
                "required_properties": ["PropToMany"],
                "optional_properties": [],
            },
        )
        test_session.add(cat_entry)

        # Create multiple resources in CategoryManyRes
        for i in range(3):
            res = Resource(
                entity_key=f"Resource{i}",
                source_path=f"resources/CategoryManyRes/Resource{i}.json",
                label=f"Resource {i}",
                category_key="CategoryManyRes",
                canonical_json={
                    "id": f"Resource{i}",
                    "category": "CategoryManyRes",
                    "label": f"Resource {i}",
                },
            )
            test_session.add(res)

        await test_session.commit()

        result = await compute_module_derived_entities(
            test_session,
            ["CategoryEntry"],
            draft_id=None,
            max_depth=10
        )

        # All 3 resources should be included
        assert "Resource0" in result["resources"]
        assert "Resource1" in result["resources"]
        assert "Resource2" in result["resources"]
```

This test uses real database fixtures (from conftest.py's test_session) rather than mocks, providing true E2E verification.
  </action>
  <verify>
Run the new E2E tests:
```bash
cd /home/daharoni/dev/ontology-hub/backend && python -m pytest tests/test_module_derived.py::TestDerivationChainE2E -v
```
All new tests should pass.
  </verify>
  <done>
TestDerivationChainE2E class added to test_module_derived.py with 3 E2E tests verifying the full derivation chain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run All Tests and Verify No Regressions</name>
  <files></files>
  <action>
Run the complete test suite to verify:
1. All existing tests still pass
2. New tests from this phase pass
3. No import errors or configuration issues

Execute:
```bash
cd /home/daharoni/dev/ontology-hub/backend && python -m pytest tests/ -v --tb=short
```

If any tests fail:
- Fix broken tests immediately per CONTEXT.md regression handling rule
- Do not proceed until all tests pass

Common issues to watch for:
- Import errors (missing model imports in conftest)
- SQLite materialized view issues (tests should use draft-created categories or skip)
- Draft expiry issues (ensure expires_at is in the future)
  </action>
  <verify>
```bash
cd /home/daharoni/dev/ontology-hub/backend && python -m pytest tests/ -v --tb=short 2>&1 | tail -30
```
Output should show all tests passed with no failures.
  </verify>
  <done>
All tests pass. No regressions introduced. Test output shows:
- test_capability.py: PASSED
- test_draft_crud_dashboard_resource.py: PASSED
- test_module_derived.py: PASSED (including new E2E tests)
- test_pr_builder.py: PASSED (from Plan 01)
- test_rate_limiting.py: PASSED
- test_webhook.py: PASSED
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. test_module_derived.py has TestDerivationChainE2E class with 3 E2E tests
2. All existing tests pass
3. Derivation chain verified: category -> property -> referenced category -> resources
</verification>

<success_criteria>
- E2E derivation chain test passes showing:
  - Property with Allows_value_from_category derives the referenced category's resources
  - Property with allowed_values.from_category format also works
  - Multiple resources per category are all included
- All existing tests pass (no regressions)
- INTG-04 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/32-integration-testing/32-02-SUMMARY.md`
</output>
