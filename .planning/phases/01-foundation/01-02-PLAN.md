---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/dependencies/__init__.py
  - backend/app/dependencies/capability.py
  - backend/app/dependencies/rate_limit.py
  - backend/app/routers/__init__.py
  - backend/app/routers/drafts.py
  - backend/app/main.py
  - backend/app/models/draft.py
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/drafts creates draft and returns capability URL (no auth required)"
    - "GET /api/v1/drafts/{token} returns draft data only with valid token"
    - "Invalid or expired capability tokens return 404 (no information leakage)"
    - "Excessive POST requests to /drafts return 429 with Retry-After header"
    - "Capability tokens are stored as SHA-256 hashes only (never plaintext)"
  artifacts:
    - path: "backend/app/dependencies/capability.py"
      provides: "Token generation and validation"
      exports: ["generate_capability_token", "validate_capability_token", "hash_token"]
    - path: "backend/app/dependencies/rate_limit.py"
      provides: "SlowAPI rate limiter configuration"
      exports: ["limiter"]
    - path: "backend/app/routers/drafts.py"
      provides: "Draft CRUD endpoints"
      exports: ["router"]
  key_links:
    - from: "backend/app/routers/drafts.py"
      to: "backend/app/dependencies/capability.py"
      via: "dependency injection"
      pattern: "Depends.*validate_capability"
    - from: "backend/app/routers/drafts.py"
      to: "backend/app/dependencies/rate_limit.py"
      via: "decorator"
      pattern: "@limiter\\.limit"
    - from: "backend/app/main.py"
      to: "backend/app/routers/drafts.py"
      via: "router include"
      pattern: "include_router.*drafts"
---

<objective>
Capability URL security and rate limiting infrastructure

Purpose: Implement secure, token-based access to drafts via capability URLs (W3C pattern) and IP-based rate limiting to prevent abuse. This enables anonymous draft submission while maintaining security through cryptographic tokens rather than authentication.

Output: Working POST /drafts endpoint returning capability URL, GET /drafts/{token} secured by token validation, rate limiting with 429 responses.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Capability URL Token System</name>
  <files>
    backend/app/dependencies/__init__.py
    backend/app/dependencies/capability.py
    backend/app/models/draft.py
  </files>
  <action>
Implement W3C capability URL pattern for secure draft access:

**backend/app/dependencies/capability.py**:

Create module with these functions:

1. generate_capability_token(): Generate cryptographically secure token using secrets.token_urlsafe(32). This produces ~43 char base64url string with 256 bits entropy (W3C recommends 120+ bits minimum).

2. hash_token(token: str) -> str: Hash token with SHA-256 using hashlib.sha256(token.encode()).hexdigest(). Returns 64 char hex string. NEVER store plaintext tokens.

3. validate_capability_token(token: str, session: AsyncSession) -> Draft: Async dependency that hashes provided token, queries Draft by capability_hash, returns 404 for invalid OR expired (no distinction to prevent oracle attacks).

4. build_capability_url(token: str, base_url: str) -> str: Build URL with token in fragment (reduces referrer leakage). Format: "{base_url}/drafts#{token}"

**Update backend/app/models/draft.py**:
- Ensure capability_hash field has unique=True, index=True
- Add helper method for creating draft with auto-hashed token

**backend/app/dependencies/__init__.py**:
- Export key functions for easy imports

Security requirements (INFR-04):
- Use secrets.token_urlsafe() only (not uuid4, not random module)
- Store only SHA-256 hash in database
- Never log capability tokens or URLs
- Return 404 for both invalid and expired (no timing/existence oracle)
  </action>
  <verify>
Unit test the token functions:
- generate_capability_token() produces ~43 char string
- hash_token(token) produces 64 char hex string (SHA-256)
- Same token always produces same hash
- Different tokens produce different hashes

Integration test (after Task 2):
- Create draft, verify capability_hash in DB is 64 chars hex
- Verify token itself is NOT stored anywhere in database
  </verify>
  <done>
Token generation uses secrets module, tokens stored as SHA-256 hashes only, validation returns 404 for invalid/expired
  </done>
</task>

<task type="auto">
  <name>Task 2: Rate Limiting Configuration</name>
  <files>
    backend/app/dependencies/rate_limit.py
    backend/app/main.py
  </files>
  <action>
Implement IP-based rate limiting with SlowAPI:

**backend/app/dependencies/rate_limit.py**:

1. Create limiter using Limiter(key_func=get_remote_address) from slowapi

2. Create rate_limit_exceeded_handler async function that returns JSONResponse with:
   - status_code=429
   - headers={"Retry-After": str(exc.retry_after)}
   - content={"detail": "Rate limit exceeded", "retry_after": exc.retry_after}

3. Define RATE_LIMITS dict with constants:
   - "draft_create": "20/hour" (per user decision in CONTEXT.md)
   - "draft_read": "100/minute" (more lenient for reads)
   - "entity_list": "100/minute"
   - "entity_read": "200/minute"

**Update backend/app/main.py**:

1. Add limiter to app state: app.state.limiter = limiter

2. Register exception handler: app.add_exception_handler(RateLimitExceeded, rate_limit_exceeded_handler)

3. Add SecurityHeadersMiddleware that sets:
   - Referrer-Policy: origin (prevents capability URL leakage)
   - X-Content-Type-Options: nosniff
   - X-Frame-Options: DENY

Update requirements.txt to include slowapi>=0.1.9 if not present.

Critical: SlowAPI requires request: Request as explicit parameter in rate-limited endpoints.
  </action>
  <verify>
Test rate limiting by making rapid requests to draft creation endpoint. After ~20 requests should see 429 responses. Verify response includes Retry-After header.

Test security headers by checking response headers include Referrer-Policy: origin.
  </verify>
  <done>
SlowAPI configured with IP-based limiting, 429 responses include Retry-After, Referrer-Policy header set
  </done>
</task>

<task type="auto">
  <name>Task 3: Draft API Endpoints</name>
  <files>
    backend/app/routers/__init__.py
    backend/app/routers/drafts.py
    backend/app/schemas/__init__.py
    backend/app/schemas/draft.py
    backend/app/main.py
  </files>
  <action>
Create draft CRUD endpoints with capability URL security:

**backend/app/schemas/draft.py**:

Create Pydantic models:
1. DraftCreate: Request body with payload (dict), source_wiki (optional str), base_commit_sha (optional str)
2. DraftResponse: Full draft data for retrieval (id, status, payload, source_wiki, base_commit_sha, expires_at, created_at)
3. DraftCreateResponse: Creation response with capability_url, expires_at, message warning that URL cannot be recovered

**backend/app/routers/drafts.py**:

Create APIRouter with prefix="/drafts", tags=["drafts"]

1. POST "/" endpoint (create_draft):
   - Decorated with @limiter.limit(RATE_LIMITS["draft_create"])
   - Takes request: Request (REQUIRED for SlowAPI), draft_in: DraftCreate, session: SessionDep
   - Generates token, creates Draft with hashed token, saves to DB
   - Returns DraftCreateResponse with capability URL
   - Token shown ONCE in response, never retrievable again
   - Do NOT log the token or URL

2. GET "/{token}" endpoint (get_draft):
   - Decorated with @limiter.limit(RATE_LIMITS["draft_read"])
   - Takes request: Request, token: str, session: SessionDep
   - Uses validate_capability_token to verify token
   - Returns DraftResponse
   - Returns 404 for invalid or expired (no distinction)

**backend/app/routers/__init__.py**:
- Export router

**Update backend/app/main.py**:
- Import and include drafts router: app.include_router(drafts.router, prefix="/api/v1")

Critical requirements:
- request: Request MUST be explicit parameter (SlowAPI requirement)
- Token shown ONCE in creation response, never retrievable
- 404 for invalid/expired (no distinction, no oracle attack)
- Never log capability tokens or URLs
  </action>
  <verify>
Test draft creation:
1. POST to /api/v1/drafts with JSON payload
2. Verify response contains capability_url and expires_at
3. Extract token from capability_url (after the #)
4. GET /api/v1/drafts/{token} returns draft data

Test security:
1. GET with invalid token returns 404
2. Verify capability_hash in database is 64-char hex (not token)
  </verify>
  <done>
POST /drafts creates draft and returns capability URL, GET /drafts/{token} validates token and returns data, invalid tokens return 404
  </done>
</task>

</tasks>

<verification>
After all tasks complete, run full integration test:

1. **Create draft and verify capability URL:**
   - POST to /api/v1/drafts with test payload
   - Response should contain capability_url with fragment token

2. **Extract token and retrieve draft:**
   - Parse token from capability_url (after #)
   - GET /api/v1/drafts/{token} returns draft with status: "pending"

3. **Verify security (404 on invalid):**
   - GET /api/v1/drafts/badtoken123 returns 404

4. **Verify rate limiting:**
   - Rapid POST requests should return 429 after ~20 requests
   - 429 response includes Retry-After header

5. **Verify token hashing (not stored plaintext):**
   - Query database: SELECT capability_hash, LENGTH(capability_hash) FROM drafts
   - capability_hash should be 64 chars (SHA-256 hex)

6. **Verify security headers:**
   - Response headers include Referrer-Policy: origin
</verification>

<success_criteria>
- POST /api/v1/drafts accepts payload, returns capability URL (no auth required)
- GET /api/v1/drafts/{token} returns draft only with valid token
- Invalid/expired tokens return 404 (no information leakage)
- Rate limiting returns 429 with Retry-After header
- Capability tokens stored as SHA-256 hashes only
- Referrer-Policy header prevents token leakage
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
