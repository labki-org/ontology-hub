---
phase: 20-entity-management
plan: 06
type: execute
wave: 2
depends_on: ["20-01", "20-04"]
files_modified:
  - frontend/src/lib/dependencyChecker.ts
  - frontend/src/api/draftApiV2.ts
  - frontend/src/components/entity/DeleteConfirmation.tsx
  - frontend/src/components/layout/SidebarV2.tsx
  - frontend/src/stores/draftStoreV2.ts
autonomous: true

must_haves:
  truths:
    - "User can delete entity if it has no dependents"
    - "User sees error listing dependents when trying to delete entity with dependents"
    - "Deleted entity shows with Deleted badge and undo button in sidebar"
    - "Undo restores entity to previous state"
  artifacts:
    - path: "frontend/src/lib/dependencyChecker.ts"
      provides: "Utility to find entities that depend on a given entity"
      min_lines: 30
    - path: "frontend/src/components/entity/DeleteConfirmation.tsx"
      provides: "Error display showing dependent entities"
      min_lines: 40
    - path: "frontend/src/api/draftApiV2.ts"
      provides: "useDeleteEntityChange and useUndoDeleteChange mutations"
      contains: "useDeleteEntityChange"
  key_links:
    - from: "frontend/src/lib/dependencyChecker.ts"
      to: "frontend/src/stores/graphStore.ts"
      via: "graph nodes and edges for dependency analysis"
      pattern: "GraphNode|GraphEdge"
    - from: "frontend/src/components/layout/SidebarV2.tsx"
      to: "frontend/src/components/entity/DeleteConfirmation.tsx"
      via: "Delete confirmation display"
      pattern: "DeleteConfirmation"
---

<objective>
Implement entity deletion with dependency checking. Block deletion if entity has dependents (show which entities depend on it). Extend soft delete pattern from Phase 18 to sidebar with inline undo.

Purpose: Users can delete entities safely, with clear feedback about dependencies and easy undo.
Output: dependencyChecker.ts, DeleteConfirmation.tsx, delete/undo API hooks, updated SidebarV2
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-entity-management/20-CONTEXT.md
@frontend/src/stores/graphStore.ts
@frontend/src/lib/dependencyGraph.ts
@frontend/src/components/entity/form/DeletedItemBadge.tsx
@frontend/src/components/layout/SidebarV2.tsx
@backend/app/routers/draft_changes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dependency checker utility</name>
  <files>
    frontend/src/lib/dependencyChecker.ts
  </files>
  <action>
Create dependencyChecker.ts to find entities that depend on a given entity:

1. Use graph data from graphStore to find dependents:
   ```typescript
   import type { GraphNode, GraphEdge } from '@/api/types'

   export interface DependentEntity {
     entityKey: string
     entityType: string
     label: string
     relationshipType: string // e.g., "is parent of", "uses property"
   }

   /**
    * Find all entities that depend on the given entity.
    * An entity A depends on entity B if there's an edge from A to B
    * (A uses/inherits from/includes B).
    *
    * @param entityKey The entity to check dependents for
    * @param nodes All graph nodes
    * @param edges All graph edges
    * @returns Array of dependent entities
    */
   export function findDependents(
     entityKey: string,
     nodes: GraphNode[],
     edges: GraphEdge[]
   ): DependentEntity[] {
     const dependents: DependentEntity[] = []

     // Find edges where target is the entity being deleted
     // (source depends on target)
     for (const edge of edges) {
       if (edge.target === entityKey) {
         const sourceNode = nodes.find(n => n.id === edge.source)
         if (sourceNode) {
           dependents.push({
             entityKey: sourceNode.id,
             entityType: sourceNode.data?.entityType || 'unknown',
             label: sourceNode.data?.label || sourceNode.id,
             relationshipType: edge.data?.label || 'depends on',
           })
         }
       }
     }

     return dependents
   }

   /**
    * Check if an entity can be deleted (has no dependents).
    */
   export function canDelete(
     entityKey: string,
     nodes: GraphNode[],
     edges: GraphEdge[]
   ): { canDelete: boolean; dependents: DependentEntity[] } {
     const dependents = findDependents(entityKey, nodes, edges)
     return {
       canDelete: dependents.length === 0,
       dependents,
     }
   }
   ```

2. Export both functions
  </action>
  <verify>
    - dependencyChecker.ts exports findDependents and canDelete
    - Uses edges to find source nodes that depend on target
    - Returns structured DependentEntity array
  </verify>
  <done>
    - Dependency checker analyzes graph edges
    - Returns list of dependent entities with types and labels
    - canDelete provides boolean + dependents list
  </done>
</task>

<task type="auto">
  <name>Task 2: Add delete/undo mutations to draftApiV2</name>
  <files>
    frontend/src/api/draftApiV2.ts
  </files>
  <action>
Extend draftApiV2.ts with delete and undo mutations:

1. Add deleteEntityChange function:
   ```typescript
   async function deleteEntityChange(
     token: string,
     entityType: string,
     entityKey: string
   ): Promise<DraftChangeV2> {
     return apiFetch(`/drafts/${token}/changes`, {
       v2: true,
       method: 'POST',
       body: JSON.stringify({
         change_type: 'DELETE',
         entity_type: entityType,
         entity_key: entityKey,
       }),
     })
   }
   ```

2. Add useDeleteEntityChange mutation:
   ```typescript
   export function useDeleteEntityChange(token: string | undefined) {
     const queryClient = useQueryClient()

     return useMutation({
       mutationFn: ({ entityType, entityKey }: { entityType: string; entityKey: string }) =>
         deleteEntityChange(token!, entityType, entityKey),
       onSuccess: () => {
         // Invalidate to refresh sidebar
         queryClient.invalidateQueries({ queryKey: ['v2', 'draft-changes', token] })
         queryClient.invalidateQueries({ queryKey: ['v2', 'categories'] })
         queryClient.invalidateQueries({ queryKey: ['v2', 'properties'] })
         queryClient.invalidateQueries({ queryKey: ['v2', 'subobjects'] })
         queryClient.invalidateQueries({ queryKey: ['v2', 'templates'] })
         queryClient.invalidateQueries({ queryKey: ['v2', 'modules'] })
         queryClient.invalidateQueries({ queryKey: ['v2', 'bundles'] })
       },
     })
   }
   ```

3. Add useUndoDeleteChange mutation (removes the DELETE change):
   ```typescript
   export function useUndoDeleteChange(token: string | undefined) {
     const queryClient = useQueryClient()

     return useMutation({
       mutationFn: (changeId: string) =>
         apiFetch(`/drafts/${token}/changes/${changeId}`, {
           v2: true,
           method: 'DELETE',
         }),
       onSuccess: () => {
         // Same invalidation pattern
         queryClient.invalidateQueries({ queryKey: ['v2', 'draft-changes', token] })
         queryClient.invalidateQueries({ queryKey: ['v2', 'categories'] })
         // ... etc
       },
     })
   }
   ```
  </action>
  <verify>
    - useDeleteEntityChange exported and sends DELETE change_type
    - useUndoDeleteChange exported and removes change via DELETE endpoint
    - Both invalidate relevant query caches
  </verify>
  <done>
    - Delete mutation creates DELETE change record
    - Undo mutation removes the DELETE change record
    - Sidebar refreshes after both operations
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DeleteConfirmation and integrate into sidebar</name>
  <files>
    frontend/src/components/entity/DeleteConfirmation.tsx
    frontend/src/components/layout/SidebarV2.tsx
    frontend/src/stores/draftStoreV2.ts
  </files>
  <action>
**DeleteConfirmation.tsx:**

Create component showing deletion blocked with dependents list:
```tsx
import { AlertCircle } from 'lucide-react'
import type { DependentEntity } from '@/lib/dependencyChecker'

interface DeleteConfirmationProps {
  entityLabel: string
  dependents: DependentEntity[]
  onClose: () => void
}

export function DeleteConfirmation({
  entityLabel,
  dependents,
  onClose,
}: DeleteConfirmationProps) {
  return (
    <div className="p-4 border border-red-200 rounded bg-red-50 dark:bg-red-900/20 dark:border-red-800">
      <div className="flex items-start gap-2">
        <AlertCircle className="h-5 w-5 text-red-600 mt-0.5" />
        <div className="flex-1">
          <p className="font-medium text-red-900 dark:text-red-100">
            Cannot delete "{entityLabel}"
          </p>
          <p className="text-sm text-red-700 dark:text-red-300 mt-1">
            {dependents.length} {dependents.length === 1 ? 'entity depends' : 'entities depend'} on this item:
          </p>
          <ul className="mt-2 text-sm text-red-700 dark:text-red-300 list-disc list-inside max-h-32 overflow-auto">
            {dependents.map((dep) => (
              <li key={dep.entityKey}>
                {dep.label} ({dep.entityType}) - {dep.relationshipType}
              </li>
            ))}
          </ul>
          <button
            onClick={onClose}
            className="mt-3 text-sm text-red-600 hover:text-red-800 underline"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  )
}
```

**draftStoreV2.ts:**

Add state for tracking delete attempts:
```typescript
// Add to state
deletedEntityChanges: Map<string, string> // entityKey -> changeId (for undo)
deleteBlockedEntity: { key: string; dependents: DependentEntity[] } | null

// Add actions
trackDeletedEntity: (entityKey: string, changeId: string) => void
untrackDeletedEntity: (entityKey: string) => void
setDeleteBlocked: (entity: { key: string; dependents: DependentEntity[] } | null) => void
```

**SidebarV2.tsx:**

1. Add delete button to entity items (in draft mode):
   - Trash2 icon next to entity label
   - On click: check dependents via canDelete
   - If blocked: show DeleteConfirmation
   - If allowed: call deleteEntityChange mutation

2. Show DeletedItemBadge for deleted entities:
   - Check entity.change_status === 'deleted' or check deletedEntityChanges map
   - Show DeletedItemBadge with undo handler
   - Undo calls useUndoDeleteChange with stored changeId

3. Wire up delete flow in EntitySection
  </action>
  <verify>
    - DeleteConfirmation shows dependents list when deletion blocked
    - Sidebar shows delete button in draft mode
    - Deleted entities show DeletedItemBadge with undo
    - Undo restores entity (removes DELETE change)
  </verify>
  <done>
    - Dependency check blocks deletion with clear error
    - Soft delete pattern extended to sidebar
    - Undo available throughout draft session
    - User understands why deletion is blocked
  </done>
</task>

</tasks>

<verification>
1. Run `cd /home/daharoni/dev/ontology-hub/frontend && npm run build` - should pass
2. Test delete flow:
   - Try deleting entity with dependents -> see error
   - Delete entity without dependents -> shows Deleted badge
   - Click undo -> entity restored
3. Verify delete button only visible in draft mode
</verification>

<success_criteria>
- Dependency checker identifies all dependent entities
- Deletion blocked with clear error showing dependents
- Successful deletion shows DeletedItemBadge in sidebar
- Undo button restores entity throughout draft session
- Delete buttons only visible in draft mode
</success_criteria>

<output>
After completion, create `.planning/phases/20-entity-management/20-06-SUMMARY.md`
</output>
