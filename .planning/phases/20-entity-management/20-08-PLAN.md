---
phase: 20-entity-management
plan: 08
type: execute
wave: 3
depends_on: ["20-03", "20-05"]
files_modified:
  - frontend/src/components/entity/detail/CategoryDetail.tsx
  - frontend/src/components/entity/detail/ModuleDetail.tsx
  - frontend/src/components/entity/detail/BundleDetail.tsx
  - frontend/src/components/entity/EntityDetailPanel.tsx
autonomous: true

must_haves:
  truths:
    - "User can add relationships from entity detail views in edit mode"
    - "User can remove relationships from entity detail views in edit mode"
    - "Relationship changes auto-save like other field edits"
  artifacts:
    - path: "frontend/src/components/entity/detail/CategoryDetail.tsx"
      provides: "Category detail with EntityCombobox for parent editing"
      contains: "EntityCombobox"
    - path: "frontend/src/components/entity/detail/ModuleDetail.tsx"
      provides: "Module detail with relationship editing"
      contains: "EntityCombobox"
  key_links:
    - from: "frontend/src/components/entity/detail/CategoryDetail.tsx"
      to: "frontend/src/components/entity/forms/EntityCombobox.tsx"
      via: "Combobox for relationship editing"
      pattern: "EntityCombobox"
    - from: "frontend/src/components/entity/detail/CategoryDetail.tsx"
      to: "frontend/src/components/entity/forms/RelationshipChips.tsx"
      via: "Chips display for selected relationships"
      pattern: "RelationshipChips"
---

<objective>
Integrate EntityCombobox and RelationshipChips into existing entity detail views for editing relationships. This satisfies MGMT-08 (add dependencies to existing entities) by allowing relationship management in the detail modal/panel.

Purpose: Users can add/remove relationships (parent categories, properties, modules, etc.) from entity detail views, not just create forms.
Output: Updated CategoryDetail, ModuleDetail, BundleDetail with relationship editing
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-entity-management/20-CONTEXT.md
@frontend/src/components/entity/detail/CategoryDetail.tsx
@frontend/src/components/entity/forms/EntityCombobox.tsx
@frontend/src/components/entity/forms/RelationshipChips.tsx
@frontend/src/hooks/useAutoSave.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add relationship editing to CategoryDetail</name>
  <files>
    frontend/src/components/entity/detail/CategoryDetail.tsx
  </files>
  <action>
Update CategoryDetail.tsx to use EntityCombobox for parent editing:

1. Import new components:
   ```tsx
   import { EntityCombobox } from '../forms/EntityCombobox'
   import { RelationshipChips } from '../forms/RelationshipChips'
   import { useCategories } from '@/api/entitiesV2'
   ```

2. Fetch available categories for selection (excluding self):
   ```tsx
   const { data: categoriesData } = useCategories(undefined, undefined, draftId)
   const availableCategories = (categoriesData?.items || [])
     .filter(c => c.entity_key !== entityKey) // Exclude self
     .map(c => ({
       key: c.entity_key,
       label: c.label,
     }))
   ```

3. Replace current parent editing section (which uses simple Input) with:
   ```tsx
   {/* Parent Categories section */}
   <AccordionSection title="Parent Categories" defaultOpen>
     <div className="space-y-3">
       {/* Existing chips */}
       <RelationshipChips
         values={editedParents.filter(p => !deletedParents.has(p))}
         onRemove={handleDeleteParent}
         disabled={!isEditing}
         getLabel={(key) => {
           const cat = availableCategories.find(c => c.key === key)
           return cat?.label || key
         }}
       />

       {/* Deleted items stay in position */}
       {Array.from(deletedParents).map(parent => (
         <DeletedItemBadge
           key={parent}
           label={availableCategories.find(c => c.key === parent)?.label || parent}
           onUndo={() => handleUndoDeleteParent(parent)}
         />
       ))}

       {/* Add new parent - only in edit mode */}
       {isEditing && (
         <EntityCombobox
           entityType="category"
           availableEntities={availableCategories.filter(
             c => !editedParents.includes(c.key) && !deletedParents.has(c.key)
           )}
           selectedKeys={[]} // Single-add pattern
           onChange={(keys) => {
             if (keys.length > 0) {
               handleAddNewParent(keys[0])
             }
           }}
           onCreateNew={(id) => {
             // Open nested create modal
             openNestedCreateModal({
               entityType: 'category',
               prefilledId: id,
               parentContext: {
                 entityType: 'category',
                 fieldName: 'Parent Categories',
               },
             })
           }}
           placeholder="Add parent category..."
         />
       )}
     </div>
   </AccordionSection>
   ```

4. Update handleAddNewParent to use saveChange for auto-save:
   ```tsx
   const handleAddNewParent = useCallback((parentKey: string) => {
     const newParents = [...editedParents.filter(p => !deletedParents.has(p)), parentKey]
     setEditedParents(newParents)
     if (draftId) {
       saveChange([{ op: 'replace', path: '/parents', value: newParents }])
     }
   }, [editedParents, deletedParents, draftId, saveChange])
   ```

5. Add nested modal state access if not already present
  </action>
  <verify>
    - CategoryDetail uses EntityCombobox for adding parents
    - RelationshipChips displays current parents with remove
    - Adding/removing auto-saves via saveChange
    - Create-if-not-exists opens nested modal
  </verify>
  <done>
    - Parent category editing uses combobox pattern
    - Soft delete with undo preserved from Phase 18
    - Auto-save on relationship changes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add relationship editing to ModuleDetail</name>
  <files>
    frontend/src/components/entity/detail/ModuleDetail.tsx
  </files>
  <action>
Update ModuleDetail.tsx to edit module contents (categories, properties, subobjects, templates):

1. Import components and hooks

2. Fetch all entity types for selection:
   ```tsx
   const { data: categoriesData } = useCategories(undefined, undefined, draftId)
   const { data: propertiesData } = useProperties(undefined, undefined, draftId)
   const { data: subobjectsData } = useSubobjects(undefined, undefined, draftId)
   const { data: templatesData } = useTemplates(undefined, undefined, draftId)
   ```

3. Add sections for each entity type (use Tabs or Accordion):
   ```tsx
   <AccordionSection title="Categories" defaultOpen>
     <RelationshipChips
       values={editedCategories}
       onRemove={(key) => handleRemoveEntity('categories', key)}
       disabled={!isEditing}
     />
     {isEditing && (
       <EntityCombobox
         entityType="category"
         availableEntities={availableCategories}
         selectedKeys={editedCategories}
         onChange={(keys) => handleAddEntity('categories', keys)}
         placeholder="Add category..."
       />
     )}
   </AccordionSection>
   ```

4. Create generic handlers:
   ```tsx
   const handleAddEntity = (field: string, keys: string[]) => {
     // Update local state
     // Save via auto-save
   }

   const handleRemoveEntity = (field: string, key: string) => {
     // Update local state
     // Save via auto-save
   }
   ```

5. Repeat pattern for Properties, Subobjects, Templates sections
  </action>
  <verify>
    - ModuleDetail has sections for all 4 entity types
    - Each section uses EntityCombobox + RelationshipChips
    - Changes auto-save
    - Read-only when not in edit mode
  </verify>
  <done>
    - Module content editing via combobox
    - All 4 entity types manageable
    - Consistent UX with CategoryDetail
  </done>
</task>

<task type="auto">
  <name>Task 3: Add relationship editing to BundleDetail</name>
  <files>
    frontend/src/components/entity/detail/BundleDetail.tsx
  </files>
  <action>
Update BundleDetail.tsx to edit bundle modules:

1. Import components and useModules hook

2. Fetch available modules:
   ```tsx
   const { data: modulesData } = useModules(undefined, undefined, draftId)
   const availableModules = (modulesData?.items || []).map(m => ({
     key: m.entity_key,
     label: m.label,
   }))
   ```

3. Add modules editing section:
   ```tsx
   <AccordionSection title="Modules" defaultOpen>
     <RelationshipChips
       values={editedModules}
       onRemove={handleRemoveModule}
       disabled={!isEditing}
       getLabel={(key) => availableModules.find(m => m.key === key)?.label || key}
     />
     {isEditing && (
       <EntityCombobox
         entityType="module"
         availableEntities={availableModules.filter(
           m => !editedModules.includes(m.key)
         )}
         selectedKeys={[]}
         onChange={(keys) => {
           if (keys.length > 0) handleAddModule(keys[0])
         }}
         onCreateNew={(id) => {
           openNestedCreateModal({
             entityType: 'module',
             prefilledId: id,
             parentContext: {
               entityType: 'bundle',
               fieldName: 'Modules',
             },
           })
         }}
         placeholder="Add module..."
       />
     )}
   </AccordionSection>
   ```

4. Implement add/remove handlers with auto-save:
   ```tsx
   const handleAddModule = useCallback((moduleKey: string) => {
     const newModules = [...editedModules, moduleKey]
     setEditedModules(newModules)
     if (draftId) {
       saveChange([{ op: 'replace', path: '/modules', value: newModules }])
     }
   }, [editedModules, draftId, saveChange])

   const handleRemoveModule = useCallback((moduleKey: string) => {
     const newModules = editedModules.filter(m => m !== moduleKey)
     setEditedModules(newModules)
     if (draftId) {
       saveChange([{ op: 'replace', path: '/modules', value: newModules }])
     }
   }, [editedModules, draftId, saveChange])
   ```
  </action>
  <verify>
    - BundleDetail has modules editing section
    - EntityCombobox for adding modules
    - RelationshipChips for displaying/removing
    - Create-if-not-exists for modules
  </verify>
  <done>
    - Bundle module editing complete
    - Consistent with other detail views
    - MGMT-08 satisfied (add dependencies to existing entities)
  </done>
</task>

</tasks>

<verification>
1. Run `cd /home/daharoni/dev/ontology-hub/frontend && npm run build` - should pass
2. Test in draft mode:
   - Open category detail, add parent via combobox
   - Verify auto-save (check network tab or draft changes)
   - Open module detail, add category/property to module
   - Open bundle detail, add module to bundle
3. Verify read-only in browse mode (no combobox visible)
</verification>

<success_criteria>
- CategoryDetail: can add/remove parent categories
- ModuleDetail: can add/remove categories, properties, subobjects, templates
- BundleDetail: can add/remove modules
- All relationship changes auto-save
- Create-if-not-exists available for adding non-existent entities
- Edit controls hidden in browse mode
</success_criteria>

<output>
After completion, create `.planning/phases/20-entity-management/20-08-SUMMARY.md`
</output>
