---
phase: 05-draft-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/draft.py
  - backend/app/schemas/draft.py
  - backend/app/routers/drafts.py
  - backend/app/services/draft_diff.py
autonomous: true

must_haves:
  truths:
    - "API accepts POST with wiki_url, base_version, and entities payload"
    - "API returns capability URL plus full diff preview on successful creation"
    - "Invalid payloads (missing required fields) return 400 with error list"
    - "Draft accessible only via capability URL token"
    - "GET /drafts/{token}/diff returns computed diff vs canonical"
  artifacts:
    - path: "backend/app/services/draft_diff.py"
      provides: "Draft vs canonical diff computation"
      exports: ["compute_draft_diff"]
    - path: "backend/app/models/draft.py"
      provides: "Extended draft schemas"
      contains: "DraftPayload"
    - path: "backend/app/routers/drafts.py"
      provides: "Extended draft endpoints"
      exports: ["router"]
  key_links:
    - from: "backend/app/routers/drafts.py"
      to: "backend/app/services/draft_diff.py"
      via: "compute_draft_diff import"
      pattern: "from app\\.services\\.draft_diff import"
    - from: "backend/app/routers/drafts.py"
      to: "backend/app/models/draft.py"
      via: "DraftPayload schema"
      pattern: "DraftPayload"
---

<objective>
Extend draft API with proper payload format including wiki metadata and full schema data. Return capability URL plus diff preview on creation. Add endpoint for retrieving diff after creation.

Purpose: Enable wiki admins to submit drafts with validation and see immediate diff feedback without requiring separate API call.
Output: Extended draft API with diff computation, payload validation, and diff retrieval endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-draft-system/05-CONTEXT.md
@.planning/phases/05-draft-system/05-RESEARCH.md

Relevant codebase files:
@backend/app/routers/drafts.py - Current draft router with capability URL security
@backend/app/models/draft.py - Current draft model and schemas
@backend/app/services/versions.py - Pattern for diff computation (compute_entity_diff)
@backend/app/services/indexer.py - Canonical data fetching pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend draft models with payload schema and diff preview</name>
  <files>
    backend/app/models/draft.py
    backend/app/schemas/draft.py
  </files>
  <action>
Extend draft models in backend/app/models/draft.py:

1. Add DraftPayload schema with:
   - wiki_url: str (required) - source wiki URL
   - base_version: str (required) - git tag or commit SHA
   - entities: object with categories, properties, subobjects arrays
   - modules: optional array of module definitions
   - profiles: optional array of profile definitions

2. Add EntityDefinition schema for payload entities:
   - entity_id: str (required)
   - label: str (required)
   - description: Optional[str]
   - schema_definition: dict (the full entity data)

3. Add ValidationError schema:
   - field: str
   - message: str
   - severity: Literal["error", "warning"]

4. Update DraftCreate to accept DraftPayload instead of generic dict:
   - payload: DraftPayload (validated structure)

5. Update DraftCreateResponse to include:
   - capability_url: str
   - expires_at: datetime
   - diff_preview: Optional[dict] (the computed diff)
   - validation_warnings: list[ValidationError] (non-fatal warnings)

6. Add DraftDiffResponse schema matching VersionDiffResponse structure:
   - old_version: str (always "canonical")
   - new_version: str (always "draft")
   - categories, properties, subobjects, modules, profiles: ChangesByType

7. Add diff_preview field to Draft model:
   - diff_preview: Optional[dict] = Field(default=None, sa_column=Column(JSON))
   - Stores the computed diff for retrieval via GET /drafts/{token}/diff

Update schemas/draft.py re-exports to include new schemas.

Use Pydantic's ConfigDict for model config. Use JSON column for diff_preview storage.
  </action>
  <verify>
python -c "from app.models.draft import DraftPayload, DraftCreateResponse, DraftDiffResponse, ValidationError; print('Schemas import OK')"
  </verify>
  <done>
DraftPayload schema validates wiki_url, base_version as required fields. DraftCreateResponse includes diff_preview field. ValidationError schema exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create draft diff service</name>
  <files>
    backend/app/services/draft_diff.py
    backend/app/services/__init__.py
  </files>
  <action>
Create backend/app/services/draft_diff.py for computing diffs between draft payload and canonical data:

1. Create compute_draft_diff async function:
   - Args: payload (DraftPayload), session (AsyncSession)
   - Returns: DraftDiffResponse

2. Implementation:
   a. Fetch canonical entities from database:
      - Query Entity table for all entities (category, property, subobject)
      - Query Module and Profile tables
      - Build lookup maps by entity_id/module_id/profile_id

   b. For each entity type (categories, properties, subobjects):
      - Build draft_by_id map from payload.entities.{type}
      - Build canonical_by_id map from database entities
      - Compute added: in draft but not canonical
      - Compute deleted: in canonical but not draft
      - Compute modified: in both but schema_definition differs

   c. For modules and profiles (if provided in payload):
      - Similar comparison logic
      - Compare category_ids/module_ids arrays

   d. Return DraftDiffResponse with all changes grouped by type

3. Add helper function compute_changes_by_type:
   - Handles the common pattern of comparing two sets
   - Returns ChangesByType with added, modified, deleted arrays

4. Use existing Entity model's schema_definition field for comparison.

Reference backend/app/services/versions.py compute_entity_diff for pattern.

Update services/__init__.py to export compute_draft_diff.
  </action>
  <verify>
python -c "from app.services.draft_diff import compute_draft_diff; print('Draft diff service OK')"
  </verify>
  <done>
compute_draft_diff function computes field-level diff between draft payload and canonical database state. Returns structured response matching VersionDiffResponse format.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend draft router with diff endpoints</name>
  <files>
    backend/app/routers/drafts.py
  </files>
  <action>
Extend backend/app/routers/drafts.py with enhanced creation and diff endpoint:

1. Update create_draft endpoint:
   a. Change input type from DraftCreate to accept DraftPayload directly
   b. Validate required fields (wiki_url, base_version):
      - Return 400 with ValidationError list if missing
   c. Call compute_draft_diff to get diff_preview
   d. Store diff_preview in draft record (add diff_preview column to model if needed)
   e. Return DraftCreateResponse with capability_url, expires_at, diff_preview, validation_warnings

2. Add GET /drafts/{token}/diff endpoint:
   - Rate limit: RATE_LIMITS["draft_read"] (same as get_draft)
   - Validate capability token using existing validate_capability_token
   - Return stored diff_preview from draft record
   - Response model: DraftDiffResponse

3. Payload validation function validate_draft_payload:
   - Check wiki_url is valid URL format
   - Check base_version is not empty
   - Check entities has at least one array populated
   - Return list of ValidationError
   - Fatal errors (error severity) cause 400 response
   - Warnings (warning severity) included in response but draft created

4. Import compute_draft_diff from services.draft_diff

Pattern: Keep capability URL security unchanged. Token in path for retrieval endpoints.
  </action>
  <verify>
# Test draft creation with new payload format
curl -X POST http://localhost:8080/api/v1/drafts/ \
  -H "Content-Type: application/json" \
  -d '{
    "wiki_url": "https://wiki.example.org",
    "base_version": "v1.0.0",
    "entities": {
      "categories": [{"entity_id": "TestCategory", "label": "Test", "schema_definition": {}}],
      "properties": [],
      "subobjects": []
    }
  }' | jq '.capability_url, .diff_preview'

# Verify 400 on missing required fields
curl -X POST http://localhost:8080/api/v1/drafts/ \
  -H "Content-Type: application/json" \
  -d '{"entities": {"categories": []}}' -w "\n%{http_code}\n" | tail -1
# Should return 400
  </verify>
  <done>
POST /drafts/ accepts DraftPayload with wiki_url and base_version required. Returns capability_url plus diff_preview. GET /drafts/{token}/diff returns stored diff. Missing required fields return 400 with error list.
  </done>
</task>

</tasks>

<verification>
1. Draft creation with full payload returns capability URL and diff preview
2. Missing wiki_url or base_version returns 400
3. Draft retrieval via capability token still works
4. GET /drafts/{token}/diff returns computed diff
5. Rate limiting still applies to all endpoints
</verification>

<success_criteria>
- API accepts POST with wiki_url, base_version, entities payload
- Response includes capability_url and diff_preview
- Validation errors return 400 with error list
- Diff endpoint returns structured diff vs canonical
- All tests pass, no regressions in existing capability URL security
</success_criteria>

<output>
After completion, create `.planning/phases/05-draft-system/05-01-SUMMARY.md`
</output>
