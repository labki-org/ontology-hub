---
phase: 06-validation-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/validation/breaking.py
  - backend/app/services/validation/semver.py
  - backend/app/services/validation/validator.py
  - backend/app/services/validation/__init__.py
autonomous: true

must_haves:
  truths:
    - "Validation detects when property datatype changes"
    - "Validation detects when cardinality changes from multiple to single"
    - "Validation detects when cardinality relaxes from single to multiple"
    - "Validation detects when entities are removed"
    - "Validation suggests MAJOR for breaking changes"
    - "Validation suggests MINOR for additions and relaxations"
    - "Validation suggests PATCH for metadata-only changes"
    - "Overall semver suggestion uses highest severity from all changes"
  artifacts:
    - path: "backend/app/services/validation/breaking.py"
      provides: "Breaking change detection comparing draft to canonical"
      exports: ["detect_breaking_changes"]
    - path: "backend/app/services/validation/semver.py"
      provides: "Semver suggestion aggregation logic"
      exports: ["compute_semver_suggestion", "classify_change"]
    - path: "backend/app/services/validation/validator.py"
      provides: "Updated validator with breaking change detection"
      contains: "detect_breaking_changes"
  key_links:
    - from: "backend/app/services/validation/validator.py"
      to: "backend/app/services/validation/breaking.py"
      via: "import detect_breaking_changes"
      pattern: "from app.services.validation.breaking import detect_breaking_changes"
    - from: "backend/app/services/validation/validator.py"
      to: "backend/app/services/validation/semver.py"
      via: "import compute_semver_suggestion"
      pattern: "from app.services.validation.semver import compute_semver_suggestion"
---

<objective>
Add breaking change detection and semver classification to the validation engine.

Purpose: Help wiki admins understand the impact of their changes before creating a PR, distinguishing between breaking changes (MAJOR), new features (MINOR), and safe updates (PATCH).

Output: Validation warnings for breaking changes with suggested semver classification, aggregate semver recommendation for the entire draft.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-validation-engine/06-RESEARCH.md

# This plan runs in parallel with 06-01 (same wave)
# The validator.py will be updated by both - 06-01 creates it, 06-02 extends it
# If 06-01 completes first, 06-02 extends existing file
# If 06-02 runs first, create validator.py with breaking change support

# Existing code patterns
@backend/app/services/draft_diff.py
@backend/app/models/draft.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create breaking change detection module</name>
  <files>
    backend/app/services/validation/breaking.py
  </files>
  <action>
Create breaking change detection comparing draft entities to canonical database state.

Create `backend/app/services/validation/breaking.py`:
```python
"""Breaking change detection for draft payloads.

Detects changes that may break backward compatibility:
- MAJOR: Datatype changes, cardinality restrictions, entity removals
- MINOR: New entities, cardinality relaxations, new optional fields
- PATCH: Label/description changes only
"""
from typing import Any
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession
from app.schemas.validation import ValidationResult
from app.models.draft import DraftPayload
from app.models.entity import Entity, EntityType
from app.models.module import Module, Profile


async def fetch_canonical_entities_map(
    session: AsyncSession,
) -> dict[str, dict[str, dict[str, Any]]]:
    """Fetch all canonical entities organized by type.

    Returns:
        Dict with keys: categories, properties, subobjects, modules, profiles
        Each value is a dict mapping entity_id to entity data
    """
    result_map: dict[str, dict[str, dict[str, Any]]] = {
        "categories": {},
        "properties": {},
        "subobjects": {},
        "modules": {},
        "profiles": {},
    }

    # Fetch entities
    stmt = select(Entity).where(Entity.deleted_at.is_(None))
    result = await session.execute(stmt)
    for entity in result.scalars().all():
        type_key = f"{entity.entity_type.value}s"  # category -> categories
        if type_key in result_map:
            result_map[type_key][entity.entity_id] = {
                "entity_id": entity.entity_id,
                "label": entity.label,
                "description": entity.description,
                "schema_definition": entity.schema_definition,
            }

    # Fetch modules
    stmt_modules = select(Module).where(Module.deleted_at.is_(None))
    result_modules = await session.execute(stmt_modules)
    for module in result_modules.scalars().all():
        result_map["modules"][module.module_id] = {
            "module_id": module.module_id,
            "label": module.label,
            "description": module.description,
            "category_ids": module.category_ids,
            "dependencies": module.dependencies,
        }

    # Fetch profiles
    stmt_profiles = select(Profile).where(Profile.deleted_at.is_(None))
    result_profiles = await session.execute(stmt_profiles)
    for profile in result_profiles.scalars().all():
        result_map["profiles"][profile.profile_id] = {
            "profile_id": profile.profile_id,
            "label": profile.label,
            "description": profile.description,
            "module_ids": profile.module_ids,
        }

    return result_map


def _check_property_breaking_changes(
    entity_id: str,
    old_schema: dict[str, Any],
    new_schema: dict[str, Any],
) -> list[ValidationResult]:
    """Check a single property for breaking changes."""
    results: list[ValidationResult] = []

    # Datatype change detection
    old_datatype = old_schema.get("datatype")
    new_datatype = new_schema.get("datatype")

    if old_datatype and new_datatype and old_datatype != new_datatype:
        results.append(ValidationResult(
            entity_type="property",
            entity_id=entity_id,
            field="datatype",
            code="DATATYPE_CHANGED",
            message=f"Datatype changed from '{old_datatype}' to '{new_datatype}' - this is a breaking change",
            severity="warning",
            suggested_semver="major",
            old_value=old_datatype,
            new_value=new_datatype,
        ))

    # Cardinality change detection
    old_cardinality = old_schema.get("cardinality")
    new_cardinality = new_schema.get("cardinality")

    if old_cardinality == "multiple" and new_cardinality == "single":
        results.append(ValidationResult(
            entity_type="property",
            entity_id=entity_id,
            field="cardinality",
            code="CARDINALITY_RESTRICTED",
            message="Cardinality changed from 'multiple' to 'single' - this is a breaking change",
            severity="warning",
            suggested_semver="major",
            old_value="multiple",
            new_value="single",
        ))
    elif old_cardinality == "single" and new_cardinality == "multiple":
        results.append(ValidationResult(
            entity_type="property",
            entity_id=entity_id,
            field="cardinality",
            code="CARDINALITY_RELAXED",
            message="Cardinality changed from 'single' to 'multiple' - backward compatible",
            severity="info",
            suggested_semver="minor",
            old_value="single",
            new_value="multiple",
        ))

    return results


def _check_entity_metadata_changes(
    entity_type: str,
    entity_id: str,
    old_data: dict[str, Any],
    new_data: dict[str, Any],
) -> list[ValidationResult]:
    """Check for metadata-only changes (label, description)."""
    results: list[ValidationResult] = []

    old_label = old_data.get("label")
    new_label = new_data.get("label")
    if old_label and new_label and old_label != new_label:
        results.append(ValidationResult(
            entity_type=entity_type,
            entity_id=entity_id,
            field="label",
            code="LABEL_CHANGED",
            message=f"Label changed from '{old_label}' to '{new_label}'",
            severity="info",
            suggested_semver="patch",
            old_value=old_label,
            new_value=new_label,
        ))

    old_desc = old_data.get("description") or ""
    new_desc = new_data.get("description") or ""
    if old_desc != new_desc:
        results.append(ValidationResult(
            entity_type=entity_type,
            entity_id=entity_id,
            field="description",
            code="DESCRIPTION_CHANGED",
            message="Description changed",
            severity="info",
            suggested_semver="patch",
            old_value=old_desc[:50] + "..." if len(old_desc) > 50 else old_desc,
            new_value=new_desc[:50] + "..." if len(new_desc) > 50 else new_desc,
        ))

    return results


async def detect_breaking_changes(
    payload: DraftPayload,
    session: AsyncSession,
) -> list[ValidationResult]:
    """Detect breaking changes vs canonical data.

    Breaking changes (MAJOR):
    - Datatype changed (e.g., Text -> Number)
    - Cardinality changed from multiple to single
    - Entity removed (only if explicitly in draft as deleted)

    Non-breaking additions (MINOR):
    - New entity added
    - Cardinality changed from single to multiple (relaxation)
    - New optional field added

    Metadata changes (PATCH):
    - Label changed
    - Description changed
    """
    results: list[ValidationResult] = []

    # Fetch canonical entities
    canonical = await fetch_canonical_entities_map(session)

    # Build draft entity maps
    draft_categories = {c.entity_id: c for c in payload.entities.categories}
    draft_properties = {p.entity_id: p for p in payload.entities.properties}
    draft_subobjects = {s.entity_id: s for s in payload.entities.subobjects}

    # Check properties for breaking changes
    for prop in payload.entities.properties:
        entity_id = prop.entity_id

        if entity_id in canonical["properties"]:
            old_data = canonical["properties"][entity_id]
            new_data = {
                "entity_id": prop.entity_id,
                "label": prop.label,
                "description": prop.description,
                "schema_definition": prop.schema_definition,
            }

            # Check schema_definition changes
            results.extend(_check_property_breaking_changes(
                entity_id,
                old_data.get("schema_definition", {}),
                prop.schema_definition,
            ))

            # Check metadata changes
            results.extend(_check_entity_metadata_changes(
                "property", entity_id, old_data, new_data
            ))
        else:
            # New property added
            results.append(ValidationResult(
                entity_type="property",
                entity_id=entity_id,
                field=None,
                code="ENTITY_ADDED",
                message=f"New property '{entity_id}' added",
                severity="info",
                suggested_semver="minor",
            ))

    # Check categories for changes
    for category in payload.entities.categories:
        entity_id = category.entity_id

        if entity_id in canonical["categories"]:
            old_data = canonical["categories"][entity_id]
            new_data = {
                "entity_id": category.entity_id,
                "label": category.label,
                "description": category.description,
                "schema_definition": category.schema_definition,
            }

            # Check metadata changes
            results.extend(_check_entity_metadata_changes(
                "category", entity_id, old_data, new_data
            ))

            # Check for removed properties (breaking)
            old_props = set(old_data.get("schema_definition", {}).get("properties", []))
            new_props = set(category.schema_definition.get("properties", []))
            removed_props = old_props - new_props
            for removed_prop in removed_props:
                results.append(ValidationResult(
                    entity_type="category",
                    entity_id=entity_id,
                    field="properties",
                    code="PROPERTY_REMOVED",
                    message=f"Property '{removed_prop}' removed from category - this is a breaking change",
                    severity="warning",
                    suggested_semver="major",
                    old_value=removed_prop,
                ))

            # Check for added properties (minor)
            added_props = new_props - old_props
            for added_prop in added_props:
                results.append(ValidationResult(
                    entity_type="category",
                    entity_id=entity_id,
                    field="properties",
                    code="PROPERTY_ADDED",
                    message=f"Property '{added_prop}' added to category",
                    severity="info",
                    suggested_semver="minor",
                    new_value=added_prop,
                ))
        else:
            # New category added
            results.append(ValidationResult(
                entity_type="category",
                entity_id=entity_id,
                field=None,
                code="ENTITY_ADDED",
                message=f"New category '{entity_id}' added",
                severity="info",
                suggested_semver="minor",
            ))

    # Check subobjects for changes
    for subobject in payload.entities.subobjects:
        entity_id = subobject.entity_id

        if entity_id in canonical["subobjects"]:
            old_data = canonical["subobjects"][entity_id]
            new_data = {
                "entity_id": subobject.entity_id,
                "label": subobject.label,
                "description": subobject.description,
                "schema_definition": subobject.schema_definition,
            }

            results.extend(_check_entity_metadata_changes(
                "subobject", entity_id, old_data, new_data
            ))
        else:
            # New subobject added
            results.append(ValidationResult(
                entity_type="subobject",
                entity_id=entity_id,
                field=None,
                code="ENTITY_ADDED",
                message=f"New subobject '{entity_id}' added",
                severity="info",
                suggested_semver="minor",
            ))

    return results
```

Key design decisions:
- Breaking changes are warnings (not errors) because they're valid changes, just impactful
- Only analyze entities actually present in the draft (partial drafts don't trigger false "removed" warnings)
- Cardinality relaxation (single -> multiple) is considered backward compatible (MINOR)
- Property removal from category is breaking because existing instances may have that property
  </action>
  <verify>
    python -c "from app.services.validation.breaking import detect_breaking_changes, fetch_canonical_entities_map; print('Breaking change module imports OK')"
  </verify>
  <done>Breaking change detection identifies datatype changes, cardinality changes, property additions/removals from categories, and new entities with appropriate severity levels.</done>
</task>

<task type="auto">
  <name>Task 2: Create semver classification module</name>
  <files>
    backend/app/services/validation/semver.py
  </files>
  <action>
Create semver suggestion computation module.

Create `backend/app/services/validation/semver.py`:
```python
"""Semver classification for validation results.

Uses SchemaVer-inspired rules adapted for SemanticSchemas:
- MAJOR: Breaking changes that require consumer updates
- MINOR: Backward-compatible additions
- PATCH: Metadata-only changes
"""
from typing import Literal
from app.schemas.validation import ValidationResult

# Codes that indicate major (breaking) changes
MAJOR_CODES = {
    "DATATYPE_CHANGED",
    "CARDINALITY_RESTRICTED",
    "PROPERTY_REMOVED",
    "ENTITY_REMOVED",
}

# Codes that indicate minor (addition) changes
MINOR_CODES = {
    "ENTITY_ADDED",
    "PROPERTY_ADDED",
    "CARDINALITY_RELAXED",
}

# Codes that indicate patch (metadata) changes
PATCH_CODES = {
    "LABEL_CHANGED",
    "DESCRIPTION_CHANGED",
}


def classify_change(code: str) -> Literal["major", "minor", "patch"]:
    """Classify a change code into semver category.

    Args:
        code: The validation result code (e.g., "DATATYPE_CHANGED")

    Returns:
        Semver category: "major", "minor", or "patch"
    """
    if code in MAJOR_CODES:
        return "major"
    elif code in MINOR_CODES:
        return "minor"
    else:
        return "patch"


def compute_semver_suggestion(
    results: list[ValidationResult],
) -> tuple[Literal["major", "minor", "patch"], list[str]]:
    """Compute aggregate semver suggestion from validation results.

    Logic:
    - Any major suggestion -> overall major
    - No major, any minor -> overall minor
    - Otherwise -> patch

    Args:
        results: List of ValidationResult objects

    Returns:
        Tuple of (suggested_semver, reasons_list)
    """
    major_reasons: list[str] = []
    minor_reasons: list[str] = []
    patch_reasons: list[str] = []

    for result in results:
        if result.suggested_semver == "major":
            reason = f"{result.code}: {result.entity_id}"
            if result.old_value and result.new_value:
                reason += f" ({result.old_value} -> {result.new_value})"
            elif result.old_value:
                reason += f" (removed: {result.old_value})"
            major_reasons.append(reason)

        elif result.suggested_semver == "minor":
            reason = f"{result.code}: {result.entity_id}"
            if result.new_value:
                reason += f" ({result.new_value})"
            minor_reasons.append(reason)

        elif result.suggested_semver == "patch":
            patch_reasons.append(f"{result.code}: {result.entity_id}")

    # Determine overall suggestion (major > minor > patch)
    if major_reasons:
        return "major", major_reasons
    elif minor_reasons:
        return "minor", minor_reasons
    elif patch_reasons:
        return "patch", patch_reasons
    else:
        return "patch", ["No changes detected"]
```
  </action>
  <verify>
    python -c "from app.services.validation.semver import compute_semver_suggestion, classify_change, MAJOR_CODES, MINOR_CODES; print('Semver module imports OK'); print(f'Major codes: {MAJOR_CODES}')"
  </verify>
  <done>Semver classification module with MAJOR_CODES, MINOR_CODES, PATCH_CODES sets. compute_semver_suggestion aggregates results using max severity rule.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate breaking changes into validator</name>
  <files>
    backend/app/services/validation/validator.py
    backend/app/services/validation/__init__.py
  </files>
  <action>
Update the validator to include breaking change detection and proper semver computation.

Update `backend/app/services/validation/validator.py`:
```python
"""Main validation orchestrator for draft payloads."""
from sqlmodel.ext.asyncio.session import AsyncSession
from app.schemas.validation import DraftValidationReport, ValidationResult
from app.models.draft import DraftPayload
from app.services.validation.reference import check_references
from app.services.validation.inheritance import check_circular_inheritance
from app.services.validation.datatype import check_datatypes
from app.services.validation.breaking import detect_breaking_changes
from app.services.validation.semver import compute_semver_suggestion


async def validate_draft(
    payload: DraftPayload,
    session: AsyncSession,
) -> DraftValidationReport:
    """Run all validation checks on draft payload.

    Performs:
    1. Reference existence checks (VALD-01)
    2. Circular inheritance detection (VALD-02)
    3. Datatype validation (VALD-03)
    4. Breaking change detection (VALD-04)
    5. Semver classification (VALD-05)

    Args:
        payload: Validated draft payload with entities, modules, profiles
        session: Async database session for canonical data lookup

    Returns:
        DraftValidationReport with all findings and semver suggestion
    """
    results: list[ValidationResult] = []

    # 1. Reference existence checks (errors)
    results.extend(await check_references(payload, session))

    # 2. Circular inheritance detection (errors)
    results.extend(await check_circular_inheritance(payload, session))

    # 3. Datatype validation (errors)
    results.extend(check_datatypes(payload))

    # 4. Breaking change detection (warnings/info)
    results.extend(await detect_breaking_changes(payload, session))

    # Separate by severity
    errors = [r for r in results if r.severity == "error"]
    warnings = [r for r in results if r.severity == "warning"]
    info = [r for r in results if r.severity == "info"]

    # 5. Compute semver suggestion
    if errors:
        # Don't suggest semver until errors are resolved
        suggested_semver = "patch"
        semver_reasons = ["Resolve validation errors before semver classification"]
    else:
        # Filter to results with semver suggestions (breaking change results)
        semver_results = [r for r in results if r.suggested_semver]
        suggested_semver, semver_reasons = compute_semver_suggestion(semver_results)

    return DraftValidationReport(
        is_valid=len(errors) == 0,
        errors=errors,
        warnings=warnings,
        info=info,
        suggested_semver=suggested_semver,
        semver_reasons=semver_reasons,
    )
```

Update `backend/app/services/validation/__init__.py`:
```python
"""Validation services for draft payloads."""
from app.services.validation.validator import validate_draft
from app.services.validation.datatype import ALLOWED_DATATYPES
from app.services.validation.semver import compute_semver_suggestion, classify_change
from app.services.validation.breaking import detect_breaking_changes

__all__ = [
    "validate_draft",
    "ALLOWED_DATATYPES",
    "compute_semver_suggestion",
    "classify_change",
    "detect_breaking_changes",
]
```

Note: If Plan 01 hasn't created the base validator.py yet, this task creates the complete file. If Plan 01 has already created it, merge the breaking change imports and calls into the existing file.
  </action>
  <verify>
    python -c "from app.services.validation import validate_draft, detect_breaking_changes, compute_semver_suggestion; print('Full validation module imports OK')"
  </verify>
  <done>Validator orchestrates all 5 checks: references, inheritance, datatypes, breaking changes, semver. DraftValidationReport includes proper semver suggestion with reasons.</done>
</task>

</tasks>

<verification>
1. Create draft changing a property's datatype - should get DATATYPE_CHANGED warning with suggested_semver: "major"
2. Create draft relaxing cardinality from single to multiple - should get CARDINALITY_RELAXED info with suggested_semver: "minor"
3. Create draft with only label changes - should get LABEL_CHANGED info with suggested_semver: "patch"
4. Create draft with multiple change types - overall semver should be highest severity (major > minor > patch)
5. Create draft with validation errors - semver should be "patch" with reason "Resolve validation errors first"
</verification>

<success_criteria>
- Breaking change detection identifies: datatype changes, cardinality restrictions/relaxations, property additions/removals
- Semver classification: MAJOR for breaking, MINOR for additions, PATCH for metadata
- compute_semver_suggestion returns highest severity from all changes
- ValidationResult includes old_value/new_value for change context
- Info-level results don't block is_valid (only errors block)
- Warnings communicate impact without preventing submission
</success_criteria>

<output>
After completion, create `.planning/phases/06-validation-engine/06-02-SUMMARY.md`
</output>
