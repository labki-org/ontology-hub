---
phase: 06-validation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/schemas/validation.py
  - backend/app/services/validation/__init__.py
  - backend/app/services/validation/validator.py
  - backend/app/services/validation/reference.py
  - backend/app/services/validation/inheritance.py
  - backend/app/services/validation/datatype.py
  - backend/app/models/draft.py
  - backend/app/routers/drafts.py
  - backend/alembic/versions/004_draft_validation_results.py
autonomous: true

must_haves:
  truths:
    - "Validation checks that referenced parent categories exist"
    - "Validation checks that referenced properties exist"
    - "Validation checks that referenced subobjects exist"
    - "Validation checks that module member categories exist"
    - "Validation checks that module dependencies exist"
    - "Validation detects circular category inheritance"
    - "Validation checks property datatypes against allowed set"
  artifacts:
    - path: "backend/app/schemas/validation.py"
      provides: "ValidationResult and DraftValidationReport Pydantic schemas"
      exports: ["ValidationResult", "DraftValidationReport"]
    - path: "backend/app/services/validation/validator.py"
      provides: "Main validation orchestrator"
      exports: ["validate_draft"]
    - path: "backend/app/services/validation/reference.py"
      provides: "Reference existence checks"
      exports: ["check_references"]
    - path: "backend/app/services/validation/inheritance.py"
      provides: "Circular inheritance detection using graphlib"
      exports: ["check_circular_inheritance"]
    - path: "backend/app/services/validation/datatype.py"
      provides: "Datatype validation against SemanticMediaWiki set"
      exports: ["check_datatypes", "ALLOWED_DATATYPES"]
    - path: "backend/app/models/draft.py"
      provides: "validation_results field on DraftBase"
      contains: "validation_results"
  key_links:
    - from: "backend/app/routers/drafts.py"
      to: "backend/app/services/validation/validator.py"
      via: "import and call validate_draft"
      pattern: "from app.services.validation.validator import validate_draft"
    - from: "backend/app/services/validation/validator.py"
      to: "backend/app/services/validation/reference.py"
      via: "import check_references"
      pattern: "from app.services.validation.reference import check_references"
    - from: "backend/app/services/validation/inheritance.py"
      to: "graphlib"
      via: "TopologicalSorter for cycle detection"
      pattern: "from graphlib import TopologicalSorter"
---

<objective>
Create backend validation engine with reference existence checks, circular inheritance detection, and datatype validation for draft payloads.

Purpose: Enable wiki admins to receive immediate feedback on schema consistency errors before submitting PRs, catching issues like missing parent references, circular inheritance, and invalid datatypes.

Output: Validation service that runs on draft create/update, stores results in validation_results JSONB field, and exposes them in API responses.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-validation-engine/06-RESEARCH.md

# Prior phase summaries
@.planning/phases/05-draft-system/05-01-SUMMARY.md

# Existing code patterns
@backend/app/models/draft.py
@backend/app/services/draft_diff.py
@backend/app/routers/drafts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation schemas and service module structure</name>
  <files>
    backend/app/schemas/validation.py
    backend/app/services/validation/__init__.py
    backend/app/services/validation/datatype.py
  </files>
  <action>
Create validation schemas and datatype check module:

1. Create `backend/app/schemas/validation.py`:
```python
from typing import Literal, Optional
from pydantic import BaseModel

class ValidationResult(BaseModel):
    """Single validation finding with entity context."""
    entity_type: Literal["category", "property", "subobject", "module", "profile"]
    entity_id: str
    field: Optional[str] = None
    code: str  # e.g., "MISSING_PARENT", "CIRCULAR_INHERITANCE", "INVALID_DATATYPE"
    message: str
    severity: Literal["error", "warning", "info"]
    suggested_semver: Optional[Literal["major", "minor", "patch"]] = None
    old_value: Optional[str] = None
    new_value: Optional[str] = None

class DraftValidationReport(BaseModel):
    """Complete validation report for a draft."""
    is_valid: bool  # True if no errors (warnings OK)
    errors: list[ValidationResult]
    warnings: list[ValidationResult]
    info: list[ValidationResult]
    suggested_semver: Literal["major", "minor", "patch"]
    semver_reasons: list[str]
```

2. Create `backend/app/services/validation/__init__.py`:
```python
"""Validation services for draft payloads."""
from app.services.validation.validator import validate_draft
from app.services.validation.datatype import ALLOWED_DATATYPES

__all__ = ["validate_draft", "ALLOWED_DATATYPES"]
```

3. Create `backend/app/services/validation/datatype.py`:
```python
"""Datatype validation against SemanticMediaWiki allowed types."""
from app.schemas.validation import ValidationResult
from app.models.draft import DraftPayload

# SemanticMediaWiki allowed datatypes
# Reference: https://www.semantic-mediawiki.org/wiki/Help:List_of_datatypes
ALLOWED_DATATYPES = {
    "Annotation URI",
    "Boolean",
    "Code",
    "Date",
    "Email",
    "External identifier",
    "Geographic coordinates",
    "Keyword",
    "Monolingual text",
    "Number",
    "Page",
    "Quantity",
    "Record",
    "Reference",
    "Telephone number",
    "Temperature",
    "Text",
    "URL",
}

def check_datatypes(payload: DraftPayload) -> list[ValidationResult]:
    """Check property datatypes are in the allowed set."""
    results: list[ValidationResult] = []

    for prop in payload.entities.properties:
        schema = prop.schema_definition
        datatype = schema.get("datatype")

        if datatype and datatype not in ALLOWED_DATATYPES:
            results.append(ValidationResult(
                entity_type="property",
                entity_id=prop.entity_id,
                field="datatype",
                code="INVALID_DATATYPE",
                message=f"Datatype '{datatype}' is not valid. Allowed: {', '.join(sorted(ALLOWED_DATATYPES))}",
                severity="error",
            ))

    return results
```

Follow existing patterns from backend/app/schemas/ and backend/app/services/ for module structure.
  </action>
  <verify>
    python -c "from app.schemas.validation import ValidationResult, DraftValidationReport; from app.services.validation import validate_draft, ALLOWED_DATATYPES; print('Imports OK')"
  </verify>
  <done>ValidationResult and DraftValidationReport schemas exist. ALLOWED_DATATYPES constant has 18 SemanticMediaWiki types. Datatype check function implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Create reference and inheritance validation</name>
  <files>
    backend/app/services/validation/reference.py
    backend/app/services/validation/inheritance.py
    backend/app/services/validation/validator.py
  </files>
  <action>
Create reference existence checks and circular inheritance detection:

1. Create `backend/app/services/validation/reference.py`:
```python
"""Reference existence validation for draft payloads."""
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession
from app.schemas.validation import ValidationResult
from app.models.draft import DraftPayload
from app.models.entity import Entity, EntityType
from app.models.module import Module

async def get_canonical_entity_ids(session: AsyncSession, entity_type: EntityType) -> set[str]:
    """Get all entity IDs of given type from canonical database."""
    stmt = select(Entity.entity_id).where(
        Entity.entity_type == entity_type,
        Entity.deleted_at.is_(None)
    )
    result = await session.execute(stmt)
    return {row[0] for row in result.all()}

async def get_canonical_module_ids(session: AsyncSession) -> set[str]:
    """Get all module IDs from canonical database."""
    stmt = select(Module.module_id).where(Module.deleted_at.is_(None))
    result = await session.execute(stmt)
    return {row[0] for row in result.all()}

async def check_references(
    payload: DraftPayload,
    session: AsyncSession,
) -> list[ValidationResult]:
    """Check all referenced IDs exist in canonical or draft data.

    Validates:
    - Category parent references
    - Category property references
    - Category subobject references
    - Module category_ids
    - Module dependencies
    - Profile module_ids
    """
    results: list[ValidationResult] = []

    # Build sets of canonical IDs
    canonical_categories = await get_canonical_entity_ids(session, EntityType.CATEGORY)
    canonical_properties = await get_canonical_entity_ids(session, EntityType.PROPERTY)
    canonical_subobjects = await get_canonical_entity_ids(session, EntityType.SUBOBJECT)
    canonical_modules = await get_canonical_module_ids(session)

    # Build sets of draft IDs
    draft_categories = {c.entity_id for c in payload.entities.categories}
    draft_properties = {p.entity_id for p in payload.entities.properties}
    draft_subobjects = {s.entity_id for s in payload.entities.subobjects}
    draft_modules = {m.module_id for m in payload.modules}

    # Combined sets (canonical + draft)
    all_categories = canonical_categories | draft_categories
    all_properties = canonical_properties | draft_properties
    all_subobjects = canonical_subobjects | draft_subobjects
    all_modules = canonical_modules | draft_modules

    # Check category references
    for category in payload.entities.categories:
        schema = category.schema_definition

        # Parent reference
        parent = schema.get("parent")
        if parent and parent not in all_categories:
            results.append(ValidationResult(
                entity_type="category",
                entity_id=category.entity_id,
                field="parent",
                code="MISSING_PARENT",
                message=f"Parent category '{parent}' does not exist",
                severity="error",
            ))

        # Property references
        for prop_id in schema.get("properties", []):
            if prop_id not in all_properties:
                results.append(ValidationResult(
                    entity_type="category",
                    entity_id=category.entity_id,
                    field="properties",
                    code="MISSING_PROPERTY",
                    message=f"Property '{prop_id}' does not exist",
                    severity="error",
                ))

        # Subobject references
        for sub_id in schema.get("subobjects", []):
            if sub_id not in all_subobjects:
                results.append(ValidationResult(
                    entity_type="category",
                    entity_id=category.entity_id,
                    field="subobjects",
                    code="MISSING_SUBOBJECT",
                    message=f"Subobject '{sub_id}' does not exist",
                    severity="error",
                ))

    # Check module references
    for module in payload.modules:
        for cat_id in module.category_ids:
            if cat_id not in all_categories:
                results.append(ValidationResult(
                    entity_type="module",
                    entity_id=module.module_id,
                    field="category_ids",
                    code="MISSING_CATEGORY",
                    message=f"Category '{cat_id}' does not exist",
                    severity="error",
                ))

        for dep_id in module.dependencies:
            if dep_id not in all_modules:
                results.append(ValidationResult(
                    entity_type="module",
                    entity_id=module.module_id,
                    field="dependencies",
                    code="MISSING_MODULE",
                    message=f"Module dependency '{dep_id}' does not exist",
                    severity="error",
                ))

    # Check profile references
    for profile in payload.profiles:
        for mod_id in profile.module_ids:
            if mod_id not in all_modules:
                results.append(ValidationResult(
                    entity_type="profile",
                    entity_id=profile.profile_id,
                    field="module_ids",
                    code="MISSING_MODULE",
                    message=f"Module '{mod_id}' does not exist",
                    severity="error",
                ))

    return results
```

2. Create `backend/app/services/validation/inheritance.py`:
```python
"""Circular inheritance detection using Python graphlib."""
from graphlib import TopologicalSorter, CycleError
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession
from app.schemas.validation import ValidationResult
from app.models.draft import DraftPayload
from app.models.entity import Entity, EntityType

async def check_circular_inheritance(
    payload: DraftPayload,
    session: AsyncSession,
) -> list[ValidationResult]:
    """Detect circular inheritance in category parent relationships.

    Checks the full inheritance graph including both canonical and draft categories.
    Uses Python's graphlib.TopologicalSorter for cycle detection.
    """
    results: list[ValidationResult] = []

    # Build map of draft category parents
    draft_parents: dict[str, str | None] = {}
    for category in payload.entities.categories:
        draft_parents[category.entity_id] = category.schema_definition.get("parent")

    # Fetch canonical category parents (not in draft)
    stmt = select(Entity).where(
        Entity.entity_type == EntityType.CATEGORY,
        Entity.deleted_at.is_(None)
    )
    result = await session.execute(stmt)
    canonical_categories = result.scalars().all()

    canonical_parents: dict[str, str | None] = {}
    for cat in canonical_categories:
        if cat.entity_id not in draft_parents:
            canonical_parents[cat.entity_id] = cat.schema_definition.get("parent")

    # Combined parent map (draft overrides canonical)
    all_parents = {**canonical_parents, **draft_parents}

    # Build graph: child -> {parents}
    graph: dict[str, set[str]] = {}
    for category_id, parent in all_parents.items():
        if parent:
            graph[category_id] = {parent}
        else:
            graph[category_id] = set()

    # Use TopologicalSorter for cycle detection
    ts = TopologicalSorter(graph)

    try:
        ts.prepare()  # Raises CycleError if cycle exists
    except CycleError as e:
        # e.args[1] contains the cycle path
        cycle_path = e.args[1]
        cycle_str = " -> ".join(cycle_path)

        # Report error for each category in the cycle that's in the draft
        for category_id in set(cycle_path):
            if category_id in draft_parents:
                results.append(ValidationResult(
                    entity_type="category",
                    entity_id=category_id,
                    field="parent",
                    code="CIRCULAR_INHERITANCE",
                    message=f"Circular inheritance detected: {cycle_str}",
                    severity="error",
                ))

    return results
```

3. Create `backend/app/services/validation/validator.py`:
```python
"""Main validation orchestrator for draft payloads."""
from sqlmodel.ext.asyncio.session import AsyncSession
from app.schemas.validation import DraftValidationReport, ValidationResult
from app.models.draft import DraftPayload
from app.services.validation.reference import check_references
from app.services.validation.inheritance import check_circular_inheritance
from app.services.validation.datatype import check_datatypes

async def validate_draft(
    payload: DraftPayload,
    session: AsyncSession,
) -> DraftValidationReport:
    """Run all validation checks on draft payload.

    Checks:
    1. Reference existence (VALD-01)
    2. Circular inheritance detection (VALD-02)
    3. Datatype validation (VALD-03)

    Breaking change detection (VALD-04, VALD-05) is handled by Plan 02.
    """
    results: list[ValidationResult] = []

    # 1. Reference existence checks
    results.extend(await check_references(payload, session))

    # 2. Circular inheritance detection
    results.extend(await check_circular_inheritance(payload, session))

    # 3. Datatype validation
    results.extend(check_datatypes(payload))

    # Separate by severity
    errors = [r for r in results if r.severity == "error"]
    warnings = [r for r in results if r.severity == "warning"]
    info = [r for r in results if r.severity == "info"]

    # Default semver (will be enhanced by breaking change detection in Plan 02)
    suggested_semver = "patch"
    semver_reasons = ["No changes analyzed yet"]

    if errors:
        semver_reasons = ["Validation errors must be resolved first"]

    return DraftValidationReport(
        is_valid=len(errors) == 0,
        errors=errors,
        warnings=warnings,
        info=info,
        suggested_semver=suggested_semver,
        semver_reasons=semver_reasons,
    )
```
  </action>
  <verify>
    python -c "from app.services.validation.validator import validate_draft; from app.services.validation.reference import check_references; from app.services.validation.inheritance import check_circular_inheritance; print('All validation modules import OK')"
  </verify>
  <done>Reference check validates parent, property, subobject, module member, and dependency references. Inheritance check uses graphlib.TopologicalSorter. Validator orchestrates all checks.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate validation into draft API</name>
  <files>
    backend/app/models/draft.py
    backend/app/routers/drafts.py
    backend/alembic/versions/004_draft_validation_results.py
  </files>
  <action>
Add validation_results field to Draft model and integrate validation into endpoints:

1. Update `backend/app/models/draft.py` - add validation_results to DraftBase:
```python
class DraftBase(SQLModel):
    """Base model for Draft with common fields."""
    status: DraftStatus = DraftStatus.PENDING
    payload: dict = Field(default_factory=dict, sa_column=Column(JSON))
    source_wiki: Optional[str] = None
    base_commit_sha: Optional[str] = None
    diff_preview: Optional[dict] = Field(default=None, sa_column=Column(JSON))
    validation_results: Optional[dict] = Field(default=None, sa_column=Column(JSON))  # NEW
```

Also update DraftCreateResponse to include validation_results:
```python
class DraftCreateResponse(SQLModel):
    """Response schema for draft creation."""
    capability_url: str
    expires_at: datetime
    diff_preview: Optional[DraftDiffResponse] = None
    validation_results: Optional[dict] = None  # NEW - full validation report
    validation_warnings: list[ValidationError] = Field(default_factory=list)  # Keep for backward compat
    message: str = "Save this URL - it cannot be recovered. Use it to access your draft."
```

2. Create migration `backend/alembic/versions/004_draft_validation_results.py`:
```python
"""Add validation_results column to drafts

Revision ID: 004
Revises: 003
Create Date: 2026-01-22
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

revision = "004"
down_revision = "003"
branch_labels = None
depends_on = None

def upgrade() -> None:
    op.add_column(
        "drafts",
        sa.Column("validation_results", postgresql.JSON(), nullable=True),
    )

def downgrade() -> None:
    op.drop_column("drafts", "validation_results")
```

3. Update `backend/app/routers/drafts.py` - integrate validation into create_draft and update_draft:

In create_draft after computing diff_preview:
```python
from app.services.validation.validator import validate_draft

# Run validation engine
validation_report = await validate_draft(payload, session)

draft = Draft(
    capability_hash=hash_token(token),
    payload=payload.model_dump(),
    diff_preview=diff_preview.model_dump(),
    validation_results=validation_report.model_dump(),  # NEW
    source_wiki=payload.wiki_url,
    base_commit_sha=payload.base_version,
    expires_at=expires_at,
)

# Return with validation results
return DraftCreateResponse(
    capability_url=capability_url,
    expires_at=expires_at,
    diff_preview=diff_preview,
    validation_results=validation_report.model_dump(),  # NEW
    validation_warnings=validation_warnings,
    message="Save this URL - it cannot be recovered. Use it to access your draft.",
)
```

In update_draft (PATCH endpoint) after recomputing diff:
```python
# Recompute validation after update
updated_payload = DraftPayload(**draft.payload)
validation_report = await validate_draft(updated_payload, session)
draft.validation_results = validation_report.model_dump()
```
  </action>
  <verify>
    cd /home/daharoni/dev/ontology-hub/backend && alembic upgrade head && python -c "from app.models.draft import Draft; print('Draft model has validation_results:', hasattr(Draft, 'validation_results'))"
  </verify>
  <done>Draft model has validation_results JSONB field. Migration adds column. POST /drafts/ runs validation and returns results. PATCH /drafts/{token} recomputes validation on update.</done>
</task>

</tasks>

<verification>
1. Run backend tests: `cd backend && python -m pytest tests/ -v`
2. Create a draft with invalid parent reference - should return validation error
3. Create a draft with valid payload - validation_results.is_valid should be true
4. Create a draft with circular inheritance - should detect and report cycle
5. Create a draft with invalid datatype - should report INVALID_DATATYPE error
</verification>

<success_criteria>
- ValidationResult schema captures entity_type, entity_id, field, code, message, severity
- DraftValidationReport aggregates errors/warnings/info with is_valid flag
- Reference check catches missing parents, properties, subobjects, module members, dependencies
- Circular inheritance detected using graphlib.TopologicalSorter
- Datatype validation checks against 18 SemanticMediaWiki types
- validation_results field stored in database and returned in API responses
- Validation runs on both draft creation and update
</success_criteria>

<output>
After completion, create `.planning/phases/06-validation-engine/06-01-SUMMARY.md`
</output>
