---
phase: 30-frontend-detail-components
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - frontend/src/components/entity/detail/DashboardDetail.tsx
  - frontend/src/components/entity/detail/ResourceDetail.tsx
  - frontend/src/components/entity/EntityDetailPanel.tsx
autonomous: true

must_haves:
  truths:
    - "User can view dashboard with pages displayed in accordion"
    - "User can view resource with dynamic fields and category link"
    - "Clicking dashboard/resource in sidebar/graph shows correct detail"
    - "Edit mode enables inline editing when draft is active"
  artifacts:
    - path: "frontend/src/components/entity/detail/DashboardDetail.tsx"
      provides: "Dashboard detail view with pages accordion"
      min_lines: 100
    - path: "frontend/src/components/entity/detail/ResourceDetail.tsx"
      provides: "Resource detail view with dynamic fields"
      min_lines: 80
    - path: "frontend/src/components/entity/EntityDetailPanel.tsx"
      provides: "Detail routing with dashboard and resource cases"
      contains: "case 'dashboard':"
  key_links:
    - from: "DashboardDetail.tsx"
      to: "useDashboard hook"
      via: "import and call"
      pattern: "useDashboard\\(entityKey"
    - from: "ResourceDetail.tsx"
      to: "useResource hook"
      via: "import and call"
      pattern: "useResource\\(entityKey"
    - from: "EntityDetailPanel.tsx"
      to: "DashboardDetail and ResourceDetail"
      via: "switch case rendering"
      pattern: "case 'dashboard':|case 'resource':"
---

<objective>
Create DashboardDetail and ResourceDetail components following established patterns.

Purpose: Users need to view and edit dashboard and resource entities. This plan creates the detail views and registers them in EntityDetailPanel.

Output: Two new detail components (DashboardDetail.tsx, ResourceDetail.tsx) and updated EntityDetailPanel with routing for both types.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/30-frontend-detail-components/30-CONTEXT.md
@.planning/phases/30-frontend-detail-components/30-RESEARCH.md
@.planning/phases/30-frontend-detail-components/30-01-SUMMARY.md

# Pattern reference
@frontend/src/components/entity/detail/TemplateDetail.tsx
@frontend/src/components/entity/EntityDetailPanel.tsx
@frontend/src/api/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DashboardDetail component</name>
  <files>frontend/src/components/entity/detail/DashboardDetail.tsx</files>
  <action>
Create DashboardDetail.tsx following TemplateDetail.tsx pattern exactly.

Structure:
1. Props: entityKey, draftId?, draftToken?, isEditing
2. Data fetching: useDashboard(entityKey, draftId)
3. Type cast: data as DashboardDetailV2 | undefined
4. State tracking: originalValues for label, description
5. Local state: editedLabel, editedDescription
6. Ref: initializedEntityRef to prevent reset on refetch
7. Auto-save: useAutoSave hook with entityType: 'dashboard'
8. Effect: initialize state when entity changes (not on refetch)
9. Change handlers: use 'add' op (not 'replace' per CLAUDE.md)
10. Loading/error states

UI per CONTEXT.md decisions:
- EntityHeader with label, description, entityType="dashboard"
- AccordionSection for "Pages" containing Radix Accordion
- Accordion type="single" collapsible (one page open at a time)
- Each page: AccordionItem with name as trigger, wikitext in pre tag
- Raw wikitext display: `<pre className="whitespace-pre-wrap font-mono text-sm bg-muted/30 rounded-md p-4">`
- Empty pages: show "No pages defined" message

For nested pages (child pages): RESEARCH.md notes structure unclear. Implement flat list first. If pages have parent/children fields, add nested rendering later.

Edit mode:
- When isEditing=true, pages wikitext shown in Textarea (like TemplateDetail)
- Track pages modifications for VisualChangeMarker

Imports needed:
- useDashboard from '@/api/entities'
- useAutoSave from '@/hooks/useAutoSave'
- EntityHeader, AccordionSection from '../sections/'
- Accordion, AccordionContent, AccordionItem, AccordionTrigger from '@/components/ui/accordion'
- Textarea, Skeleton from '@/components/ui/'
- VisualChangeMarker from '../form/VisualChangeMarker'
- DashboardDetailV2, DashboardPage from '@/api/types'
  </action>
  <verify>
File exists and TypeScript compiles:
```bash
ls frontend/src/components/entity/detail/DashboardDetail.tsx
cd frontend && npx tsc --noEmit
```
  </verify>
  <done>
DashboardDetail.tsx exists, follows TemplateDetail pattern, displays pages in accordion, supports edit mode with draft.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ResourceDetail component</name>
  <files>frontend/src/components/entity/detail/ResourceDetail.tsx</files>
  <action>
Create ResourceDetail.tsx following TemplateDetail.tsx pattern.

Structure (same as Task 1 for state management):
1. Props: entityKey, draftId?, draftToken?, isEditing
2. Data fetching: useResource(entityKey, draftId)
3. Type cast: data as ResourceDetailV2 | undefined
4. State/refs/auto-save pattern from TemplateDetail

UI per CONTEXT.md decisions:
- EntityHeader with label, description, entityType="resource"
- Category shown as header link: clickable button that navigates to category detail
  - Use useGraphStore's setSelectedEntity(category_key, 'category')
  - Style: "text-primary hover:underline font-medium"
- AccordionSection for "Properties" or "Fields"
- Flat list layout for dynamic_fields: key-value pairs
- Each field: property name (label) and value display
- Handle different value types (string, number, array, object)

Dynamic fields display:
```tsx
<div className="space-y-3">
  {Object.entries(resource.dynamic_fields).map(([key, value]) => (
    <div key={key} className="flex flex-col">
      <span className="text-sm font-medium text-muted-foreground">{key}</span>
      <span className="text-sm">{formatValue(value)}</span>
    </div>
  ))}
</div>
```

formatValue helper function:
- string/number: return as-is
- array: join with ', '
- object: JSON.stringify with indent
- null/undefined: show italic "Not set"

Edit mode:
- Per CONTEXT.md: defer field validation to Phase 31 (create/edit forms)
- Show simple text input for each dynamic field when editing
- Track changes per field in originalValues

Imports needed:
- useResource from '@/api/entities'
- useGraphStore from '@/stores/graphStore'
- ResourceDetailV2 from '@/api/types'
- Plus same utility imports as DashboardDetail
  </action>
  <verify>
File exists and TypeScript compiles:
```bash
ls frontend/src/components/entity/detail/ResourceDetail.tsx
cd frontend && npx tsc --noEmit
```
  </verify>
  <done>
ResourceDetail.tsx exists, shows category as clickable link, displays dynamic_fields in flat list, supports edit mode.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register components in EntityDetailPanel</name>
  <files>frontend/src/components/entity/EntityDetailPanel.tsx</files>
  <action>
Update EntityDetailPanel.tsx to include dashboard and resource cases.

1. Add imports at top:
```tsx
import { DashboardDetail } from './detail/DashboardDetail'
import { ResourceDetail } from './detail/ResourceDetail'
```

2. Add cases in switch statement (after 'template' case):
```tsx
case 'dashboard':
  return <DashboardDetail {...props} />
case 'resource':
  return <ResourceDetail {...props} />
```

This enables navigation: when user clicks dashboard/resource in sidebar or graph, the correct detail component renders.
  </action>
  <verify>
```bash
grep -E "case 'dashboard':|case 'resource':" frontend/src/components/entity/EntityDetailPanel.tsx
cd frontend && npx tsc --noEmit
```
  </verify>
  <done>
EntityDetailPanel includes cases for 'dashboard' and 'resource', imports both components, TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
1. Both detail components exist in frontend/src/components/entity/detail/
2. EntityDetailPanel switch includes 'dashboard' and 'resource' cases
3. TypeScript compiles without errors
4. Components follow established patterns (useAutoSave, EntityHeader, AccordionSection)
</verification>

<success_criteria>
- DashboardDetail shows pages in accordion with raw wikitext display
- ResourceDetail shows category link and dynamic fields in flat list
- Both support edit mode when draft is active
- EntityDetailPanel routes to correct component for each type
- TypeScript compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-detail-components/30-02-SUMMARY.md`
</output>
