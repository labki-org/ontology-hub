# Project Research Summary: Ontology Hub v2.0

**Project:** Ontology Hub v2.0 Platform Rebuild
**Domain:** Schema/ontology management platform with graph visualization and draft workflow
**Researched:** 2026-01-23
**Confidence:** HIGH

---

## Executive Summary

Ontology Hub v2.0 is a full platform rebuild that transforms the data model from JSON-blob-with-runtime-computation to normalized-tables-with-precomputed-relationships. The existing stack (FastAPI + React 19 + PostgreSQL 17 + React Flow) is validated and requires only minimal additions: `jsonpatch` (Python) for RFC 6902 patch operations and `d3-polygon` for module hull computation. No new major frameworks or database extensions are needed.

The recommended approach is a phased rebuild starting with the database foundation (versioned canonical tables, relationship normalization, materialized inheritance views), then building the ingest pipeline, query layer, draft system, and finally the enhanced graph visualization. The key architectural shift is moving complexity from the client to the server: the API will always return "effective" data (canonical + draft overlay computed server-side), eliminating client-side merge logic.

The primary risks are (1) graph performance with 200+ nodes requiring careful memoization and stable node IDs, (2) JSON Patch array index instability requiring hybrid patch strategies, and (3) materialized view staleness requiring localized re-materialization. All risks have documented mitigations from established PostgreSQL and React Flow patterns.

---

## Key Findings

### Recommended Stack Additions

The existing v1.0 stack handles 95% of v2.0 requirements. Only two dependencies need to be added.

**New additions:**
- **jsonpatch (Python):** RFC 6902 implementation for backend patch operations -- most widely used (2M+ downloads/month), supports both `make_patch()` and `apply_patch()`
- **d3-polygon:** Convex hull computation for module overlays -- tiny (4KB), zero dependencies, standard D3 module

**Validated existing stack (no changes):**
- @xyflow/react v12 for graph visualization (stress-tested at 450 nodes)
- @dagrejs/dagre for hierarchical layout
- jsondiffpatch for frontend diff/patch (includes RFC 6902 formatter)
- zustand + immer for client state

**Explicitly rejected:**
- pg_ivm extension: Native REFRESH CONCURRENTLY sufficient for expected data sizes
- Cytoscape.js: React Flow already integrated and working; migration cost not justified
- Full D3 bundle: Only d3-polygon needed

### Expected Features

**Must have (table stakes):**
- Edge type filtering (inheritance vs all relationships)
- Module scope filtering (module page shows module entities only)
- Search-to-center (find entity, graph zooms to node)
- Zoom controls, pan/drag, minimap
- Node detail on hover/click (existing via navigation)

**Should have (differentiators):**
- Multi-hull module overlays (PRD requirement)
- Draft change badges on graph nodes (green/yellow/red for add/modify/delete)
- Change-only filter ("show changes only" toggle)
- Neighborhood expansion (1-hop expand on node click)
- Graph export (SVG/PNG for documentation)

**Defer to v2.1+:**
- Force-directed layout option
- Impact radius visualization
- Graph version diff mode
- Animated layout transitions
- Keyboard navigation

**Anti-features (do not build):**
- 3D visualization
- SPARQL query integration
- Real-time collaborative graph editing
- Graph-based schema creation

### Architecture Approach

The v2.0 architecture moves from "relationships stored in JSON, computed at query time" to "relationships stored in normalized tables, precomputed for fast reads, overlaid for drafts." The database schema introduces `ontology_version` for canonical version tracking, six entity tables (category, property, subobject, module, bundle, template), normalized relationship tables with version scope, and materialized views for precomputed inheritance.

**Major components:**
1. **Ingest Pipeline** -- Git fetch, JSON Schema validation, entity parsing, relationship building, materialized view refresh
2. **Query Layer** -- Version-scoped entity reads, relationship queries, graph response builder, draft overlay computation
3. **Draft System** -- JSON Patch storage (RFC 6902 for updates, full replacement for creates), localized re-materialization for inheritance changes
4. **Graph Visualization** -- React Flow with dagre layout, ViewportPortal for module hull overlays, memoized custom nodes

**Key simplification:** Frontend no longer merges draft changes with canonical data. The API always returns effective data (canonical + draft overlay computed server-side).

### Critical Pitfalls

1. **Graph Performance Collapse** -- React Flow becomes janky with 100+ nodes. Prevent with: memoize all custom components, stable node IDs (entity keys not auto-generated), batch state updates, debounce hull calculations (300-500ms), simplify node CSS.

2. **JSON Patch Array Index Instability** -- Array indices become invalid after insertions/deletions. Prevent with: configure jsondiffpatch objectHash using entity IDs, avoid array-index patches (use replace on entire array or object maps), version-lock patches to base state.

3. **Materialized View Staleness** -- Precomputed relationship tables become stale after partial updates. Prevent with: localized re-materialization (only affected subtree), version stamps on rows, REFRESH CONCURRENTLY for no-lock refresh.

4. **Draft Overlay Complexity Explosion** -- Computing effective state becomes exponential when drafts modify interdependent entities. Prevent with: topological sort on apply, cycle detection (already using graphlib.TopologicalSorter), memoized effective state, complexity bounds.

5. **Module Hull Overlap Confusion** -- Convex hulls include non-member nodes, multiple intersecting hulls create visual noise. Prevent with: layer-based display (one module at a time with toggle), concave hulls (alpha shapes) for tighter boundaries, interactive disambiguation on hover.

---

## Implications for Roadmap

Based on research, the suggested phase structure follows component dependencies and risk mitigation:

### Phase 1: Database Foundation
**Rationale:** All other phases depend on the v2.0 schema. Versioned canonical tables and relationship normalization are prerequisites for query layer and draft system.
**Delivers:** New database schema with ontology_version, entity tables (category, property, subobject, module, bundle, template), relationship tables (category_parent, category_property, etc.), materialized inheritance view.
**Addresses:** Version context for all reads, precomputed relationships, effective property computation
**Avoids:** Pitfall 3 (materialized view staleness) -- design in localized re-materialization from start

### Phase 2: Ingest Pipeline
**Rationale:** Populates the v2.0 schema; needed before query layer can return meaningful data.
**Delivers:** Git fetch service, JSON Schema validation, entity parsing, relationship builder, materialized view refresh trigger.
**Uses:** PostgreSQL recursive CTEs, REFRESH MATERIALIZED VIEW CONCURRENTLY
**Avoids:** Pitfall 10 (data migration schema mismatch) -- production data analysis informs parser edge cases

### Phase 3: Query Layer
**Rationale:** Core read path for all frontends; must work before draft system adds overlay complexity.
**Delivers:** Version-scoped entity reads, relationship queries (effective properties, where-used), graph response builder.
**Implements:** Version context in all API endpoints, graph data model for React Flow

### Phase 4: Draft System
**Rationale:** Most complex phase; depends on stable query layer. JSON Patch and effective state computation are novel patterns requiring careful implementation.
**Delivers:** Draft and draft_change tables, JSON Patch integration (RFC 6902), draft overlay computation, localized re-materialization.
**Avoids:** Pitfall 4 (JSON Patch array instability) -- hybrid patch format, objectHash configuration. Pitfall 5 (draft overlay complexity) -- topological sort, memoization.

### Phase 5: Graph Visualization
**Rationale:** Requires query layer for data and draft system for change badges. Performance-critical; should be designed with mitigations from start.
**Delivers:** Full ontology graph view, module hull overlays (d3-polygon), draft change badges, edge/node filtering, search-to-center.
**Uses:** React Flow ViewportPortal, d3-polygon, stable node IDs (entity keys)
**Avoids:** Pitfall 1 (graph performance) -- memoization, stable IDs, debounced hulls. Pitfall 2 (hull overlap) -- layer-based display option.

### Phase 6: Frontend Migration
**Rationale:** After backend is complete; removes client-side merge logic, updates API client for version context.
**Delivers:** Simplified draft store (no merge logic), version context in API client, updated graph components.
**Avoids:** Pitfall 9 (feature parity gaps) -- comprehensive v1.0 feature audit, behavior comparison testing.

### Phase 7: Data Migration and Cutover
**Rationale:** Final phase; requires all new components working. Run v1.0 and v2.0 in parallel during transition.
**Delivers:** Data migration from v1.0 tables, integration testing, v1.0 table deprecation.
**Avoids:** Pitfall 10 (data migration mismatch) -- validation step, rollback plan.

### Phase Ordering Rationale

- **Foundation first:** Schema design sets constraints for everything else; cannot be retrofitted
- **Ingest before query:** Need data in tables before reads make sense
- **Query before draft:** Draft overlay extends query layer; must have stable base
- **Draft before graph:** Change badges depend on draft state
- **Graph last in core build:** Most visible but depends on all backend work
- **Migration last:** Requires complete feature parity before cutover

### Research Flags

**Phases likely needing deeper research during planning:**
- **Phase 4 (Draft System):** JSON Patch edge cases with arrays, localized re-materialization algorithm details
- **Phase 5 (Graph Visualization):** Hull overlap disambiguation UX, performance testing with real ontology sizes

**Phases with standard patterns (skip research-phase):**
- **Phase 1 (Database Foundation):** Well-documented PostgreSQL patterns
- **Phase 2 (Ingest Pipeline):** Standard ETL pattern with existing GitHubClient
- **Phase 3 (Query Layer):** Evolution of v1.0 patterns with version context
- **Phase 6 (Frontend Migration):** Simplification, removal of complexity
- **Phase 7 (Data Migration):** Standard migration patterns

---

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | Existing stack validated; additions are minimal and well-documented (jsonpatch, d3-polygon) |
| Features | MEDIUM-HIGH | Table stakes verified against WebVOWL, Neo4j Browser, Cytoscape; draft overlay is novel |
| Architecture | HIGH | Based on v1.0 codebase analysis + established PostgreSQL patterns |
| Pitfalls | HIGH | Multiple authoritative sources (React Flow docs, RFC 6902, PostgreSQL docs) |

**Overall confidence:** HIGH

### Gaps to Address

- **Hull overlap UX:** Research identifies problem and mitigations, but specific UX design needs user testing during Phase 5
- **Template entity structure:** Need to analyze labki-schemas template format before Phase 1 schema finalization
- **Performance thresholds:** Research cites 450-node stress test, but real labki-schemas data size needs profiling

---

## Sources

### Primary (HIGH confidence)
- [React Flow Performance Guide](https://reactflow.dev/learn/advanced-use/performance) -- memoization, stable IDs
- [React Flow Stress Test](https://reactflow.dev/examples/nodes/stress) -- 450 nodes verified
- [React Flow ViewportPortal](https://reactflow.dev/api-reference/components/viewport-portal) -- custom overlays
- [PostgreSQL Recursive CTEs](https://www.postgresql.org/docs/current/queries-with.html) -- inheritance traversal
- [PostgreSQL Materialized Views](https://www.postgresql.org/docs/current/rules-materializedviews.html) -- refresh patterns
- [RFC 6902 - JSON Patch](https://www.rfc-editor.org/rfc/rfc6902.html) -- patch specification
- [python-json-patch PyPI](https://pypi.org/project/jsonpatch/) -- v1.33, verified API
- [D3 Polygon Documentation](https://d3js.org/d3-polygon) -- hull computation

### Secondary (MEDIUM confidence)
- [WebVOWL GitHub](https://github.com/VisualDataWeb/WebVOWL) -- ontology visualization patterns
- [Neo4j Graph Visualization](https://neo4j.com/docs/getting-started/graph-visualization/graph-visualization/) -- navigation patterns
- [Cytoscape.js](https://js.cytoscape.org/) -- feature comparison
- [jsondiffpatch Formatters](https://github.com/benjamine/jsondiffpatch/blob/master/docs/formatters.md) -- RFC 6902 output
- [pg_ivm Extension](https://github.com/sraoss/pg_ivm) -- incremental view maintenance (not recommended for v2.0)

### Tertiary (LOW confidence)
- [Visualizing Overlapping Node Groups (WZB)](https://datascience.blog.wzb.eu/2018/05/11/visualizing-graphs-with-overlapping-node-groups/) -- hull overlap patterns
- [gsgdt-rs Graph Diff](https://github.com/vn-ki/gsgdt-rs) -- change badge inspiration

---

*Research completed: 2026-01-23*
*Ready for roadmap: yes*
